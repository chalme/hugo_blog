[{"content":" 此文章主要整理了 macos 个人常用的软件。软件分为 appstore 和 brew两个来源。 brew软件来源一般都是开源的项目。\nappstore 工具 Justfocus 番茄工作\nCaffeinated 避免 mac 睡眠\niShot 截图软件，功能齐全。 也可以用 xnip 等代替。\nbrew 资源 软件 clashx github\nClashX 旨在提供一个简单轻量化的代理客户端\ncalibre github\nThe official source code repository for the calibre ebook manager\nmotrix A full-featured download manager\nlisten1 github\nListen 1 可以搜索和播放来自多个主流音乐网站的歌曲，让你的曲库更全面。并支持收藏功能，方便的创建自己的歌单。\nNetNewsWire github\nIt’s a free and open source feed reader for macOS and iOS.\namethyst github\nAutomatic tiling window manager for macOS à la xmonad.\nrectangle github\nMove and resize windows on macOS with keyboard shortcuts and snap areas\naerial github\nApple TV Aerial Screensaver for Mac. 屏幕保护程序\nblurred github\nA macOS utility that helps reduce distraction by dimming your inactive noise.（专注当前的 app）\nhidden github An ultra-light MacOS utility that helps hide menu bar icons\ncheatsheet official\nJust hold the ⌘-Key a bit longer to get a list of all active shortcuts of the current application. It\u0026rsquo;s as simple as that.(展示当前 App 快捷键或修改）\nclean-me github\nA macOS system analyser and cleaner\neul github\n🖥️ macOS status monitoring app written in SwiftUI.\nkeka github\nThe macOS file archiver\nmonitorcontrol github\n🖥 Control your display\u0026rsquo;s brightness \u0026amp; volume on your Mac as if it was a native Apple Display. Use Apple Keyboard keys or custom shortcuts. Shows the native macOS OSDs.(控制显示器)\nmaccy github\nLightweight clipboard manager for macOS\nuPic github\n📤uPic is a native, powerful, beautiful and simple picture and file upload tool for macOS.\n笔记 fsnotes github\nNotes manager for macOS/iOS\nnotable github\nThe Markdown-based note-taking app that doesn\u0026rsquo;t suck.\n开发 AnotherRedisDesktopManager github\nintellij-idea iterm2 syncthing github\nOpen Source Continuous File Synchronization\nvimrc github\ngit clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime sh ~/.vim_runtime/install_awesome_vimrc.sh 其他 swiftbar github\nPowerful macOS menu bar customization tool\nHammerspoon github\nThis is a tool for powerful automation of OS X. At its core, Hammerspoon is just a bridge between the operating system and a Lua scripting engine.\nCakebrew Manage your Homebrew formulas with style using Cakebrew. github\niptv https://github.com/iptv-org/iptv\ncommand fzf fzf is a general-purpose command-line fuzzy finder.\nwrk github\na HTTP benchmarking tool\nmkcert github\nA simple zero-config tool to make locally trusted development certificates with any names you\u0026rsquo;d like.\nbrew install clashx; brew install netnewswire; brew install calibre; brew install motrix; brew install listen1; brew install netnewswire; brew install amethyst; brew install rectangle; brew install aerial; brew install blurred; brew install hiddenbar; brew install cheatsheet; brew install clean-me; brew install eul; brew install fsnotes; brew install keka; brew install maccy; brew install monitorcontrol; brew install rectangle; brew install upic; brew install another-redis-desktop-manager; brew install cakebrew; brew install iterm2; brew install intellij-idea; brew install syncthing; brew install swiftbar; brew install hammerspoon; brew install fzf; brew install wrk; ","permalink":"https://blog.chalme.top/posts/macos/macos-software/","summary":"此文章主要整理了 macos 个人常用的软件。软件分为 appstore 和 brew两个来源。 brew软件来源一般都是开源的项目。\nappstore 工具 Justfocus 番茄工作\nCaffeinated 避免 mac 睡眠\niShot 截图软件，功能齐全。 也可以用 xnip 等代替。\nbrew 资源 软件 clashx github\nClashX 旨在提供一个简单轻量化的代理客户端\ncalibre github\nThe official source code repository for the calibre ebook manager\nmotrix A full-featured download manager\nlisten1 github\nListen 1 可以搜索和播放来自多个主流音乐网站的歌曲，让你的曲库更全面。并支持收藏功能，方便的创建自己的歌单。\nNetNewsWire github\nIt’s a free and open source feed reader for macOS and iOS.\namethyst github\nAutomatic tiling window manager for macOS à la xmonad.","title":"Macos Software"},{"content":"概述 sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n基础 -E -- use extended regular expressions -a -- delay opening files listed with w function -e -- specify sed commands to run -f -- add contents of file to commands to run -i -- edit files in-place, running scripts separately for each file -l -- make output line buffered -n -- suppress automatic printing of pattern space a,append 追加 i,insert 插入 d,delete 删除 s,substitution 替换 c,change 修改 y,transform 转换 替换 替换标记 s（substitution）默认情况下只替换每行中出现的第一处。使用替换标记（substitution flag）指定替换位置。替换标记在替换命令字符串之后设置。 s/pattern/replacement/flags 有4种可用的替换标记：\n数字，表明新文本将替换第几处模式匹配的地方； g，表明新文本将会替换所有匹配的文本； p，表明替换过的行要打印出来； w file，将替换的结果写到文件中。 替换字符 sed允许选择其他字符来作为替换命令中的字符串分隔符：\nsed \u0026#39;s!/bin/bash!/bin/csh!\u0026#39; /etc/passwd 使用地址 默认情况下，sed命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（line addressing）。\n以数字形式表示行区间 用文本模式来过滤出行 格式 [address]command 以数字形式表示行区间 sed \u0026#39;2s/dog/cat/\u0026#39; data1.txt sed \u0026#39;2,3s/dog/cat/\u0026#39; data1.txt sed \u0026#39;2,$s/dog/cat/\u0026#39; data1.txt 使用文本模式过滤器 sed编辑器允许指定文本模式来过滤出命令要作用的行 /pattern/command\nsed -n \u0026#39;/special/s/test/dog/p\u0026#39; data1.txt 命令组合 sed \u0026#39;2{ \u0026gt; s/fox/elephant/ \u0026gt; s/dog/cat/ \u0026gt; }\u0026#39; data1.txt 删除行 删除命令d删除匹配指定寻址模式的所有行。如果没有加入寻址模式，流中的所有文本行都会被删除。\nsed \u0026#39;1d\u0026#39; data1.txt sed \u0026#39;/spe/d\u0026#39; data1.txt 插入和附加文本 插入（insert）命令（i）会在指定行前增加一个新行； 附加（append）命令（a）会在指定行后增加一个新行。 sed \u0026#39;[address]command\\ new line\u0026#39; $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;i\\Test Line 1\u0026#39; Test Line 1 Test Line 2 $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;a\\Test Line 1\u0026#39; Test Line 2 Test Line 1 #在命令行上使用sed时，会看到次提示符来提醒输入新的行数据。必须在该行完成sed编辑器命令。 $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;i\\ \u0026gt; Test Line 1\u0026#39; Test Line 1 Test Line 2 修改行 修改（change）命令(c)允许修改(替换)数据流中整行文本的内容.如果作用于地址区间，sed会用一行文本代替区间内的所有行，而非逐一替换。\nsed \u0026#39;1,2c\\ hello \u0026#39; data1.txt 转换命令 转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。转换命令格式如下: [address]y/inchars/outchars/\n回顾打印 3个命令也能用来打印数据流中的信息： p命令用来打印文本行； 等号（=）命令用来打印行号； l（小写的L）命令用来列出行。\n使用sed处理文件 写入文件 w命令用来向文件写入行 [address]w filename\n从文件读取数据 读取（read）命令（r）将一个独立文件中的数据插入到数据流中 [address]r filename\nhttps://jixiaocan.github.io/posts/cmd-sed/ https://markrepo.github.io/commands/2018/06/26/sed/ ","permalink":"https://blog.chalme.top/posts/linux/command/sed/","summary":"概述 sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n基础 -E -- use extended regular expressions -a -- delay opening files listed with w function -e -- specify sed commands to run -f -- add contents of file to commands to run -i -- edit files in-place, running scripts separately for each file -l -- make output line buffered -n -- suppress automatic printing of pattern space a,append 追加 i,insert 插入 d,delete 删除 s,substitution 替换 c,change 修改 y,transform 转换 替换 替换标记 s（substitution）默认情况下只替换每行中出现的第一处。使用替换标记（substitution flag）指定替换位置。替换标记在替换命令字符串之后设置。 s/pattern/replacement/flags 有4种可用的替换标记：","title":"Sed"},{"content":"First This is first post !!! hji h-\nh-title\ntest hello, world!\n","permalink":"https://blog.chalme.top/posts/first/","summary":"First This is first post !!! hji h-\nh-title\ntest hello, world!","title":"First"},{"content":"Iterator pattern(迭代器模式) 这个模式已经被整合入Java的Collection.在大多数场合下无需自己制造一个Iterator,只要将对象装入Collection中，直接使用Iterator进行对象遍历.更多\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.11-iterator/","summary":"Iterator pattern(迭代器模式) 这个模式已经被整合入Java的Collection.在大多数场合下无需自己制造一个Iterator,只要将对象装入Collection中，直接使用Iterator进行对象遍历.更多","title":"3.11 Iterator"},{"content":"Visitor pattern (访问者模式) 作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.\n在Java中,Visitor模式实际上是分离了collection结构中的元素和对这些元素进行操作的行为. 为何使用Visitor? Java的Collection(包括Vector和Hashtable)是我们最经常使用的技术,可是Collection好象是个黑色大染缸,本来有各种鲜明类型特征的对象一旦放入后,再取出时,这些类型就消失了.那么我们势必要用If来判断,如:\nIterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Collection) messyPrintCollection((Collection)o); else if (o instanceof String) System.out.println(\u0026#34;\u0026#39;\u0026#34;+o.toString()+\u0026#34;\u0026#39;\u0026#34;); else if (o instanceof Float) System.out.println(o.toString()+\u0026#34;f\u0026#34;); else System.out.println(o.toString()); } 在上例中,我们使用了 instanceof来判断 o的类型.\n很显然,这样做的缺点代码If else if 很繁琐.我们就可以使用Visitor模式解决它.\n如何使用Visitor? 针对上例,定义接口叫Visitable,用来定义一个Accept操作,也就是说让Collection每个元素具备可访问性.\n被访问者是我们Collection的每个元素Element,我们要为这些Element定义一个可以接受访问的接口(访问和被访问是互动的,只有访问者,被访问者如果表示不欢迎,访问者就不能访问),取名为Visitable，也可取名为Element。\npublic interface Visitable { public void accept(Visitor visitor); } 被访问的具体元素继承这个新的接口Visitable：\npublic class StringElement implements Visitable { private String value; public StringElement(String string) { value = string; } public String getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.visitString(this); } } 上面是被访问者是字符串类型，下面再建立一个Float类型的：\npublic class FloatElement implements Visitable { private Float value; public FloatElement(Float value) { this.value = value; } public Float getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.visitFloat(this); } } 我们设计一个接口visitor访问者，在这个接口中,有一些访问操作，这些访问操作是专门访问对象集合Collection中有可能的所有类，目前我们假定有三个行为：访问对象集合中的字符串类型；访问对象集合中的Float类型；访问对象集合中的对象集合类型。注意最后一个类型是集合嵌套，通过这个嵌套实现可以看出使用访问模式的一个优点。\n接口visitor访问者如下：\npublic interface Visitor { public void visitString(StringElement stringE); public void visitFloat(FloatElement floatE); public void visitCollection(Collection collection); } 访问者的实现:\npublic class ConcreteVisitor implements Visitor { //在本方法中,我们实现了对Collection的元素的成功访问 public void visitCollection(Collection collection) { Iterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Visitable) ((Visitable)o).accept(this); } ｝ public void visitString(StringElement stringE) { System.out.println(\u0026#34;\u0026#39;\u0026#34;+stringE.getValue()+\u0026#34;\u0026#39;\u0026#34;); } public void visitFloat(FloatElement floatE){ System.out.println(floatE.getValue().toString()+\u0026#34;f\u0026#34;); } } 在上面的visitCollection我们实现了对Collection每个元素访问,只使用了一个判断语句,只要判断其是否可以访问.\nStringElement只是一个实现，可以拓展为更多的实现，整个核心奥妙在accept方法中，在遍历Collection时，通过相应的accept方法调用具体类型的被访问者。这一步确定了被访问者类型，\n如果是StringElement，而StringElement则回调访问者的visiteString方法，这一步实现了行为操作方法。\n客户端代码：\nVisitor visitor = new ConcreteVisitor(); StringElement stringE = new StringElement(\u0026#34;I am a String\u0026#34;); visitor.visitString(stringE); Collection list = new ArrayList(); list.add(new StringElement(\u0026#34;I am a String1\u0026#34;)); list.add(new StringElement(\u0026#34;I am a String2\u0026#34;)); list.add(new FloatElement(new Float(12))); list.add(new StringElement(\u0026#34;I am a String3\u0026#34;)); visitor.visitCollection(list); 客户端代码中的list对象集合中放置了多种数据类型，对对象集合中的访问不必象一开始那样，使用instance of逐个判断，而是通过访问者模式巧妙实现了。\n至此,我们完成了Visitor模式基本结构.\n使用Visitor模式的前提 使用访问者模式是对象群结构中(Collection) 中的对象类型很少改变。\n在两个接口Visitor和Visitable中,确保Visitable很少变化,也就是说，确保不能老有新的Element元素类型加进来，可以变化的是访问者行为或操作，也就是Visitor的不同子类可以有多种,这样使用访问者模式最方便.\n如果对象集合中的对象集合经常有变化, 那么不但Visitor实现要变化，Visistable也要增加相应行为，GOF建议是,不如在这些对象类中直接逐个定义操作，无需使用访问者设计模式。\n但是在Java中，Java的Reflect技术解决了这个问题，因此结合reflect反射机制，可以使得访问者模式适用范围更广了。\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.10-visitor/","summary":"Visitor pattern (访问者模式) 作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.\n在Java中,Visitor模式实际上是分离了collection结构中的元素和对这些元素进行操作的行为. 为何使用Visitor? Java的Collection(包括Vector和Hashtable)是我们最经常使用的技术,可是Collection好象是个黑色大染缸,本来有各种鲜明类型特征的对象一旦放入后,再取出时,这些类型就消失了.那么我们势必要用If来判断,如:\nIterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Collection) messyPrintCollection((Collection)o); else if (o instanceof String) System.out.println(\u0026#34;\u0026#39;\u0026#34;+o.toString()+\u0026#34;\u0026#39;\u0026#34;); else if (o instanceof Float) System.out.println(o.toString()+\u0026#34;f\u0026#34;); else System.out.println(o.toString()); } 在上例中,我们使用了 instanceof来判断 o的类型.\n很显然,这样做的缺点代码If else if 很繁琐.我们就可以使用Visitor模式解决它.\n如何使用Visitor? 针对上例,定义接口叫Visitable,用来定义一个Accept操作,也就是说让Collection每个元素具备可访问性.\n被访问者是我们Collection的每个元素Element,我们要为这些Element定义一个可以接受访问的接口(访问和被访问是互动的,只有访问者,被访问者如果表示不欢迎,访问者就不能访问),取名为Visitable，也可取名为Element。\npublic interface Visitable { public void accept(Visitor visitor); } 被访问的具体元素继承这个新的接口Visitable：\npublic class StringElement implements Visitable { private String value; public StringElement(String string) { value = string; } public String getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.","title":"3.10 Visitor"},{"content":"Interpreter pattern(解释者模式) 定义 定义语言的文法 ,并且建立一个解释器来解释该语言中的句子.\nInterpreter似乎使用面不是很广,它描述了一个语言解释器是如何构成的,在实际应用中,我们可能很少去构造一个语言的文法.我们还是来简单的了解一下: 首先要建立一个接口,用来描述共同的操作.\npublic interface AbstractExpression { void interpret( Context context ); } 再看看包含解释器之外的一些全局信息\npublic interface Context { } AbstractExpression的具体实现分两种:终结符表达式和非终结符表达式:\npublic class TerminalExpression implements AbstractExpression { public void interpret( Context context ) { } } 对于文法中没一条规则,非终结符表达式都必须的:\npublic class NonterminalExpression implements AbstractExpression { private AbstractExpression successor; public void setSuccessor( AbstractExpression successor ) { this.successor = successor; } public AbstractExpression getSuccessor() { return successor; } public void interpret( Context context ) { } } ","permalink":"https://blog.chalme.top/posts/design-patterns/3.9-interpreter/","summary":"Interpreter pattern(解释者模式) 定义 定义语言的文法 ,并且建立一个解释器来解释该语言中的句子.\nInterpreter似乎使用面不是很广,它描述了一个语言解释器是如何构成的,在实际应用中,我们可能很少去构造一个语言的文法.我们还是来简单的了解一下: 首先要建立一个接口,用来描述共同的操作.\npublic interface AbstractExpression { void interpret( Context context ); } 再看看包含解释器之外的一些全局信息\npublic interface Context { } AbstractExpression的具体实现分两种:终结符表达式和非终结符表达式:\npublic class TerminalExpression implements AbstractExpression { public void interpret( Context context ) { } } 对于文法中没一条规则,非终结符表达式都必须的:\npublic class NonterminalExpression implements AbstractExpression { private AbstractExpression successor; public void setSuccessor( AbstractExpression successor ) { this.successor = successor; } public AbstractExpression getSuccessor() { return successor; } public void interpret( Context context ) { } } ","title":"3.9 Interpreter"},{"content":"Mediator pattern(中介者模式) 定义 用一个中介对象来封装一系列关于对象交互行为.\n为何使用Mediator? 各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性.\n如何使用? 首先 有一个接口,用来定义成员对象之间的交互联系方式:\npublic interface Mediator { } Meiator具体实现,真正实现交互操作的内容:\npublic class ConcreteMediator implements Mediator { //假设当前有两个成员. private ConcreteColleague1 colleague1 = new ConcreteColleague1(); private ConcreteColleague2 colleague2 = new ConcreteColleague2(); ... } 再看看另外一个参与者:成员,因为是交互行为,都需要双方提供一些共同接口,这种要求在Visitor Observer等模式中都是相同的.\npublic class Colleague { private Mediator mediator; public Mediator getMediator() { return mediator; } public void setMediator( Mediator mediator ) { this.mediator = mediator; } } public class ConcreteColleague1 { } public class ConcreteColleague2 { } 每个成员都必须知道Mediator,并且和 Mediator联系,而不是和其他成员联系.\n至此,Mediator模式框架完成,可以发现Mediator模式规定不是很多,大体框架也比较简单,但实际使用起来就非常灵活.\nMediator模式在事件驱动类应用中比较多,例如界面设计GUI.;聊天,消息传递等,在聊天应用中,需要有一个MessageMediator,专门负责request/reponse之间任务的调节. MVC是J2EE的一个基本模式,View Controller是一种Mediator,它是Jsp和服务器上应用程序间的Mediator.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.8-mediator/","summary":"Mediator pattern(中介者模式) 定义 用一个中介对象来封装一系列关于对象交互行为.\n为何使用Mediator? 各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性.\n如何使用? 首先 有一个接口,用来定义成员对象之间的交互联系方式:\npublic interface Mediator { } Meiator具体实现,真正实现交互操作的内容:\npublic class ConcreteMediator implements Mediator { //假设当前有两个成员. private ConcreteColleague1 colleague1 = new ConcreteColleague1(); private ConcreteColleague2 colleague2 = new ConcreteColleague2(); ... } 再看看另外一个参与者:成员,因为是交互行为,都需要双方提供一些共同接口,这种要求在Visitor Observer等模式中都是相同的.\npublic class Colleague { private Mediator mediator; public Mediator getMediator() { return mediator; } public void setMediator( Mediator mediator ) { this.mediator = mediator; } } public class ConcreteColleague1 { } public class ConcreteColleague2 { } 每个成员都必须知道Mediator,并且和 Mediator联系,而不是和其他成员联系.","title":"3.8 Mediator"},{"content":"Strategy pattern(策略模式) 定义 属于设计模式中 对象行为型模式,主要是定义一系列的算法,把这些算法一个个封装成单独的类.\nStratrgy应用比较广泛,比如, 公司经营业务变化图, 可能有两种实现方式,一个是线条曲线,一个是框图(bar),这是两种算法,可以使用Strategy实现. 如何使用? 这里以字符串替代为例, 有一个文件,我们需要读取后,希望替代其中相应的变量,然后输出.关于替代其中变量的方法可能有多种方法,这取决于用户的要求,所以我们要准备几套变量字符替代方案. 首先,我们建立一个抽象类RepTempRule 定义一些公用变量和方法:\npublic abstract class RepTempRule{ protected String oldString=\u0026#34;\u0026#34;; public void setOldString(String oldString){ this.oldString=oldString; } protected String newString=\u0026#34;\u0026#34;; public String getNewString(){ return newString; } public abstract void replace() throws Exception; } 在RepTempRule中 有一个抽象方法abstract需要继承明确,这个replace里其实是替代的具体方法. 我们现在有两个字符替代方案, 1.将文本中aaa替代成bbb; 2.将文本中aaa替代成ccc;\n对应的类分别是RepTempRuleOne RepTempRuleTwo\npublic class RepTempRuleOne extends RepTempRule{ public void replace() throws Exception{ //replaceFirst是jdk1.4新特性 newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;) System.out.println(\u0026#34;this is replace one\u0026#34;); } } public class RepTempRuleTwo extends RepTempRule{ public void replace() throws Exception{ newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;ccc\u0026#34;) System.out.println(\u0026#34;this is replace Two\u0026#34;);　} } 第二步：我们要建立一个算法解决类，用来提供客户端可以自由选择算法。\npublic class RepTempRuleSolve { private RepTempRule strategy; public RepTempRuleSolve(RepTempRule rule){ this.strategy=rule; } public String getNewContext(Site site,String oldString) { return strategy.replace(site,oldString); } public void changeAlgorithm(RepTempRule newAlgorithm) { strategy = newAlgorithm; } } 调用如下:\npublic class test{ ...... public void testReplace(){ //使用第一套替代方案 RepTempRuleSolve solver=new RepTempRuleSolve(new RepTempRuleOne()); solver.getNewContext(site,context); //使用第二套 solver=new RepTempRuleSolve(new RepTempRuleTwo()); solver.getNewContext(site,context); } ..... } 我们达到了在运行期间，可以自由切换算法的目的。\n实际整个Strategy的核心部分就是抽象类的使用,使用Strategy模式可以在用户需要变化时,修改量很少,而且快速.\nStrategy和Factory有一定的类似,Strategy相对简单容易理解,并且可以在运行时刻自由切换。Factory重点是用来创建对象。\nStrategy适合下列场合: 以不同的格式保存文件;\n以不同的算法压缩文件;\n以不同的算法截获图象;\n以不同的格式输出同样数据的图形,比如曲线 或框图bar等\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.7-strategy/","summary":"Strategy pattern(策略模式) 定义 属于设计模式中 对象行为型模式,主要是定义一系列的算法,把这些算法一个个封装成单独的类.\nStratrgy应用比较广泛,比如, 公司经营业务变化图, 可能有两种实现方式,一个是线条曲线,一个是框图(bar),这是两种算法,可以使用Strategy实现. 如何使用? 这里以字符串替代为例, 有一个文件,我们需要读取后,希望替代其中相应的变量,然后输出.关于替代其中变量的方法可能有多种方法,这取决于用户的要求,所以我们要准备几套变量字符替代方案. 首先,我们建立一个抽象类RepTempRule 定义一些公用变量和方法:\npublic abstract class RepTempRule{ protected String oldString=\u0026#34;\u0026#34;; public void setOldString(String oldString){ this.oldString=oldString; } protected String newString=\u0026#34;\u0026#34;; public String getNewString(){ return newString; } public abstract void replace() throws Exception; } 在RepTempRule中 有一个抽象方法abstract需要继承明确,这个replace里其实是替代的具体方法. 我们现在有两个字符替代方案, 1.将文本中aaa替代成bbb; 2.将文本中aaa替代成ccc;\n对应的类分别是RepTempRuleOne RepTempRuleTwo\npublic class RepTempRuleOne extends RepTempRule{ public void replace() throws Exception{ //replaceFirst是jdk1.4新特性 newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;) System.out.println(\u0026#34;this is replace one\u0026#34;); } } public class RepTempRuleTwo extends RepTempRule{ public void replace() throws Exception{ newString=oldString.","title":"3.7 Strategy"},{"content":"State(状态模式)的定义 不同的状态,不同的行为;或者说,每个状态有着相应的行为.\n何时使用? State模式在实际使用中比较多,适合\u0026quot;状态的切换\u0026quot;.因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.\n不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.\n是否使用? 在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度.\n这里要阐述的是\u0026quot;开关切换状态\u0026quot; 和\u0026quot; 一般的状态判断\u0026quot;是有一些区别的, \u0026quot; 一般的状态判断\u0026quot;也是有 if..elseif结构,例如:\nif (which==1) state=\u0026ldquo;hello\u0026rdquo;; else if (which==2) state=\u0026ldquo;hi\u0026rdquo;; else if (which==3) state=\u0026ldquo;bye\u0026rdquo;;\n这是一个 \u0026quot; 一般的状态判断\u0026quot;,state值的不同是根据which变量来决定的,which和state没有关系.如果改成:\nif (state.euqals(\u0026ldquo;bye\u0026rdquo;)) state=\u0026ldquo;hello\u0026rdquo;; else if (state.euqals(\u0026ldquo;hello\u0026rdquo;)) state=\u0026ldquo;hi\u0026rdquo;; else if (state.euqals(\u0026ldquo;hi\u0026rdquo;)) state=\u0026ldquo;bye\u0026rdquo;;\n这就是 \u0026ldquo;开关切换状态\u0026rdquo;,是将state的状态从\u0026quot;hello\u0026quot;切换到\u0026quot;hi\u0026quot;,再切换到\u0026quot;\u0026ldquo;bye\u0026rdquo;;在切换到\u0026quot;hello\u0026quot;,好象一个旋转开关,这种状态改变就可以使用State模式了.\n如果单纯有上面一种将\u0026quot;hello\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;hi\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;bye\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;hello\u0026quot;这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.\n请看下例:\npublic class Context{ private Color state=null; public void push(){ //如果当前red状态 就切换到blue if (state==Color.red) state=Color.blue; //如果当前blue状态 就切换到green else if (state==Color.blue) state=Color.green; //如果当前black状态 就切换到red else if (state==Color.black) state=Color.red; //如果当前green状态 就切换到black else if (state==Color.green) state=Color.black; Sample sample=new Sample(state); sample.operate(); } public void pull(){ //与push状态切换正好相反 if (state==Color.green) state=Color.blue; else if (state==Color.black) state=Color.green; else if (state==Color.blue) state=Color.red; else if (state==Color.red) state=Color.black; Sample2 sample2=new Sample2(state); sample2.operate(); } } 在上例中,我们有两个动作push推和pull拉,这两个开关动作,改变了Context颜色,至此,我们就需要使用State模式优化它.\n另外注意:但就上例,state的变化,只是简单的颜色赋值,这个具体行为是很简单的,State适合巨大的具体行为,因此在,就本例,实际使用中也不一定非要使用State模式,这会增加子类的数目,简单的变复杂.\n例如: 银行帐户, 经常会在Open 状态和Close状态间转换.\n例如: 经典的TcpConnection, Tcp的状态有创建 侦听 关闭三个,并且反复转换,其创建 侦听 关闭的具体行为不是简单一两句就能完成的,适合使用State\n例如:信箱POP帐号, 会有四种状态, start HaveUsername Authorized quit,每个状态对应的行为应该是比较大的.适合使用State\n例如:在工具箱挑选不同工具,可以看成在不同工具中切换,适合使用State.如 具体绘图程序,用户可以选择不同工具绘制方框 直线 曲线,这种状态切换可以使用State.\n如何使用 State需要两种类型实体参与:\nstate manager 状态管理器 ,就是开关 ,如上面例子的Context实际就是一个state manager, 在state manager中有对状态的切换动作. 用抽象类或接口实现的父类,,不同状态就是继承这个父类的不同子类. 以上面的Context为例.我们要修改它,建立两个类型的实体.\n第一步: 首先建立一个父类: public abstract class State{ public abstract void handlepush(Context c); public abstract void handlepull(Context c); public abstract void getcolor(); } 父类中的方法要对应state manager中的开关行为,在state manager中 本例就是Context中,有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作:handlepush() handlepull(); 同时还需要一个获取push或pull结果的方法getcolor()\n下面是具体子类的实现:\npublic class BlueState extends State{ public void handlepush(Context c){ //根据push方法\u0026#34;如果是blue状态的切换到green\u0026#34; ; c.setState(new GreenState()); } public void handlepull(Context c){ //根据pull方法\u0026#34;如果是blue状态的切换到red\u0026#34; ; c.setState(new RedState()); } public abstract void getcolor(){ return (Color.blue)} } 同样 其他状态的子类实现如blue一样.\n第二步: 要重新改写State manager 也就是本例的Context: public class Context{ private Sate state=null; //我们将原来的 Color state 改成了新建的State state; //setState是用来改变state的状态 使用setState实现状态的切换 pulic void setState(State state){ this.state=state; } public void push(){ //状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心 state.handlepush(this); //因为sample要使用state中的一个切换结果,使用getColor() Sample sample=new Sample(state.getColor()); sample.operate(); } public void pull(){ state.handlepull(this); Sample2 sample2=new Sample2(state.getColor()); sample2.operate(); } } 至此,我们也就实现了State的refactorying过程.\n以上只是相当简单的一个实例,在实际应用中,handlepush或handelpull的处理是复杂的.\n状态模式优点： （1） 封装转换过程，也就是转换规则 （2） 枚举可能的状态，因此，需要事先确定状态种类。\n状态模式可以允许客户端改变状态的转换行为，而状态机则是能够自动改变状态，状态机是一个比较独立的而且复杂的机制，具体可参考一个状态机开源项目：http://sourceforge.net/projects/smframework/\n状态模式在工作流或游戏等各种系统中有大量使用，甚至是这些系统的核心功能设计，例如政府OA中，一个批文的状态有多种：未办；正在办理；正在批示；正在审核；已经完成等各种状态，使用状态机可以封装这个状态的变化规则，从而达到扩充状态时，不必涉及到状态的使用者。\n在网络游戏中，一个游戏活动存在开始；开玩；正在玩；输赢等各种状态，使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面，使用状态模式可以对整个游戏架构功能实现起到决定的主导作用。\n状态模式实质 使用状态模式前，客户端外界需要介入改变状态，而状态改变的实现是琐碎或复杂的。\n使用状态模式后，客户端外界可以直接使用事件Event实现，根本不必关心该事件导致如何状态变化，这些是由状态机等内部实现。\n这是一种Event-condition-State，状态模式封装了condition-State部分。\n每个状态形成一个子类，每个状态只关心它的下一个可能状态，从而无形中形成了状态转换的规则。如果新的状态加入，只涉及它的前一个状态修改和定义。\n状态转换有几个方法实现：一个在每个状态实现next()，指定下一个状态；还有一种方法，设定一个StateOwner，在StateOwner设定stateEnter状态进入和stateExit状态退出行为。\n状态从一个方面说明了流程，流程是随时间而改变，状态是截取流程某个时间片。\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.6-state/","summary":"State(状态模式)的定义 不同的状态,不同的行为;或者说,每个状态有着相应的行为.\n何时使用? State模式在实际使用中比较多,适合\u0026quot;状态的切换\u0026quot;.因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.\n不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.\n是否使用? 在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度.\n这里要阐述的是\u0026quot;开关切换状态\u0026quot; 和\u0026quot; 一般的状态判断\u0026quot;是有一些区别的, \u0026quot; 一般的状态判断\u0026quot;也是有 if..elseif结构,例如:\nif (which==1) state=\u0026ldquo;hello\u0026rdquo;; else if (which==2) state=\u0026ldquo;hi\u0026rdquo;; else if (which==3) state=\u0026ldquo;bye\u0026rdquo;;\n这是一个 \u0026quot; 一般的状态判断\u0026quot;,state值的不同是根据which变量来决定的,which和state没有关系.如果改成:\nif (state.euqals(\u0026ldquo;bye\u0026rdquo;)) state=\u0026ldquo;hello\u0026rdquo;; else if (state.euqals(\u0026ldquo;hello\u0026rdquo;)) state=\u0026ldquo;hi\u0026rdquo;; else if (state.euqals(\u0026ldquo;hi\u0026rdquo;)) state=\u0026ldquo;bye\u0026rdquo;;\n这就是 \u0026ldquo;开关切换状态\u0026rdquo;,是将state的状态从\u0026quot;hello\u0026quot;切换到\u0026quot;hi\u0026quot;,再切换到\u0026quot;\u0026ldquo;bye\u0026rdquo;;在切换到\u0026quot;hello\u0026quot;,好象一个旋转开关,这种状态改变就可以使用State模式了.\n如果单纯有上面一种将\u0026quot;hello\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;hi\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;bye\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;hello\u0026quot;这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.\n请看下例:\npublic class Context{ private Color state=null; public void push(){ //如果当前red状态 就切换到blue if (state==Color.red) state=Color.blue; //如果当前blue状态 就切换到green else if (state==Color.blue) state=Color.green; //如果当前black状态 就切换到red else if (state==Color.","title":"3.6 State"},{"content":"Command模式是最让我疑惑的一个模式,我在阅读了很多代码后,才感觉隐约掌握其大概原理,我认为理解设计模式最主要是掌握起原理构造,这样才对自己实际编程有指导作用.Command模式实际上不是个很具体,规定很多的模式,正是这个灵活性,让人有些confuse.\nCommand命令模式 n 将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。\n这是一种两台机器之间通讯联系性质的模式，类似传统过程语 言的 CallBack功能。\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n优点 解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。\n不少Command模式的代码都是针对图形界面的,它实际就是菜单命令,我们在一个下拉菜单选择一个命令时,然后会执行一些动作.\n将这些命令封装成在一个类中,然后用户(调用者)再对这个类进行操作,这就是Command模式,换句话说,本来用户(调用者)是直接调用这些命令的,如菜单上打开文档(调用者),就直接指向打开文档的代码,使用Command模式,就是在这两者之间增加一个中间者,将这种直接关系拗断,同时两者之间都隔离,基本没有关系了.\n显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式, 从Command模式,我也发现设计模式一个\u0026quot;通病\u0026quot;:好象喜欢将简单的问题复杂化, 喜欢在不同类中增加第三者,当然这样做有利于代码的健壮性 可维护性 还有复用性.\n如何使用? 具体的Command模式代码各式各样,因为如何封装命令,不同系统,有不同的做法.下面事例是将命令封装在一个Collection的List中,任何对象一旦加入List中,实际上装入了一个封闭的黑盒中,对象的特性消失了,只有取出时,才有可能模糊的分辨出:典型的Command模式需要有一个接口.接口中有一个统一的方法,这就是\u0026quot;将命令/请求封装为对象\u0026quot;:\npublic interface Command { public abstract void execute ( ); } 具体不同命令/请求代码是实现接口Command,下面有三个具体命令\npublic class Engineer implements Command { public void execute( ) { //do Engineer\u0026#39;s command } } public class Programmer implements Command { public void execute( ) { //do programmer\u0026#39;s command } } public class Politician implements Command { public void execute( ) { //do Politician\u0026#39;s command } } 按照通常做法,我们就可以直接调用这三个Command,但是使用Command模式,我们要将他们封装起来,扔到黑盒子List里去:\npublic class producer{ public static List produceRequests() { List queue = new ArrayList(); queue.add( new DomesticEngineer() ); queue.add( new Politician() ); queue.add( new Programmer() ); return queue; } } 这三个命令进入List中后,已经失去了其外表特征,以后再取出,也可能无法分辨出谁是Engineer 谁是Programmer了,看下面客户端如何调用Command模式:\npublic class TestCommand { public static void main(String[] args) { List queue = Producer.produceRequests(); for (Iterator it = queue.iterator(); it.hasNext(); ) //客户端直接调用execute方法，无需知道被调用者的其它更多类的方法名。 ((Command)it.next()).execute(); } } 由此可见,调用者基本只和接口打交道,不合具体实现交互,这也体现了一个原则,面向接口编程,这样,以后增加第四个具体命令时,就不必修改调用者TestCommand中的代码了.\n理解了上面的代码的核心原理,在使用中,就应该各人有自己方法了,特别是在如何分离调用者和具体命令上,有很多实现方法,上面的代码是使用\u0026quot;从List过一遍\u0026quot;的做法.这种做法只是为了演示.\n使用Command模式的一个好理由还因为它能实现Undo功能.每个具体命令都可以记住它刚刚执行的动作,并且在需要时恢复.\nCommand模式在界面设计中应用广泛.Java的Swing中菜单命令都是使用Command模式,由于Java在界面设计的性能上还有欠缺,因此界面设计具体代码我们就不讨论,网络上有很多这样的示例.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.5-command/","summary":"Command模式是最让我疑惑的一个模式,我在阅读了很多代码后,才感觉隐约掌握其大概原理,我认为理解设计模式最主要是掌握起原理构造,这样才对自己实际编程有指导作用.Command模式实际上不是个很具体,规定很多的模式,正是这个灵活性,让人有些confuse.\nCommand命令模式 n 将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。\n这是一种两台机器之间通讯联系性质的模式，类似传统过程语 言的 CallBack功能。\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n优点 解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。\n不少Command模式的代码都是针对图形界面的,它实际就是菜单命令,我们在一个下拉菜单选择一个命令时,然后会执行一些动作.\n将这些命令封装成在一个类中,然后用户(调用者)再对这个类进行操作,这就是Command模式,换句话说,本来用户(调用者)是直接调用这些命令的,如菜单上打开文档(调用者),就直接指向打开文档的代码,使用Command模式,就是在这两者之间增加一个中间者,将这种直接关系拗断,同时两者之间都隔离,基本没有关系了.\n显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式, 从Command模式,我也发现设计模式一个\u0026quot;通病\u0026quot;:好象喜欢将简单的问题复杂化, 喜欢在不同类中增加第三者,当然这样做有利于代码的健壮性 可维护性 还有复用性.\n如何使用? 具体的Command模式代码各式各样,因为如何封装命令,不同系统,有不同的做法.下面事例是将命令封装在一个Collection的List中,任何对象一旦加入List中,实际上装入了一个封闭的黑盒中,对象的特性消失了,只有取出时,才有可能模糊的分辨出:典型的Command模式需要有一个接口.接口中有一个统一的方法,这就是\u0026quot;将命令/请求封装为对象\u0026quot;:\npublic interface Command { public abstract void execute ( ); } 具体不同命令/请求代码是实现接口Command,下面有三个具体命令\npublic class Engineer implements Command { public void execute( ) { //do Engineer\u0026#39;s command } } public class Programmer implements Command { public void execute( ) { //do programmer\u0026#39;s command } } public class Politician implements Command { public void execute( ) { //do Politician\u0026#39;s command } } 按照通常做法,我们就可以直接调用这三个Command,但是使用Command模式,我们要将他们封装起来,扔到黑盒子List里去:","title":"3.5 Command"},{"content":"Chain of Responsibility (职责链模式) Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。\n如何使用? 虽然这一段是如何使用CoR,但是也是演示什么是CoR.\n有一个Handler接口:\npublic interface Handler{ public void handleRequest(); } 这是一个处理request的事例， 如果有多种request,比如 请求帮助 请求打印 或请求格式化：\n最先想到的解决方案是：在接口中增加多个请求：\npublic interface Handler{ public void handleHelp(); public void handlePrint(); public void handleFormat(); } 具体是一段实现接口Handler代码：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleHelp(){ //具体处理请求Help的代码 ... } public void handlePrint(){ //如果是print 转去处理Print successor.handlePrint(); } public void handleFormat(){ //如果是Format 转去处理format successor.handleFormat(); } } 一共有三个这样的具体实现类，上面是处理help,还有处理Print 处理Format这大概是我们最常用的编程思路。\n虽然思路简单明了，但是有一个扩展问题，如果我们需要再增加一个请求request种类,需要修改接口及其每一个实现。\n第二方案:将每种request都变成一个接口，因此我们有以下代码 ：\npublic interface HelpHandler{ public void handleHelp(); } public interface PrintHandler{ public void handlePrint(); } public interface FormatHandler{ public void handleFormat(); } public class ConcreteHandler implements HelpHandler,PrintHandler,FormatHandlet{ private HelpHandler helpSuccessor; private PrintHandler printSuccessor; private FormatHandler formatSuccessor; public ConcreteHandler(HelpHandler helpSuccessor,PrintHandler printSuccessor,FormatHandler formatSuccessor) { this.helpSuccessor=helpSuccessor; this.printSuccessor=printSuccessor; this.formatSuccessor=formatSuccessor; } public void handleHelp(){ ....... } public void handlePrint(){this.printSuccessor=printSuccessor;} public void handleFormat(){this.formatSuccessor=formatSuccessor;} } 这个办法在增加新的请求request情况下，只是节省了接口的修改量，接口实现ConcreteHandler还需要修改。而且代码显然不简单美丽。\n解决方案3: 在Handler接口中只使用一个参数化方法：\npublic interface Handler{ public void handleRequest(String request); } 那么Handler实现代码如下：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleRequest(String request){ if (request.equals(\u0026#34;Help\u0026#34;)){ //这里是处理Help的具体代码 }else //传递到下一个 successor.handle(request); } } } 这里先假设request是String类型，如果不是怎么办？当然我们可以创建一个专门类Request\n最后解决方案:接口Handler的代码如下：\npublic interface Handler{ public void handleRequest(Request request); } Request类的定义:\npublic class Request{ private String type; public Request(String type){this.type=type;} public String getType(){return type;} public void execute(){ //request真正具体行为代码 } } 那么Handler实现代码如下：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleRequest(Request request){ if (request instanceof HelpRequest){ //这里是处理Help的具体代码 }else if (request instanceof PrintRequst){ request.execute(); }else //传递到下一个 successor.handle(request); } } } 这个解决方案就是CoR, 在一个链上,都有相应职责的类,因此叫Chain of Responsibility.\nCoR的优点 因为无法预知来自外界（客户端）的请求是属于哪种类型，每个类如果碰到它不能处理的请求只要放弃就可以。\n缺点是效率低，因为一个请求的完成可能要遍历到最后才可能完成，当然也可以用树的概念优化。 在Java AWT1.0中，对于鼠标按键事情的处理就是使用CoR,到Java.1.1以后，就使用Observer代替CoR\n扩展性差，因为在CoR中，一定要有一个统一的接口Handler.局限性就在这里。\n与Command模式区别 Command 模式需要事先协商客户端和服务器端的调用关系，比如 1 代表 start 2 代表 move 等，这些 都是封装在 request 中，到达服务器端再分解。\nCoR 模式就无需这种事先约定，服务器端可以使用 CoR 模式进行客户端请求的猜测，一个个猜测 试验。\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.4-chain-of-responsibility/","summary":"Chain of Responsibility (职责链模式) Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。\n如何使用? 虽然这一段是如何使用CoR,但是也是演示什么是CoR.\n有一个Handler接口:\npublic interface Handler{ public void handleRequest(); } 这是一个处理request的事例， 如果有多种request,比如 请求帮助 请求打印 或请求格式化：\n最先想到的解决方案是：在接口中增加多个请求：\npublic interface Handler{ public void handleHelp(); public void handlePrint(); public void handleFormat(); } 具体是一段实现接口Handler代码：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleHelp(){ //具体处理请求Help的代码 ... } public void handlePrint(){ //如果是print 转去处理Print successor.handlePrint(); } public void handleFormat(){ //如果是Format 转去处理format successor.","title":"3.4 Chain of Responsibility"},{"content":"Observer(观察者模式)定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n链接\n具体讲解\nJava深入到一定程度,就不可避免的碰到设计模式(design pattern)这一概念,了解设计模式,将使自己对java中的接口或抽象类应用有更深的理解.设计模式在java的中型系统中应用广泛,遵循一定的编程模式,才能使自己的代码便于理解,易于交流,Observer(观察者)模式是比较常用的一个模式,尤其在界面设计中应用广泛,而本站所关注的是Java在电子商务系统中应用,因此想从电子商务实例中分析Observer的应用.\n虽然网上商店形式多样,每个站点有自己的特色,但也有其一般的共性,单就\u0026quot;商品的变化,以便及时通知订户\u0026quot;这一点,是很多网上商店共有的模式,这一模式类似Observer patern观察者模式.\n具体的说,如果网上商店中商品在名称 价格等方面有变化,如果系统能自动通知会员,将是网上商店区别传统商店的一大特色.这就需要在商品product中加入Observer这样角色,以便product细节发生变化时,Observer能自动观察到这种变化,并能进行及时的update或notify动作.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.3-observer/","summary":"Observer(观察者模式)定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n链接\n具体讲解\nJava深入到一定程度,就不可避免的碰到设计模式(design pattern)这一概念,了解设计模式,将使自己对java中的接口或抽象类应用有更深的理解.设计模式在java的中型系统中应用广泛,遵循一定的编程模式,才能使自己的代码便于理解,易于交流,Observer(观察者)模式是比较常用的一个模式,尤其在界面设计中应用广泛,而本站所关注的是Java在电子商务系统中应用,因此想从电子商务实例中分析Observer的应用.\n虽然网上商店形式多样,每个站点有自己的特色,但也有其一般的共性,单就\u0026quot;商品的变化,以便及时通知订户\u0026quot;这一点,是很多网上商店共有的模式,这一模式类似Observer patern观察者模式.\n具体的说,如果网上商店中商品在名称 价格等方面有变化,如果系统能自动通知会员,将是网上商店区别传统商店的一大特色.这就需要在商品product中加入Observer这样角色,以便product细节发生变化时,Observer能自动观察到这种变化,并能进行及时的update或notify动作.","title":"3.3 Observer"},{"content":"Memento(备忘录模式)定义 memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.\nMemento模式相对也比较好理解,我们看下列代码:\npublic class Originator { public int number; public File file = null; public Originator(){} // 创建一个Memento public Memento getMemento(){ return new Memento(this); } // 恢复到原始值 public void setMemento(Memento m){ number = m.number; file = m.file; } } 我们再看看Memento类:\nprivate class Memento implements java.io.Serializable{ public int number; public File file = null; public Memento( Originator o){ number = o.number; file = o.file; } } 可见 Memento中保存了Originator中的number和file的值. 通过调用Originator中number和file值改变的话,通过调用setMemento()方法可以恢复.\nMemento模式的缺点是耗费大,如果内部状态很多,再保存一份,无意要浪费大量内存.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.2-memento/","summary":"Memento(备忘录模式)定义 memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.\nMemento模式相对也比较好理解,我们看下列代码:\npublic class Originator { public int number; public File file = null; public Originator(){} // 创建一个Memento public Memento getMemento(){ return new Memento(this); } // 恢复到原始值 public void setMemento(Memento m){ number = m.number; file = m.file; } } 我们再看看Memento类:\nprivate class Memento implements java.io.Serializable{ public int number; public File file = null; public Memento( Originator o){ number = o.number; file = o.file; } } 可见 Memento中保存了Originator中的number和file的值. 通过调用Originator中number和file值改变的话,通过调用setMemento()方法可以恢复.\nMemento模式的缺点是耗费大,如果内部状态很多,再保存一份,无意要浪费大量内存.","title":"3.2 Memento"},{"content":"Template(模板模式)定义 定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.\n使用Java的抽象类时，就经常会使用到Template模式,因此Template模式使用很普遍.而且很容易理解和使用。\npublic abstract class Benchmark { /** * 下面操作是我们希望在子类中完成 */ public abstract void benchmark(); /** * 重复执行benchmark次数 */ public final long repeat (int count) { if (count \u0026lt;= 0) return 0; else { long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; count; i++) benchmark(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; } } } 在上例中,我们希望重复执行benchmark()操作,但是对benchmark()的具体内容没有说明,而是延迟到其子类中描述:\npublic class MethodBenchmark extends Benchmark { /** * 真正定义benchmark内容 */ public void benchmark() { for (int i = 0; i \u0026lt; Integer.MAX_VALUE; i++){ System.out.printtln(\u0026#34;i=\u0026#34;+i);　} } } 至此,Template模式已经完成,是不是很简单?\n我们称repeat方法为模板方法， 它其中的benchmark()实现被延迟到子类MethodBenchmark中实现了，\n看看如何使用:\nBenchmark operation = new MethodBenchmark(); long duration = operation.repeat(Integer.parseInt(args[0].trim())); System.out.println(\u0026#34;The operation took \u0026#34; + duration + \u0026#34; milliseconds\u0026#34;); 也许你以前还疑惑抽象类有什么用,现在你应该彻底明白了吧? 至于这样做的好处,很显然啊,扩展性强,以后Benchmark内容变化,我只要再做一个继承子类就可以,不必修改其他应用代码.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.1-template/","summary":"Template(模板模式)定义 定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.\n使用Java的抽象类时，就经常会使用到Template模式,因此Template模式使用很普遍.而且很容易理解和使用。\npublic abstract class Benchmark { /** * 下面操作是我们希望在子类中完成 */ public abstract void benchmark(); /** * 重复执行benchmark次数 */ public final long repeat (int count) { if (count \u0026lt;= 0) return 0; else { long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; count; i++) benchmark(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; } } } 在上例中,我们希望重复执行benchmark()操作,但是对benchmark()的具体内容没有说明,而是延迟到其子类中描述:\npublic class MethodBenchmark extends Benchmark { /** * 真正定义benchmark内容 */ public void benchmark() { for (int i = 0; i \u0026lt; Integer.","title":"3.1 Template"},{"content":"Flyweight(享元模式)定义 避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).\n重点 本质factory的实现，巧妙的设计。 hashtable 或 hashmap 来判断对象是否存在 为什么使用? 面向对象语言的原则就是一切都是对象,但是如果真正使用起来,有时对象数可能显得很庞大,比如,字处理软件,如果以每个文字都作为一个对象,几千个字,对象数就是几千,无疑耗费内存,那么我们还是要\u0026quot;求同存异\u0026quot;,找出这些对象群的共同点,设计一个元类,封装可以被共享的类,另外,还有一些特性是取决于应用(context),是不可共享的,这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分.\n说白点,就是先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象.\nFlyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.\n如何使用?\n我们先从Flyweight抽象接口开始:\npublic interface Flyweight { public void operation( ExtrinsicState state ); } //用于本模式的抽象数据类型(自行设计) public interface ExtrinsicState { }\n下面是接口的具体实现(ConcreteFlyweight) ,并为内部状态增加内存空间, ConcreteFlyweight必须是可共享的,它保存的任何状态都必须是内部(intrinsic),也就是说,ConcreteFlyweight必须和它的应用环境场合无关.\npublic class ConcreteFlyweight implements Flyweight { private IntrinsicState state; public void operation( ExtrinsicState state ) { //具体操作 } } 当然,并不是所有的Flyweight具体实现子类都需要被共享的,所以还有另外一种不共享的ConcreteFlyweight:\npublic class UnsharedConcreteFlyweight implements Flyweight { public void operation( ExtrinsicState state ) { } } Flyweight factory负责维护一个Flyweight池(存放内部状态),当客户端请求一个共享Flyweight时,这个factory首先搜索池中是否已经有可适用的,如果有,factory只是简单返回送出这个对象,否则,创建一个新的对象,加入到池中,再返回送出这个对象.池\npublic class FlyweightFactory { //Flyweight pool private Hashtable flyweights = new Hashtable(); public Flyweight getFlyweight( Object key ) { Flyweight flyweight = (Flyweight) flyweights.get(key); if( flyweight == null ) { //产生新的ConcreteFlyweight flyweight = new ConcreteFlyweight(); flyweights.put( key, flyweight ); } return flyweight; } } 至此,Flyweight模式的基本框架已经就绪,我们看看如何调用:\nFlyweightFactory factory = new FlyweightFactory(); Flyweight fly1 = factory.getFlyweight( \u0026ldquo;Fred\u0026rdquo; ); Flyweight fly2 = factory.getFlyweight( \u0026ldquo;Wilma\u0026rdquo; ); \u0026hellip;\u0026hellip;\n从调用上看,好象是个纯粹的Factory使用,但奥妙就在于Factory的内部设计上.\nFlyweight模式在XML等数据源中应用 我们上面已经提到,当大量从数据源中读取字符串,其中肯定有重复的,那么我们使用Flyweight模式可以提高效率,以唱片CD为例,在一个XML文件中,存放了多个CD的资料.\n每个CD有三个字段: 1.出片日期(year) 2.歌唱者姓名等信息(artist) 3.唱片曲目 (title)\n其中,歌唱者姓名有可能重复,也就是说,可能有同一个演唱者的多个不同时期 不同曲目的CD.我们将\u0026quot;歌唱者姓名\u0026quot;作为可共享的ConcreteFlyweight.其他两个字段作为UnsharedConcreteFlyweight.\n首先看看数据源XML文件的内容:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;collection\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Another Green World\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1978\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Eno, Brian\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Greatest Hits\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1950\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Holiday, Billie\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Taking Tiger Mountain (by strategy)\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1977\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Eno, Brian\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; ....... \u0026lt;/collection\u0026gt; 虽然上面举例CD只有3张,CD可看成是大量重复的小类,因为其中成分只有三个字段,而且有重复的(歌唱者姓名).\nCD就是类似上面接口 Flyweight:\npublic class CD { private String title; private int year; private Artist artist; public String getTitle() {　return title;　} public int getYear() {　return year;　} public Artist getArtist() {　return artist;　} public void setTitle(String t){　title = t;} public void setYear(int y){year = y;} public void setArtist(Artist a){artist = a;} } 将\u0026quot;歌唱者姓名\u0026quot;作为可共享的ConcreteFlyweight:\npublic class Artist { //内部状态 private String name; // note that Artist is immutable. String getName(){return name;} Artist(String n){ name = n; } } 再看看Flyweight factory,专门用来制造上面的可共享的ConcreteFlyweight:Artist\npublic class ArtistFactory { Hashtable pool = new Hashtable(); Artist getArtist(String key){ Artist result; result = (Artist)pool.get(key); ////产生新的Artist if(result == null) { result = new Artist(key); pool.put(key,result); } return result; } } 当你有几千张甚至更多CD时,Flyweight模式将节省更多空间,共享的flyweight越多,空间节省也就越大.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.7-flyweight/","summary":"Flyweight(享元模式)定义 避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).\n重点 本质factory的实现，巧妙的设计。 hashtable 或 hashmap 来判断对象是否存在 为什么使用? 面向对象语言的原则就是一切都是对象,但是如果真正使用起来,有时对象数可能显得很庞大,比如,字处理软件,如果以每个文字都作为一个对象,几千个字,对象数就是几千,无疑耗费内存,那么我们还是要\u0026quot;求同存异\u0026quot;,找出这些对象群的共同点,设计一个元类,封装可以被共享的类,另外,还有一些特性是取决于应用(context),是不可共享的,这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分.\n说白点,就是先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象.\nFlyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.\n如何使用?\n我们先从Flyweight抽象接口开始:\npublic interface Flyweight { public void operation( ExtrinsicState state ); } //用于本模式的抽象数据类型(自行设计) public interface ExtrinsicState { }\n下面是接口的具体实现(ConcreteFlyweight) ,并为内部状态增加内存空间, ConcreteFlyweight必须是可共享的,它保存的任何状态都必须是内部(intrinsic),也就是说,ConcreteFlyweight必须和它的应用环境场合无关.\npublic class ConcreteFlyweight implements Flyweight { private IntrinsicState state; public void operation( ExtrinsicState state ) { //具体操作 } } 当然,并不是所有的Flyweight具体实现子类都需要被共享的,所以还有另外一种不共享的ConcreteFlyweight:\npublic class UnsharedConcreteFlyweight implements Flyweight { public void operation( ExtrinsicState state ) { } } Flyweight factory负责维护一个Flyweight池(存放内部状态),当客户端请求一个共享Flyweight时,这个factory首先搜索池中是否已经有可适用的,如果有,factory只是简单返回送出这个对象,否则,创建一个新的对象,加入到池中,再返回送出这个对象.","title":"2.7 Flyweight"},{"content":"Bridge(桥接模式)定义 将抽象和行为划分开来,各自独立,但能动态的结合。\n在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。\n重点 单例模型的使用和 调用 为什么使用? 不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。\n如果一个抽象类或接口有多个具体实现(子类、concrete subclass),这些子类之间关系可能有以下两种情况:\n这多个子类之间概念是并列的,如前面举例,打桩,有两个concrete class:方形桩和圆形桩;这两个形状上的桩是并列的,没有概念上的重复。\n这多个子类之中有内容概念上重叠.那么需要我们把抽象共同部分和行为共同部分各自独立开来,原来是准备放在一个接口里,现在需要设计两个接口：抽象接口和行为接口，分别放置抽象和行为.\n例如,一杯咖啡为例,子类实现类为四个：中杯加奶、大杯加奶、 中杯不加奶、大杯不加奶。\n但是，我们注意到：上面四个子类中有概念重叠，可从另外一个角度进行考虑，这四个类实际是两个角色的组合：抽象 和行为，其中抽象为：中杯和大杯；行为为：加奶 不加奶（如加橙汁 加苹果汁）.\n实现四个子类在抽象和行为之间发生了固定的绑定关系，如果以后动态增加加葡萄汁的行为，就必须再增加两个类：中杯加葡萄汁和大杯加葡萄汁。显然混乱,扩展性极差。\n那我们从分离抽象和行为的角度，使用Bridge模式来实现。\n如何实现? 以上面提到的咖啡 为例. 我们原来打算只设计一个接口(抽象类),使用Bridge模式后,我们需要将抽象和行为分开,加奶和不加奶属于行为,我们将它们抽象成一个专门的行为接口.\n先看看抽象部分的接口代码:\npublic abstract class Coffee { CoffeeImp coffeeImp; public void setCoffeeImp() { this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp(); } public CoffeeImp getCoffeeImp() {return this.CoffeeImp;} public abstract void pourCoffee(); } 其中CoffeeImp 是加不加奶的行为接口,看其代码如下:\npublic abstract class CoffeeImp { public abstract void pourCoffeeImp(); } 现在我们有了两个抽象类,下面我们分别对其进行继承,实现concrete class:\n//中杯 public class MediumCoffee extends Coffee { public MediumCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.getCoffeeImp(); //我们以重复次数来说明是冲中杯还是大杯 ,重复2次是中杯 for (int i = 0; i \u0026lt; 2; i++) { coffeeImp.pourCoffeeImp(); } } } //大杯 public class SuperSizeCoffee extends Coffee { public SuperSizeCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.getCoffeeImp(); //我们以重复次数来说明是冲中杯还是大杯 ,重复5次是大杯 for (int i = 0; i \u0026lt; 5; i++) { coffeeImp.pourCoffeeImp(); } } } 上面分别是中杯和大杯的具体实现.下面再对行为CoffeeImp进行继承:\n//加奶 public class MilkCoffeeImp extends CoffeeImp { MilkCoffeeImp() {} public void pourCoffeeImp() { System.out.println(\u0026#34;加了美味的牛奶\u0026#34;); } } //不加奶 public class FragrantCoffeeImp extends CoffeeImp { FragrantCoffeeImp() {} public void pourCoffeeImp() { System.out.println(\u0026#34;什么也没加,清香\u0026#34;); } } Bridge模式的基本框架我们已经搭好了,别忘记定义中还有一句:动态结合,我们现在可以喝到至少四种咖啡: 1.中杯加奶 2.中杯不加奶 3.大杯加奶 4.大杯不加奶\n看看是如何动态结合的,在使用之前,我们做个准备工作,设计一个单态类(Singleton)用来hold当前的CoffeeImp:\npublic class CoffeeImpSingleton { private static CoffeeImp coffeeImp; public CoffeeImpSingleton(CoffeeImp coffeeImpIn) {this.coffeeImp = coffeeImpIn;} public static CoffeeImp getTheCoffeeImp() { return coffeeImp; } } 看看中杯加奶 和大杯加奶 是怎么出来的:\n//拿出牛奶 CoffeeImpSingleton coffeeImpSingleton = new CoffeeImpSingleton(new MilkCoffeeImp()); //中杯加奶 MediumCoffee mediumCoffee = new MediumCoffee(); mediumCoffee.pourCoffee(); //大杯加奶 SuperSizeCoffee superSizeCoffee = new SuperSizeCoffee(); superSizeCoffee.pourCoffee(); 注意: Bridge模式的执行类如CoffeeImp和Coffee是一对一的关系, 正确创建CoffeeImp是该模式的关键。\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.6-bridge/","summary":"Bridge(桥接模式)定义 将抽象和行为划分开来,各自独立,但能动态的结合。\n在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。\n重点 单例模型的使用和 调用 为什么使用? 不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。\n如果一个抽象类或接口有多个具体实现(子类、concrete subclass),这些子类之间关系可能有以下两种情况:\n这多个子类之间概念是并列的,如前面举例,打桩,有两个concrete class:方形桩和圆形桩;这两个形状上的桩是并列的,没有概念上的重复。\n这多个子类之中有内容概念上重叠.那么需要我们把抽象共同部分和行为共同部分各自独立开来,原来是准备放在一个接口里,现在需要设计两个接口：抽象接口和行为接口，分别放置抽象和行为.\n例如,一杯咖啡为例,子类实现类为四个：中杯加奶、大杯加奶、 中杯不加奶、大杯不加奶。\n但是，我们注意到：上面四个子类中有概念重叠，可从另外一个角度进行考虑，这四个类实际是两个角色的组合：抽象 和行为，其中抽象为：中杯和大杯；行为为：加奶 不加奶（如加橙汁 加苹果汁）.\n实现四个子类在抽象和行为之间发生了固定的绑定关系，如果以后动态增加加葡萄汁的行为，就必须再增加两个类：中杯加葡萄汁和大杯加葡萄汁。显然混乱,扩展性极差。\n那我们从分离抽象和行为的角度，使用Bridge模式来实现。\n如何实现? 以上面提到的咖啡 为例. 我们原来打算只设计一个接口(抽象类),使用Bridge模式后,我们需要将抽象和行为分开,加奶和不加奶属于行为,我们将它们抽象成一个专门的行为接口.\n先看看抽象部分的接口代码:\npublic abstract class Coffee { CoffeeImp coffeeImp; public void setCoffeeImp() { this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp(); } public CoffeeImp getCoffeeImp() {return this.CoffeeImp;} public abstract void pourCoffee(); } 其中CoffeeImp 是加不加奶的行为接口,看其代码如下:\npublic abstract class CoffeeImp { public abstract void pourCoffeeImp(); } 现在我们有了两个抽象类,下面我们分别对其进行继承,实现concrete class:\n//中杯 public class MediumCoffee extends Coffee { public MediumCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.","title":"2.6 Bridge"},{"content":"Composite(组合模式)定义 将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.\nComposite比较容易理解，想到Composite就应该想到树形结构图。组合体内这些对象都有共同接口,当组合体一个对象的方法被调用执行时，Composite将遍历(Iterator)整个树形结构,寻找同样包含这个方法的对象并实现调用执行。可以用牵一动百来形容。\n所以Composite模式使用到Iterator模式，和Chain of Responsibility模式类似。\n本质 定义 interface 或 abstract class\n核心 在class(继承或实现) 中使用了 arraylist . 可以在其中添加 其他 对象（继承同一class）\nComposite好处 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。 更容易在组合体内加入对象部件. 客户端不必因为加入了新的对象部件而更改代码。 如何使用Composite 首先定义一个接口或抽象类，这是设计模式通用方式了，其他设计模式对接口内部定义限制不多，Composite却有个规定，那就是要在接口内部定义一个用于访问和管理Composite组合体的对象们（或称部件Component）.\n下面的代码是以抽象类定义，一般尽量用接口interface,\npublic abstract class Equipment { private String name; //实价 public abstract double netPrice(); //折扣价格 public abstract double discountPrice(); //增加部件方法　public boolean add(Equipment equipment) { return false; } //删除部件方法 public boolean remove(Equipment equipment) { return false; } //注意这里，这里就提供一种用于访问组合体类的部件方法。 public Iterator iter() { return null; } public Equipment(final String name) { this.name=name; } } 抽象类Equipment就是Component定义，代表着组合体类的对象们,Equipment中定义几个共同的方法。\npublic class Disk extends Equipment { public Disk(String name) { super(name); } //定义Disk实价为1 public double netPrice() { return 1.; } //定义了disk折扣价格是0.5 对折。 public double discountPrice() { return .5; } } Disk是组合体内的一个对象，或称一个部件，这个部件是个单独元素( Primitive)。 还有一种可能是，一个部件也是一个组合体，就是说这个部件下面还有\u0026rsquo;儿子\u0026rsquo;，这是树形结构中通常的情况，应该比较容易理解。现在我们先要定义这个组合体：\nabstract class CompositeEquipment extends Equipment { private int i=0; //定义一个Vector 用来存放\u0026#39;儿子\u0026#39; private Lsit equipment=new ArrayList(); public CompositeEquipment(String name) { super(name); } public boolean add(Equipment equipment) { this.equipment.add(equipment); return true; } public double netPrice() { double netPrice=0.; Iterator iter=equipment.iterator(); for(iter.hasNext()) netPrice+=((Equipment)iter.next()).netPrice(); return netPrice; } public double discountPrice() { double discountPrice=0.; Iterator iter=equipment.iterator(); for(iter.hasNext()) discountPrice+=((Equipment)iter.next()).discountPrice(); return discountPrice; } //注意这里，这里就提供用于访问自己组合体内的部件方法。 //上面dIsk 之所以没有，是因为Disk是个单独(Primitive)的元素. public Iterator iter() { return equipment.iterator() ; { //重载Iterator方法 public boolean hasNext() { return i\u0026lt;equipment.size(); } //重载Iterator方法 public Object next() { if(hasNext()) return equipment.elementAt(i++); else throw new NoSuchElementException(); } } 上面CompositeEquipment继承了Equipment,同时为自己里面的对象们提供了外部访问的方法,重载了Iterator,Iterator是Java的Collection的一个接口，是Iterator模式的实现.\n我们再看看CompositeEquipment的两个具体类:盘盒Chassis和箱子Cabinet，箱子里面可以放很多东西，如底板，电源盒，硬盘盒等；盘盒里面可以放一些小设备，如硬盘 软驱等。无疑这两个都是属于组合体性质的。\npublic class Chassis extends CompositeEquipment { public Chassis(String name) { super(name); } public double netPrice() { return 1.+super.netPrice(); } public double discountPrice() { return .5+super.discountPrice(); } } public class Cabinet extends CompositeEquipment { public Cabinet(String name) { super(name); } public double netPrice() { return 1.+super.netPrice(); } public double discountPrice() { return .5+super.discountPrice(); } } 至此我们完成了整个Composite模式的架构。\n我们可以看看客户端调用Composote代码:\nCabinet cabinet=new Cabinet(\u0026#34;Tower\u0026#34;); Chassis chassis=new Chassis(\u0026#34;PC Chassis\u0026#34;); //将PC Chassis装到Tower中 (将盘盒装到箱子里) cabinet.add(chassis); //将一个10GB的硬盘装到 PC Chassis (将硬盘装到盘盒里) chassis.add(new Disk(\u0026#34;10 GB\u0026#34;)); //调用 netPrice()方法; System.out.println(\u0026#34;netPrice=\u0026#34;+cabinet.netPrice()); System.out.println(\u0026#34;discountPrice=\u0026#34;+cabinet.discountPrice()); 上面调用的方法netPrice()或discountPrice()，实际上Composite使用Iterator遍历了整个树形结构,寻找同样包含这个方法的对象并实现调用执行.\nComposite是个很巧妙体现智慧的模式，在实际应用中，如果碰到树形结构，我们就可以尝试是否可以使用这个模式。\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.4-composite/","summary":"Composite(组合模式)定义 将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.\nComposite比较容易理解，想到Composite就应该想到树形结构图。组合体内这些对象都有共同接口,当组合体一个对象的方法被调用执行时，Composite将遍历(Iterator)整个树形结构,寻找同样包含这个方法的对象并实现调用执行。可以用牵一动百来形容。\n所以Composite模式使用到Iterator模式，和Chain of Responsibility模式类似。\n本质 定义 interface 或 abstract class\n核心 在class(继承或实现) 中使用了 arraylist . 可以在其中添加 其他 对象（继承同一class）\nComposite好处 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。 更容易在组合体内加入对象部件. 客户端不必因为加入了新的对象部件而更改代码。 如何使用Composite 首先定义一个接口或抽象类，这是设计模式通用方式了，其他设计模式对接口内部定义限制不多，Composite却有个规定，那就是要在接口内部定义一个用于访问和管理Composite组合体的对象们（或称部件Component）.\n下面的代码是以抽象类定义，一般尽量用接口interface,\npublic abstract class Equipment { private String name; //实价 public abstract double netPrice(); //折扣价格 public abstract double discountPrice(); //增加部件方法　public boolean add(Equipment equipment) { return false; } //删除部件方法 public boolean remove(Equipment equipment) { return false; } //注意这里，这里就提供一种用于访问组合体类的部件方法。 public Iterator iter() { return null; } public Equipment(final String name) { this.","title":"2.4 Composite"},{"content":"Decorator(装饰者模式) 定义 动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.\n本质 interface(一般都要)\n主要是编写 被装饰者，在构造函数中加入装饰者，然后在被装饰者类中注意对装饰者类的调用\n为什么使用Decorator? 我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.\n使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了\u0026quot;即插即用\u0026quot;的方法,在运行期间决定何时增加何种功能.\n如何使用? 举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.\n我们先建立一个接口:\npublic interface Work { public void insert(); } 接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:\npublic class SquarePeg implements Work{ public void insert(){ System.out.println(\u0026#34;方形桩插入\u0026#34;); } } 现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).\n那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些\u0026quot;油漆\u0026quot;,这些油漆就是那些额外的功能.\npublic class Decorator implements Work{ private Work work; //额外增加的功能被打包在这个List中 private ArrayList others = new ArrayList(); //在构造器中使用组合new方式,引入Work对象; public Decorator(Work work) { this.work=work; others.add(\u0026#34;挖坑\u0026#34;); others.add(\u0026#34;钉木板\u0026#34;); } public void insert(){ newMethod(); } //在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 public void newMethod() { otherMethod(); work.insert(); } public void otherMethod() { ListIterator listIterator = others.listIterator(); while (listIterator.hasNext()) { System.out.println(((String)(listIterator.next())) + \u0026#34; 正在进行\u0026#34;); } } } 在上例中,我们把挖坑和钉木板都排在了打桩insert前面,这里只是举例说明额外功能次序可以任意安排.\n好了,Decorator模式出来了,我们看如何调用:\nWork squarePeg = new SquarePeg(); Work decorator = new Decorator(squarePeg); decorator.insert(); Decorator模式至此完成.\n如果你细心,会发现,上面调用类似我们读取文件时的调用:\nFileReader fr = new FileReader(filename); BufferedReader br = new BufferedReader(fr);\n实际上Java 的I/O API就是使用Decorator实现的,I/O变种很多,如果都采取继承方法,将会产生很多子类,显然相当繁琐.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.5-decorator/","summary":"Decorator(装饰者模式) 定义 动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.\n本质 interface(一般都要)\n主要是编写 被装饰者，在构造函数中加入装饰者，然后在被装饰者类中注意对装饰者类的调用\n为什么使用Decorator? 我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.\n使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了\u0026quot;即插即用\u0026quot;的方法,在运行期间决定何时增加何种功能.\n如何使用? 举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.\n我们先建立一个接口:\npublic interface Work { public void insert(); } 接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:\npublic class SquarePeg implements Work{ public void insert(){ System.out.println(\u0026#34;方形桩插入\u0026#34;); } } 现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).\n那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些\u0026quot;油漆\u0026quot;,这些油漆就是那些额外的功能.\npublic class Decorator implements Work{ private Work work; //额外增加的功能被打包在这个List中 private ArrayList others = new ArrayList(); //在构造器中使用组合new方式,引入Work对象; public Decorator(Work work) { this.work=work; others.add(\u0026#34;挖坑\u0026#34;); others.add(\u0026#34;钉木板\u0026#34;); } public void insert(){ newMethod(); } //在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 public void newMethod() { otherMethod(); work.","title":"2.5 Decorator"},{"content":"Adapter(适配者模式) 定义 将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份.\n为何使用? 我们经常碰到要将两个没有关系的类组合在一起使用,第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?\n使用Adapter，在这两种接口之间创建一个混合接口(混血儿).\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.3-adapter/","summary":"Adapter(适配者模式) 定义 将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份.\n为何使用? 我们经常碰到要将两个没有关系的类组合在一起使用,第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?\n使用Adapter，在这两种接口之间创建一个混合接口(混血儿).","title":"2.3 Adapter"},{"content":"Proxy(代理模式)定义 为其他对象提供一种代理以控制对这个对象的访问.\n代理模式是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结构,Proxy是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理.\n为什么要使用Proxy? 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.\n某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况:\n如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.\n如何使用Proxy? 以Jive论坛系统为例,访问论坛系统的用户有多种类型:注册普通用户 论坛管理者 系统管理者 游客,注册普通用户才能发言;论坛管理者可以管理他被授权的论坛;系统管理者可以管理所有事务等,这些权限划分和管理是使用Proxy完成的.\nForum是Jive的核心接口,在Forum中陈列了有关论坛操作的主要行为,如论坛名称 论坛描述的获取和修改,帖子发表删除编辑等.\n在ForumPermissions中定义了各种级别权限的用户:\npublic class ForumPermissions implements Cacheable { /** * Permission to read object. */ public static final int READ = 0; /** * Permission to administer the entire sytem. */ public static final int SYSTEM_ADMIN = 1; /** * Permission to administer a particular forum. */ public static final int FORUM_ADMIN = 2; /** * Permission to administer a particular user. */ public static final int USER_ADMIN = 3; /** * Permission to administer a particular group. */ public static final int GROUP_ADMIN = 4; /** * Permission to moderate threads. */ public static final int MODERATE_THREADS = 5; /** * Permission to create a new thread. */ public static final int CREATE_THREAD = 6; /** * Permission to create a new message. */ public static final int CREATE_MESSAGE = 7; /** * Permission to moderate messages. */ public static final int MODERATE_MESSAGES = 8; ..... public boolean isSystemOrForumAdmin() { return (values[FORUM_ADMIN] || values[SYSTEM_ADMIN]); } ..... } 因此,Forum中各种操作权限是和ForumPermissions定义的用户级别有关系的,作为接口Forum的实现:ForumProxy正是将这种对应关系联系起来.比如,修改Forum的名称,只有论坛管理者或系统管理者可以修改,代码如下:\npublic class ForumProxy implements Forum { private ForumPermissions permissions; private Forum forum; this.authorization = authorization; public ForumProxy(Forum forum, Authorization authorization, ForumPermissions permissions) { this.forum = forum; this.authorization = authorization; this.permissions = permissions; } ..... public void setName(String name) throws UnauthorizedException, ForumAlreadyExistsException { //只有是系统或论坛管理者才可以修改名称 if (permissions.isSystemOrForumAdmin()) { forum.setName(name); } else { throw new UnauthorizedException(); } } ... } 而DbForum才是接口Forum的真正实现,以修改论坛名称为例:\npublic class DbForum implements Forum, Cacheable { ... public void setName(String name) throws ForumAlreadyExistsException { .... this.name = name; //这里真正将新名称保存到数据库中 saveToDb(); .... } ... } 凡是涉及到对论坛名称修改这一事件,其他程序都首先得和ForumProxy打交道,由ForumProxy决定是否有权限做某一样事情,ForumProxy是个名副其实的\u0026quot;网关\u0026quot;,\u0026ldquo;安全代理系统\u0026rdquo;.\n在平时应用中,无可避免总要涉及到系统的授权或安全体系,不管你有无意识的使用Proxy,实际你已经在使用Proxy了.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.2-proxy/","summary":"Proxy(代理模式)定义 为其他对象提供一种代理以控制对这个对象的访问.\n代理模式是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结构,Proxy是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理.\n为什么要使用Proxy? 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.\n某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况:\n如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.\n如何使用Proxy? 以Jive论坛系统为例,访问论坛系统的用户有多种类型:注册普通用户 论坛管理者 系统管理者 游客,注册普通用户才能发言;论坛管理者可以管理他被授权的论坛;系统管理者可以管理所有事务等,这些权限划分和管理是使用Proxy完成的.\nForum是Jive的核心接口,在Forum中陈列了有关论坛操作的主要行为,如论坛名称 论坛描述的获取和修改,帖子发表删除编辑等.\n在ForumPermissions中定义了各种级别权限的用户:\npublic class ForumPermissions implements Cacheable { /** * Permission to read object. */ public static final int READ = 0; /** * Permission to administer the entire sytem. */ public static final int SYSTEM_ADMIN = 1; /** * Permission to administer a particular forum. */ public static final int FORUM_ADMIN = 2; /** * Permission to administer a particular user.","title":"2.2 Proxy"},{"content":"Facade (外观 总管模式）定义 为子系统中的一组接口提供一个一致的界面.\n链接\nFacade一个典型应用就是数据库JDBC的应用\n所有程序对数据库访问都是使用改接口,降低系统的复杂性,增加了灵活性.\n如果我们要使用连接池,也只要针对facade接口修改就可以.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.1-facade/","summary":"Facade (外观 总管模式）定义 为子系统中的一组接口提供一个一致的界面.\n链接\nFacade一个典型应用就是数据库JDBC的应用\n所有程序对数据库访问都是使用改接口,降低系统的复杂性,增加了灵活性.\n如果我们要使用连接池,也只要针对facade接口修改就可以.","title":"2.1 Facade"},{"content":"Builder(建造者模式）定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.\nBuilder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.\n为何使用? 是为了将构建复杂对象的过程和它的部件解耦.注意: 是解耦过程和部件.\n因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.\n如何使用? 首先假设一个复杂对象是由多个部件组成的,Builder模式是把复杂对象的创建和部件的创建分别开来,分别用Builder类和Director类来表示.\n首先,需要一个接口,它定义如何创建复杂对象的各个部件:\npublic interface Builder { //创建部件A　比如创建汽车车轮 void buildPartA(); //创建部件B 比如创建汽车方向盘 void buildPartB(); //创建部件C 比如创建汽车发动机 void buildPartC(); //返回最后组装成品结果 (返回最后装配好的汽车) //成品的组装过程不在这里进行,而是转移到下面的Director类中进行. //从而实现了解耦过程和部件 Product getResult(); } 用Director构建最后的复杂对象,而在上面Builder接口中封装的是如何创建一个个部件(复杂对象是由这些部件组成的),也就是说Director的内容是如何将部件最后组装成成品:\npublic class Director { private Builder builder; public Director( Builder builder ) { this.builder = builder; } // 将部件partA partB partC最后组成复杂对象 //这里是将车轮 方向盘和发动机组装成汽车的过程 public void construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); } } Builder的具体实现ConcreteBuilder:\n通过具体完成接口Builder来构建或装配产品的部件; 定义并明确它所要创建的是什么具体东西; 提供一个可以重新获取产品的接口: public class ConcreteBuilder implements Builder { Part partA, partB, partC; public void buildPartA() { //这里是具体如何构建partA的代码 }; public void buildPartB() { //这里是具体如何构建partB的代码 }; public void buildPartC() { //这里是具体如何构建partB的代码 }; public Product getResult() { //返回最后组装成品结果 }; } 复杂对象:产品Product:\npublic interface Product { } 复杂对象的部件:\npublic interface Part { } 我们看看如何调用Builder模式:\nConcreteBuilder builder = new ConcreteBuilder(); Director director = new Director( builder ); director.construct(); Product product = builder.getResult(); 应用 在Java实际使用中,我们经常用到\u0026quot;池\u0026quot;(Pool)的概念,当资源提供者无法提供足够的资源,并且这些资源需要被很多用户反复共享时,就需要使用池.\n\u0026ldquo;池\u0026quot;实际是一段内存,当池中有一些复杂的资源的\u0026quot;断肢\u0026rdquo;(比如数据库的连接池,也许有时一个连接会中断),如果循环再利用这些\u0026quot;断肢\u0026quot;,将提高内存使用效率,提高池的性能.修改Builder模式中Director类使之能诊断\u0026quot;断肢\u0026quot;断在哪个部件上,再修复这个部件.\n","permalink":"https://blog.chalme.top/posts/design-patterns/1.4-builder/","summary":"Builder(建造者模式）定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.\nBuilder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.\n为何使用? 是为了将构建复杂对象的过程和它的部件解耦.注意: 是解耦过程和部件.\n因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.\n如何使用? 首先假设一个复杂对象是由多个部件组成的,Builder模式是把复杂对象的创建和部件的创建分别开来,分别用Builder类和Director类来表示.\n首先,需要一个接口,它定义如何创建复杂对象的各个部件:\npublic interface Builder { //创建部件A　比如创建汽车车轮 void buildPartA(); //创建部件B 比如创建汽车方向盘 void buildPartB(); //创建部件C 比如创建汽车发动机 void buildPartC(); //返回最后组装成品结果 (返回最后装配好的汽车) //成品的组装过程不在这里进行,而是转移到下面的Director类中进行. //从而实现了解耦过程和部件 Product getResult(); } 用Director构建最后的复杂对象,而在上面Builder接口中封装的是如何创建一个个部件(复杂对象是由这些部件组成的),也就是说Director的内容是如何将部件最后组装成成品:\npublic class Director { private Builder builder; public Director( Builder builder ) { this.builder = builder; } // 将部件partA partB partC最后组成复杂对象 //这里是将车轮 方向盘和发动机组装成汽车的过程 public void construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); } } Builder的具体实现ConcreteBuilder:\n通过具体完成接口Builder来构建或装配产品的部件; 定义并明确它所要创建的是什么具体东西; 提供一个可以重新获取产品的接口: public class ConcreteBuilder implements Builder { Part partA, partB, partC; public void buildPartA() { //这里是具体如何构建partA的代码 }; public void buildPartB() { //这里是具体如何构建partB的代码 }; public void buildPartC() { //这里是具体如何构建partB的代码 }; public Product getResult() { //返回最后组装成品结果 }; } 复杂对象:产品Product:","title":"1.4 Builder"},{"content":"Singleton (单例模式）定义 Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。\n在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作. 还有, singleton能够被状态化; 这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要论坛中的帖子计数器，每次浏览一次需要计数，单态类能否保持住这个计数，并且能synchronize的安全自动加1，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。\n另外方面，Singleton也能够被无状态化。提供工具性质的功能，\nSingleton模式就为我们提供了这样实现的可能。使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。\n我们常常看到工厂模式中类装入器(class loader)中也用Singleton模式实现的,因为被装入的类实际也属于资源。\n如何使用 public class Singleton { private Singleton(){} //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问　public static Singleton getInstance() { return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class TestInstance{ private static TestInstance instance; public static TestInstance getInstance{ if(instance==null){ synchronized(TestInstance.class){ if(instance==null){ instance=new TestInstance(); } } return instance; } } public class SingleClass2{ private static class SingleInstance{ private static SingleClass2 instance = new SingleClass2(); } private SingleClass2(){ } public static SingleClass2 CreateInstance(){ return SingleInstance.instance; } } ","permalink":"https://blog.chalme.top/posts/design-patterns/1.3-singleton/","summary":"Singleton (单例模式）定义 Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。\n在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作. 还有, singleton能够被状态化; 这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要论坛中的帖子计数器，每次浏览一次需要计数，单态类能否保持住这个计数，并且能synchronize的安全自动加1，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。\n另外方面，Singleton也能够被无状态化。提供工具性质的功能，\nSingleton模式就为我们提供了这样实现的可能。使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。\n我们常常看到工厂模式中类装入器(class loader)中也用Singleton模式实现的,因为被装入的类实际也属于资源。\n如何使用 public class Singleton { private Singleton(){} //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问　public static Singleton getInstance() { return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class TestInstance{ private static TestInstance instance; public static TestInstance getInstance{ if(instance==null){ synchronized(TestInstance.","title":"1.3 Singleton"},{"content":"Prototype Prototype （原型模式）定义 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 使用 java中有 clone 方法来实现对象的克隆，所以。。。 以 勺子为例\npublic abstract class AbstractSpoon implements Cloneable { String spoonName; public void setSpoonName(String spoonName) {this.spoonName = spoonName;} public String getSpoonName() {return this.spoonName;} public Object clone() { Object object = null; try { object = super.clone(); } catch (CloneNotSupportedException exception) { System.err.println(\u0026#34;AbstractSpoon is not Cloneable\u0026#34;); } return object; } } public class SoupSpoon extends AbstractSpoon { public SoupSpoon() { setSpoonName(\u0026#34;Soup Spoon\u0026#34;); } } 调用Prototype模式很简单:\nAbstractSpoon spoon = new SoupSpoon(); AbstractSpoon spoon2 = spoon.clone(); 当然也可以结合工厂模式来创建AbstractSpoon实例。 实质： java 使用object 类的clone 方法\n","permalink":"https://blog.chalme.top/posts/design-patterns/1.2-prototype/","summary":"Prototype Prototype （原型模式）定义 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 使用 java中有 clone 方法来实现对象的克隆，所以。。。 以 勺子为例\npublic abstract class AbstractSpoon implements Cloneable { String spoonName; public void setSpoonName(String spoonName) {this.spoonName = spoonName;} public String getSpoonName() {return this.spoonName;} public Object clone() { Object object = null; try { object = super.clone(); } catch (CloneNotSupportedException exception) { System.err.println(\u0026#34;AbstractSpoon is not Cloneable\u0026#34;); } return object; } } public class SoupSpoon extends AbstractSpoon { public SoupSpoon() { setSpoonName(\u0026#34;Soup Spoon\u0026#34;); } } 调用Prototype模式很简单:","title":"1.2 Prototype"},{"content":"工厂模式定义 提供创建对象的接口\n详细1\n详细2\n简介 简单工厂模式\n工厂方法模式\n抽象工厂模式\n简单工厂模式 它由三种角色组成（关系见下面的类图）：\n工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。\n抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。\n具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。\n本质 : 在Creator 中 create 方法中 使用 equals(string name)方法来创建 Product。\n//抽象产品角色 public interface Car{ public void drive(); } //具体产品角色 public class Benz implements Car{ public void drive() { System.out.println(\u0026#34;Driving Benz \u0026#34;); } } public class Bmw implements Car{ public void drive() { System.out.println(\u0026#34;Driving Bmw \u0026#34;); } } 。。。（奥迪我就不写了:P） //工厂类角色 public class Driver{ //工厂方法 //注意 返回类型为抽象产品角色 public static Car driverCar(String s)throws Exception { //判断逻辑，返回具体的产品角色给Client if(s.equalsIgnoreCase(\u0026#34;Benz\u0026#34;)) return new Benz(); else if(s.equalsIgnoreCase(\u0026#34;Bmw\u0026#34;)) return new Bmw(); ...... else throw new Exception(); 。。。 //欢迎暴发户出场...... public class Magnate{ public static void main(String[] args){ try{ //告诉司机我今天坐奔驰 Car car = Driver.driverCar(\u0026#34;benz\u0026#34;); //下命令：开车 car.drive(); 。。。 工厂方法模式 先来看下它的组成吧：\n抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4、具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 //抽象工厂角色 public interface Driver{ public Car driverCar(); } public class BenzDriver implements Driver{ public Car driverCar(){ return new Benz(); } } public class BmwDriver implements Driver{ public Car driverCar() { return new Bmw(); } } ......//应该和具体产品形成对应关系，这里略... //有请暴发户先生 public class Magnate { public static void main(String[] args) { try{ Driver driver = new BenzDriver(); Car car = driver.driverCar(); car.drive(); }catch(Exception e) { } } } 抽象工厂模式 抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。而且使用抽象工厂模式还要满足一下条件：\n系统中有多个产品族，而系统一次只可能消费其中一族产品 同属于同一个产品族的产品一起使用时。 来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：\n抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 ","permalink":"https://blog.chalme.top/posts/design-patterns/1.1-factory/","summary":"工厂模式定义 提供创建对象的接口\n详细1\n详细2\n简介 简单工厂模式\n工厂方法模式\n抽象工厂模式\n简单工厂模式 它由三种角色组成（关系见下面的类图）：\n工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。\n抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。\n具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。\n本质 : 在Creator 中 create 方法中 使用 equals(string name)方法来创建 Product。\n//抽象产品角色 public interface Car{ public void drive(); } //具体产品角色 public class Benz implements Car{ public void drive() { System.out.println(\u0026#34;Driving Benz \u0026#34;); } } public class Bmw implements Car{ public void drive() { System.out.println(\u0026#34;Driving Bmw \u0026#34;); } } 。。。（奥迪我就不写了:P） //工厂类角色 public class Driver{ //工厂方法 //注意 返回类型为抽象产品角色 public static Car driverCar(String s)throws Exception { //判断逻辑，返回具体的产品角色给Client if(s.","title":"1.1 Factory"},{"content":"设计模式(Patterns in Java) 链接 另类的设计模式\n图说设计模式\n如今设计模式已经成为架构师和程序员之间沟通的必备语言，也是普通程序员成长为资深程序员的必备基础之一。只有掌握了设计模式，才能更好地掌握DDD领域驱动设计等OO分析设计方法，也才能更熟练地学习使用不断涌现的新语言。\n创建模式（5） Factory(工厂模式）\nPrototype(原型模式）\nBuilder\nSingleton(单例模式）\n结构模式（7） Facade\nProxy\nAdapter\nComposite\nDecorator\nBridge\nFlyweight\n行为模式（11） Template(模板模式）\nMemento(备忘录模式）\nObserver(观察者模式）\nChain of Responsibility(CoR)\nCommand\nState\nStrategy\nmediator\nInterperter\nVivistor\nIterator\n","permalink":"https://blog.chalme.top/posts/design-patterns/0.0-outline/","summary":"设计模式(Patterns in Java) 链接 另类的设计模式\n图说设计模式\n如今设计模式已经成为架构师和程序员之间沟通的必备语言，也是普通程序员成长为资深程序员的必备基础之一。只有掌握了设计模式，才能更好地掌握DDD领域驱动设计等OO分析设计方法，也才能更熟练地学习使用不断涌现的新语言。\n创建模式（5） Factory(工厂模式）\nPrototype(原型模式）\nBuilder\nSingleton(单例模式）\n结构模式（7） Facade\nProxy\nAdapter\nComposite\nDecorator\nBridge\nFlyweight\n行为模式（11） Template(模板模式）\nMemento(备忘录模式）\nObserver(观察者模式）\nChain of Responsibility(CoR)\nCommand\nState\nStrategy\nmediator\nInterperter\nVivistor\nIterator","title":"0.0 outline"},{"content":"","permalink":"https://blog.chalme.top/categories/","summary":"categories","title":"Category"}]