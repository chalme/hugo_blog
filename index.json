[{"content":"概述 sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n基础 -E -- use extended regular expressions -a -- delay opening files listed with w function -e -- specify sed commands to run -f -- add contents of file to commands to run -i -- edit files in-place, running scripts separately for each file -l -- make output line buffered -n -- suppress automatic printing of pattern space a,append 追加 i,insert 插入 d,delete 删除 s,substitution 替换 c,change 修改 y,transform 转换 替换 替换标记 s（substitution）默认情况下只替换每行中出现的第一处。使用替换标记（substitution flag）指定替换位置。替换标记在替换命令字符串之后设置。 s/pattern/replacement/flags 有4种可用的替换标记：\n数字，表明新文本将替换第几处模式匹配的地方； g，表明新文本将会替换所有匹配的文本； p，表明替换过的行要打印出来； w file，将替换的结果写到文件中。 替换字符 sed允许选择其他字符来作为替换命令中的字符串分隔符：\nsed \u0026#39;s!/bin/bash!/bin/csh!\u0026#39; /etc/passwd 使用地址 默认情况下，sed命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（line addressing）。\n以数字形式表示行区间 用文本模式来过滤出行 格式 [address]command 以数字形式表示行区间 sed \u0026#39;2s/dog/cat/\u0026#39; data1.txt sed \u0026#39;2,3s/dog/cat/\u0026#39; data1.txt sed \u0026#39;2,$s/dog/cat/\u0026#39; data1.txt 使用文本模式过滤器 sed编辑器允许指定文本模式来过滤出命令要作用的行 /pattern/command\nsed -n \u0026#39;/special/s/test/dog/p\u0026#39; data1.txt 命令组合 sed \u0026#39;2{ \u0026gt; s/fox/elephant/ \u0026gt; s/dog/cat/ \u0026gt; }\u0026#39; data1.txt 删除行 删除命令d删除匹配指定寻址模式的所有行。如果没有加入寻址模式，流中的所有文本行都会被删除。\nsed \u0026#39;1d\u0026#39; data1.txt sed \u0026#39;/spe/d\u0026#39; data1.txt 插入和附加文本 插入（insert）命令（i）会在指定行前增加一个新行； 附加（append）命令（a）会在指定行后增加一个新行。 sed \u0026#39;[address]command\\ new line\u0026#39; $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;i\\Test Line 1\u0026#39; Test Line 1 Test Line 2 $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;a\\Test Line 1\u0026#39; Test Line 2 Test Line 1 #在命令行上使用sed时，会看到次提示符来提醒输入新的行数据。必须在该行完成sed编辑器命令。 $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;i\\ \u0026gt; Test Line 1\u0026#39; Test Line 1 Test Line 2 修改行 修改（change）命令(c)允许修改(替换)数据流中整行文本的内容.如果作用于地址区间，sed会用一行文本代替区间内的所有行，而非逐一替换。\nsed \u0026#39;1,2c\\ hello \u0026#39; data1.txt 转换命令 转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。转换命令格式如下: [address]y/inchars/outchars/\n回顾打印 3个命令也能用来打印数据流中的信息： p命令用来打印文本行； 等号（=）命令用来打印行号； l（小写的L）命令用来列出行。\n使用sed处理文件 写入文件 w命令用来向文件写入行 [address]w filename\n从文件读取数据 读取（read）命令（r）将一个独立文件中的数据插入到数据流中 [address]r filename\nhttps://jixiaocan.github.io/posts/cmd-sed/ https://markrepo.github.io/commands/2018/06/26/sed/ ","permalink":"https://blog.chalme.top/posts/linux/command/sed/","summary":"概述 sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n基础 -E -- use extended regular expressions -a -- delay opening files listed with w function -e -- specify sed commands to run -f -- add contents of file to commands to run -i -- edit files in-place, running scripts separately for each file -l -- make output line buffered -n -- suppress automatic printing of pattern space a,append 追加 i,insert 插入 d,delete 删除 s,substitution 替换 c,change 修改 y,transform 转换 替换 替换标记 s（substitution）默认情况下只替换每行中出现的第一处。使用替换标记（substitution flag）指定替换位置。替换标记在替换命令字符串之后设置。 s/pattern/replacement/flags 有4种可用的替换标记：","title":"Sed"},{"content":"First This is first post !!! hji h-\nh-title\ntest hello, world!\n","permalink":"https://blog.chalme.top/posts/first/","summary":"First This is first post !!! hji h-\nh-title\ntest hello, world!","title":"First"},{"content":"Iterator pattern(迭代器模式) 这个模式已经被整合入Java的Collection.在大多数场合下无需自己制造一个Iterator,只要将对象装入Collection中，直接使用Iterator进行对象遍历.更多\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.11-iterator/","summary":"Iterator pattern(迭代器模式) 这个模式已经被整合入Java的Collection.在大多数场合下无需自己制造一个Iterator,只要将对象装入Collection中，直接使用Iterator进行对象遍历.更多","title":"3.11 Iterator"},{"content":"Visitor pattern (访问者模式) 作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.\n在Java中,Visitor模式实际上是分离了collection结构中的元素和对这些元素进行操作的行为. 为何使用Visitor? Java的Collection(包括Vector和Hashtable)是我们最经常使用的技术,可是Collection好象是个黑色大染缸,本来有各种鲜明类型特征的对象一旦放入后,再取出时,这些类型就消失了.那么我们势必要用If来判断,如:\nIterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Collection) messyPrintCollection((Collection)o); else if (o instanceof String) System.out.println(\u0026#34;\u0026#39;\u0026#34;+o.toString()+\u0026#34;\u0026#39;\u0026#34;); else if (o instanceof Float) System.out.println(o.toString()+\u0026#34;f\u0026#34;); else System.out.println(o.toString()); } 在上例中,我们使用了 instanceof来判断 o的类型.\n很显然,这样做的缺点代码If else if 很繁琐.我们就可以使用Visitor模式解决它.\n如何使用Visitor? 针对上例,定义接口叫Visitable,用来定义一个Accept操作,也就是说让Collection每个元素具备可访问性.\n被访问者是我们Collection的每个元素Element,我们要为这些Element定义一个可以接受访问的接口(访问和被访问是互动的,只有访问者,被访问者如果表示不欢迎,访问者就不能访问),取名为Visitable，也可取名为Element。\npublic interface Visitable { public void accept(Visitor visitor); } 被访问的具体元素继承这个新的接口Visitable：\npublic class StringElement implements Visitable { private String value; public StringElement(String string) { value = string; } public String getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.visitString(this); } } 上面是被访问者是字符串类型，下面再建立一个Float类型的：\npublic class FloatElement implements Visitable { private Float value; public FloatElement(Float value) { this.value = value; } public Float getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.visitFloat(this); } } 我们设计一个接口visitor访问者，在这个接口中,有一些访问操作，这些访问操作是专门访问对象集合Collection中有可能的所有类，目前我们假定有三个行为：访问对象集合中的字符串类型；访问对象集合中的Float类型；访问对象集合中的对象集合类型。注意最后一个类型是集合嵌套，通过这个嵌套实现可以看出使用访问模式的一个优点。\n接口visitor访问者如下：\npublic interface Visitor { public void visitString(StringElement stringE); public void visitFloat(FloatElement floatE); public void visitCollection(Collection collection); } 访问者的实现:\npublic class ConcreteVisitor implements Visitor { //在本方法中,我们实现了对Collection的元素的成功访问 public void visitCollection(Collection collection) { Iterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Visitable) ((Visitable)o).accept(this); } ｝ public void visitString(StringElement stringE) { System.out.println(\u0026#34;\u0026#39;\u0026#34;+stringE.getValue()+\u0026#34;\u0026#39;\u0026#34;); } public void visitFloat(FloatElement floatE){ System.out.println(floatE.getValue().toString()+\u0026#34;f\u0026#34;); } } 在上面的visitCollection我们实现了对Collection每个元素访问,只使用了一个判断语句,只要判断其是否可以访问.\nStringElement只是一个实现，可以拓展为更多的实现，整个核心奥妙在accept方法中，在遍历Collection时，通过相应的accept方法调用具体类型的被访问者。这一步确定了被访问者类型，\n如果是StringElement，而StringElement则回调访问者的visiteString方法，这一步实现了行为操作方法。\n客户端代码：\nVisitor visitor = new ConcreteVisitor(); StringElement stringE = new StringElement(\u0026#34;I am a String\u0026#34;); visitor.visitString(stringE); Collection list = new ArrayList(); list.add(new StringElement(\u0026#34;I am a String1\u0026#34;)); list.add(new StringElement(\u0026#34;I am a String2\u0026#34;)); list.add(new FloatElement(new Float(12))); list.add(new StringElement(\u0026#34;I am a String3\u0026#34;)); visitor.visitCollection(list); 客户端代码中的list对象集合中放置了多种数据类型，对对象集合中的访问不必象一开始那样，使用instance of逐个判断，而是通过访问者模式巧妙实现了。\n至此,我们完成了Visitor模式基本结构.\n使用Visitor模式的前提 使用访问者模式是对象群结构中(Collection) 中的对象类型很少改变。\n在两个接口Visitor和Visitable中,确保Visitable很少变化,也就是说，确保不能老有新的Element元素类型加进来，可以变化的是访问者行为或操作，也就是Visitor的不同子类可以有多种,这样使用访问者模式最方便.\n如果对象集合中的对象集合经常有变化, 那么不但Visitor实现要变化，Visistable也要增加相应行为，GOF建议是,不如在这些对象类中直接逐个定义操作，无需使用访问者设计模式。\n但是在Java中，Java的Reflect技术解决了这个问题，因此结合reflect反射机制，可以使得访问者模式适用范围更广了。\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.10-visitor/","summary":"Visitor pattern (访问者模式) 作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.\n在Java中,Visitor模式实际上是分离了collection结构中的元素和对这些元素进行操作的行为. 为何使用Visitor? Java的Collection(包括Vector和Hashtable)是我们最经常使用的技术,可是Collection好象是个黑色大染缸,本来有各种鲜明类型特征的对象一旦放入后,再取出时,这些类型就消失了.那么我们势必要用If来判断,如:\nIterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Collection) messyPrintCollection((Collection)o); else if (o instanceof String) System.out.println(\u0026#34;\u0026#39;\u0026#34;+o.toString()+\u0026#34;\u0026#39;\u0026#34;); else if (o instanceof Float) System.out.println(o.toString()+\u0026#34;f\u0026#34;); else System.out.println(o.toString()); } 在上例中,我们使用了 instanceof来判断 o的类型.\n很显然,这样做的缺点代码If else if 很繁琐.我们就可以使用Visitor模式解决它.\n如何使用Visitor? 针对上例,定义接口叫Visitable,用来定义一个Accept操作,也就是说让Collection每个元素具备可访问性.\n被访问者是我们Collection的每个元素Element,我们要为这些Element定义一个可以接受访问的接口(访问和被访问是互动的,只有访问者,被访问者如果表示不欢迎,访问者就不能访问),取名为Visitable，也可取名为Element。\npublic interface Visitable { public void accept(Visitor visitor); } 被访问的具体元素继承这个新的接口Visitable：\npublic class StringElement implements Visitable { private String value; public StringElement(String string) { value = string; } public String getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.","title":"3.10 Visitor"},{"content":"Interpreter pattern(解释者模式) 定义 定义语言的文法 ,并且建立一个解释器来解释该语言中的句子.\nInterpreter似乎使用面不是很广,它描述了一个语言解释器是如何构成的,在实际应用中,我们可能很少去构造一个语言的文法.我们还是来简单的了解一下: 首先要建立一个接口,用来描述共同的操作.\npublic interface AbstractExpression { void interpret( Context context ); } 再看看包含解释器之外的一些全局信息\npublic interface Context { } AbstractExpression的具体实现分两种:终结符表达式和非终结符表达式:\npublic class TerminalExpression implements AbstractExpression { public void interpret( Context context ) { } } 对于文法中没一条规则,非终结符表达式都必须的:\npublic class NonterminalExpression implements AbstractExpression { private AbstractExpression successor; public void setSuccessor( AbstractExpression successor ) { this.successor = successor; } public AbstractExpression getSuccessor() { return successor; } public void interpret( Context context ) { } } ","permalink":"https://blog.chalme.top/posts/design-patterns/3.9-interpreter/","summary":"Interpreter pattern(解释者模式) 定义 定义语言的文法 ,并且建立一个解释器来解释该语言中的句子.\nInterpreter似乎使用面不是很广,它描述了一个语言解释器是如何构成的,在实际应用中,我们可能很少去构造一个语言的文法.我们还是来简单的了解一下: 首先要建立一个接口,用来描述共同的操作.\npublic interface AbstractExpression { void interpret( Context context ); } 再看看包含解释器之外的一些全局信息\npublic interface Context { } AbstractExpression的具体实现分两种:终结符表达式和非终结符表达式:\npublic class TerminalExpression implements AbstractExpression { public void interpret( Context context ) { } } 对于文法中没一条规则,非终结符表达式都必须的:\npublic class NonterminalExpression implements AbstractExpression { private AbstractExpression successor; public void setSuccessor( AbstractExpression successor ) { this.successor = successor; } public AbstractExpression getSuccessor() { return successor; } public void interpret( Context context ) { } } ","title":"3.9 Interpreter"},{"content":"Mediator pattern(中介者模式) 定义 用一个中介对象来封装一系列关于对象交互行为.\n为何使用Mediator? 各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性.\n如何使用? 首先 有一个接口,用来定义成员对象之间的交互联系方式:\npublic interface Mediator { } Meiator具体实现,真正实现交互操作的内容:\npublic class ConcreteMediator implements Mediator { //假设当前有两个成员. private ConcreteColleague1 colleague1 = new ConcreteColleague1(); private ConcreteColleague2 colleague2 = new ConcreteColleague2(); ... } 再看看另外一个参与者:成员,因为是交互行为,都需要双方提供一些共同接口,这种要求在Visitor Observer等模式中都是相同的.\npublic class Colleague { private Mediator mediator; public Mediator getMediator() { return mediator; } public void setMediator( Mediator mediator ) { this.mediator = mediator; } } public class ConcreteColleague1 { } public class ConcreteColleague2 { } 每个成员都必须知道Mediator,并且和 Mediator联系,而不是和其他成员联系.\n至此,Mediator模式框架完成,可以发现Mediator模式规定不是很多,大体框架也比较简单,但实际使用起来就非常灵活.\nMediator模式在事件驱动类应用中比较多,例如界面设计GUI.;聊天,消息传递等,在聊天应用中,需要有一个MessageMediator,专门负责request/reponse之间任务的调节. MVC是J2EE的一个基本模式,View Controller是一种Mediator,它是Jsp和服务器上应用程序间的Mediator.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.8-mediator/","summary":"Mediator pattern(中介者模式) 定义 用一个中介对象来封装一系列关于对象交互行为.\n为何使用Mediator? 各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性.\n如何使用? 首先 有一个接口,用来定义成员对象之间的交互联系方式:\npublic interface Mediator { } Meiator具体实现,真正实现交互操作的内容:\npublic class ConcreteMediator implements Mediator { //假设当前有两个成员. private ConcreteColleague1 colleague1 = new ConcreteColleague1(); private ConcreteColleague2 colleague2 = new ConcreteColleague2(); ... } 再看看另外一个参与者:成员,因为是交互行为,都需要双方提供一些共同接口,这种要求在Visitor Observer等模式中都是相同的.\npublic class Colleague { private Mediator mediator; public Mediator getMediator() { return mediator; } public void setMediator( Mediator mediator ) { this.mediator = mediator; } } public class ConcreteColleague1 { } public class ConcreteColleague2 { } 每个成员都必须知道Mediator,并且和 Mediator联系,而不是和其他成员联系.","title":"3.8 Mediator"},{"content":"Strategy pattern(策略模式) 定义 属于设计模式中 对象行为型模式,主要是定义一系列的算法,把这些算法一个个封装成单独的类.\nStratrgy应用比较广泛,比如, 公司经营业务变化图, 可能有两种实现方式,一个是线条曲线,一个是框图(bar),这是两种算法,可以使用Strategy实现. 如何使用? 这里以字符串替代为例, 有一个文件,我们需要读取后,希望替代其中相应的变量,然后输出.关于替代其中变量的方法可能有多种方法,这取决于用户的要求,所以我们要准备几套变量字符替代方案. 首先,我们建立一个抽象类RepTempRule 定义一些公用变量和方法:\npublic abstract class RepTempRule{ protected String oldString=\u0026#34;\u0026#34;; public void setOldString(String oldString){ this.oldString=oldString; } protected String newString=\u0026#34;\u0026#34;; public String getNewString(){ return newString; } public abstract void replace() throws Exception; } 在RepTempRule中 有一个抽象方法abstract需要继承明确,这个replace里其实是替代的具体方法. 我们现在有两个字符替代方案, 1.将文本中aaa替代成bbb; 2.将文本中aaa替代成ccc;\n对应的类分别是RepTempRuleOne RepTempRuleTwo\npublic class RepTempRuleOne extends RepTempRule{ public void replace() throws Exception{ //replaceFirst是jdk1.4新特性 newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;) System.out.println(\u0026#34;this is replace one\u0026#34;); } } public class RepTempRuleTwo extends RepTempRule{ public void replace() throws Exception{ newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;ccc\u0026#34;) System.out.println(\u0026#34;this is replace Two\u0026#34;);　} } 第二步：我们要建立一个算法解决类，用来提供客户端可以自由选择算法。\npublic class RepTempRuleSolve { private RepTempRule strategy; public RepTempRuleSolve(RepTempRule rule){ this.strategy=rule; } public String getNewContext(Site site,String oldString) { return strategy.replace(site,oldString); } public void changeAlgorithm(RepTempRule newAlgorithm) { strategy = newAlgorithm; } } 调用如下:\npublic class test{ ...... public void testReplace(){ //使用第一套替代方案 RepTempRuleSolve solver=new RepTempRuleSolve(new RepTempRuleOne()); solver.getNewContext(site,context); //使用第二套 solver=new RepTempRuleSolve(new RepTempRuleTwo()); solver.getNewContext(site,context); } ..... } 我们达到了在运行期间，可以自由切换算法的目的。\n实际整个Strategy的核心部分就是抽象类的使用,使用Strategy模式可以在用户需要变化时,修改量很少,而且快速.\nStrategy和Factory有一定的类似,Strategy相对简单容易理解,并且可以在运行时刻自由切换。Factory重点是用来创建对象。\nStrategy适合下列场合: 以不同的格式保存文件;\n以不同的算法压缩文件;\n以不同的算法截获图象;\n以不同的格式输出同样数据的图形,比如曲线 或框图bar等\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.7-strategy/","summary":"Strategy pattern(策略模式) 定义 属于设计模式中 对象行为型模式,主要是定义一系列的算法,把这些算法一个个封装成单独的类.\nStratrgy应用比较广泛,比如, 公司经营业务变化图, 可能有两种实现方式,一个是线条曲线,一个是框图(bar),这是两种算法,可以使用Strategy实现. 如何使用? 这里以字符串替代为例, 有一个文件,我们需要读取后,希望替代其中相应的变量,然后输出.关于替代其中变量的方法可能有多种方法,这取决于用户的要求,所以我们要准备几套变量字符替代方案. 首先,我们建立一个抽象类RepTempRule 定义一些公用变量和方法:\npublic abstract class RepTempRule{ protected String oldString=\u0026#34;\u0026#34;; public void setOldString(String oldString){ this.oldString=oldString; } protected String newString=\u0026#34;\u0026#34;; public String getNewString(){ return newString; } public abstract void replace() throws Exception; } 在RepTempRule中 有一个抽象方法abstract需要继承明确,这个replace里其实是替代的具体方法. 我们现在有两个字符替代方案, 1.将文本中aaa替代成bbb; 2.将文本中aaa替代成ccc;\n对应的类分别是RepTempRuleOne RepTempRuleTwo\npublic class RepTempRuleOne extends RepTempRule{ public void replace() throws Exception{ //replaceFirst是jdk1.4新特性 newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;) System.out.println(\u0026#34;this is replace one\u0026#34;); } } public class RepTempRuleTwo extends RepTempRule{ public void replace() throws Exception{ newString=oldString.","title":"3.7 Strategy"},{"content":"State(状态模式)的定义 不同的状态,不同的行为;或者说,每个状态有着相应的行为.\n何时使用? State模式在实际使用中比较多,适合\u0026quot;状态的切换\u0026quot;.因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.\n不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.\n是否使用? 在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度.\n这里要阐述的是\u0026quot;开关切换状态\u0026quot; 和\u0026quot; 一般的状态判断\u0026quot;是有一些区别的, \u0026quot; 一般的状态判断\u0026quot;也是有 if..elseif结构,例如:\nif (which==1) state=\u0026ldquo;hello\u0026rdquo;; else if (which==2) state=\u0026ldquo;hi\u0026rdquo;; else if (which==3) state=\u0026ldquo;bye\u0026rdquo;;\n这是一个 \u0026quot; 一般的状态判断\u0026quot;,state值的不同是根据which变量来决定的,which和state没有关系.如果改成:\nif (state.euqals(\u0026ldquo;bye\u0026rdquo;)) state=\u0026ldquo;hello\u0026rdquo;; else if (state.euqals(\u0026ldquo;hello\u0026rdquo;)) state=\u0026ldquo;hi\u0026rdquo;; else if (state.euqals(\u0026ldquo;hi\u0026rdquo;)) state=\u0026ldquo;bye\u0026rdquo;;\n这就是 \u0026ldquo;开关切换状态\u0026rdquo;,是将state的状态从\u0026quot;hello\u0026quot;切换到\u0026quot;hi\u0026quot;,再切换到\u0026quot;\u0026ldquo;bye\u0026rdquo;;在切换到\u0026quot;hello\u0026quot;,好象一个旋转开关,这种状态改变就可以使用State模式了.\n如果单纯有上面一种将\u0026quot;hello\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;hi\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;bye\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;hello\u0026quot;这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.\n请看下例:\npublic class Context{ private Color state=null; public void push(){ //如果当前red状态 就切换到blue if (state==Color.red) state=Color.blue; //如果当前blue状态 就切换到green else if (state==Color.blue) state=Color.green; //如果当前black状态 就切换到red else if (state==Color.black) state=Color.red; //如果当前green状态 就切换到black else if (state==Color.green) state=Color.black; Sample sample=new Sample(state); sample.operate(); } public void pull(){ //与push状态切换正好相反 if (state==Color.green) state=Color.blue; else if (state==Color.black) state=Color.green; else if (state==Color.blue) state=Color.red; else if (state==Color.red) state=Color.black; Sample2 sample2=new Sample2(state); sample2.operate(); } } 在上例中,我们有两个动作push推和pull拉,这两个开关动作,改变了Context颜色,至此,我们就需要使用State模式优化它.\n另外注意:但就上例,state的变化,只是简单的颜色赋值,这个具体行为是很简单的,State适合巨大的具体行为,因此在,就本例,实际使用中也不一定非要使用State模式,这会增加子类的数目,简单的变复杂.\n例如: 银行帐户, 经常会在Open 状态和Close状态间转换.\n例如: 经典的TcpConnection, Tcp的状态有创建 侦听 关闭三个,并且反复转换,其创建 侦听 关闭的具体行为不是简单一两句就能完成的,适合使用State\n例如:信箱POP帐号, 会有四种状态, start HaveUsername Authorized quit,每个状态对应的行为应该是比较大的.适合使用State\n例如:在工具箱挑选不同工具,可以看成在不同工具中切换,适合使用State.如 具体绘图程序,用户可以选择不同工具绘制方框 直线 曲线,这种状态切换可以使用State.\n如何使用 State需要两种类型实体参与:\nstate manager 状态管理器 ,就是开关 ,如上面例子的Context实际就是一个state manager, 在state manager中有对状态的切换动作. 用抽象类或接口实现的父类,,不同状态就是继承这个父类的不同子类. 以上面的Context为例.我们要修改它,建立两个类型的实体.\n第一步: 首先建立一个父类: public abstract class State{ public abstract void handlepush(Context c); public abstract void handlepull(Context c); public abstract void getcolor(); } 父类中的方法要对应state manager中的开关行为,在state manager中 本例就是Context中,有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作:handlepush() handlepull(); 同时还需要一个获取push或pull结果的方法getcolor()\n下面是具体子类的实现:\npublic class BlueState extends State{ public void handlepush(Context c){ //根据push方法\u0026#34;如果是blue状态的切换到green\u0026#34; ; c.setState(new GreenState()); } public void handlepull(Context c){ //根据pull方法\u0026#34;如果是blue状态的切换到red\u0026#34; ; c.setState(new RedState()); } public abstract void getcolor(){ return (Color.blue)} } 同样 其他状态的子类实现如blue一样.\n第二步: 要重新改写State manager 也就是本例的Context: public class Context{ private Sate state=null; //我们将原来的 Color state 改成了新建的State state; //setState是用来改变state的状态 使用setState实现状态的切换 pulic void setState(State state){ this.state=state; } public void push(){ //状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心 state.handlepush(this); //因为sample要使用state中的一个切换结果,使用getColor() Sample sample=new Sample(state.getColor()); sample.operate(); } public void pull(){ state.handlepull(this); Sample2 sample2=new Sample2(state.getColor()); sample2.operate(); } } 至此,我们也就实现了State的refactorying过程.\n以上只是相当简单的一个实例,在实际应用中,handlepush或handelpull的处理是复杂的.\n状态模式优点： （1） 封装转换过程，也就是转换规则 （2） 枚举可能的状态，因此，需要事先确定状态种类。\n状态模式可以允许客户端改变状态的转换行为，而状态机则是能够自动改变状态，状态机是一个比较独立的而且复杂的机制，具体可参考一个状态机开源项目：http://sourceforge.net/projects/smframework/\n状态模式在工作流或游戏等各种系统中有大量使用，甚至是这些系统的核心功能设计，例如政府OA中，一个批文的状态有多种：未办；正在办理；正在批示；正在审核；已经完成等各种状态，使用状态机可以封装这个状态的变化规则，从而达到扩充状态时，不必涉及到状态的使用者。\n在网络游戏中，一个游戏活动存在开始；开玩；正在玩；输赢等各种状态，使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面，使用状态模式可以对整个游戏架构功能实现起到决定的主导作用。\n状态模式实质 使用状态模式前，客户端外界需要介入改变状态，而状态改变的实现是琐碎或复杂的。\n使用状态模式后，客户端外界可以直接使用事件Event实现，根本不必关心该事件导致如何状态变化，这些是由状态机等内部实现。\n这是一种Event-condition-State，状态模式封装了condition-State部分。\n每个状态形成一个子类，每个状态只关心它的下一个可能状态，从而无形中形成了状态转换的规则。如果新的状态加入，只涉及它的前一个状态修改和定义。\n状态转换有几个方法实现：一个在每个状态实现next()，指定下一个状态；还有一种方法，设定一个StateOwner，在StateOwner设定stateEnter状态进入和stateExit状态退出行为。\n状态从一个方面说明了流程，流程是随时间而改变，状态是截取流程某个时间片。\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.6-state/","summary":"State(状态模式)的定义 不同的状态,不同的行为;或者说,每个状态有着相应的行为.\n何时使用? State模式在实际使用中比较多,适合\u0026quot;状态的切换\u0026quot;.因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.\n不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.\n是否使用? 在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度.\n这里要阐述的是\u0026quot;开关切换状态\u0026quot; 和\u0026quot; 一般的状态判断\u0026quot;是有一些区别的, \u0026quot; 一般的状态判断\u0026quot;也是有 if..elseif结构,例如:\nif (which==1) state=\u0026ldquo;hello\u0026rdquo;; else if (which==2) state=\u0026ldquo;hi\u0026rdquo;; else if (which==3) state=\u0026ldquo;bye\u0026rdquo;;\n这是一个 \u0026quot; 一般的状态判断\u0026quot;,state值的不同是根据which变量来决定的,which和state没有关系.如果改成:\nif (state.euqals(\u0026ldquo;bye\u0026rdquo;)) state=\u0026ldquo;hello\u0026rdquo;; else if (state.euqals(\u0026ldquo;hello\u0026rdquo;)) state=\u0026ldquo;hi\u0026rdquo;; else if (state.euqals(\u0026ldquo;hi\u0026rdquo;)) state=\u0026ldquo;bye\u0026rdquo;;\n这就是 \u0026ldquo;开关切换状态\u0026rdquo;,是将state的状态从\u0026quot;hello\u0026quot;切换到\u0026quot;hi\u0026quot;,再切换到\u0026quot;\u0026ldquo;bye\u0026rdquo;;在切换到\u0026quot;hello\u0026quot;,好象一个旋转开关,这种状态改变就可以使用State模式了.\n如果单纯有上面一种将\u0026quot;hello\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;hi\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;bye\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;hello\u0026quot;这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.\n请看下例:\npublic class Context{ private Color state=null; public void push(){ //如果当前red状态 就切换到blue if (state==Color.red) state=Color.blue; //如果当前blue状态 就切换到green else if (state==Color.blue) state=Color.green; //如果当前black状态 就切换到red else if (state==Color.","title":"3.6 State"},{"content":"Command模式是最让我疑惑的一个模式,我在阅读了很多代码后,才感觉隐约掌握其大概原理,我认为理解设计模式最主要是掌握起原理构造,这样才对自己实际编程有指导作用.Command模式实际上不是个很具体,规定很多的模式,正是这个灵活性,让人有些confuse.\nCommand命令模式 n 将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。\n这是一种两台机器之间通讯联系性质的模式，类似传统过程语 言的 CallBack功能。\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n优点 解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。\n不少Command模式的代码都是针对图形界面的,它实际就是菜单命令,我们在一个下拉菜单选择一个命令时,然后会执行一些动作.\n将这些命令封装成在一个类中,然后用户(调用者)再对这个类进行操作,这就是Command模式,换句话说,本来用户(调用者)是直接调用这些命令的,如菜单上打开文档(调用者),就直接指向打开文档的代码,使用Command模式,就是在这两者之间增加一个中间者,将这种直接关系拗断,同时两者之间都隔离,基本没有关系了.\n显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式, 从Command模式,我也发现设计模式一个\u0026quot;通病\u0026quot;:好象喜欢将简单的问题复杂化, 喜欢在不同类中增加第三者,当然这样做有利于代码的健壮性 可维护性 还有复用性.\n如何使用? 具体的Command模式代码各式各样,因为如何封装命令,不同系统,有不同的做法.下面事例是将命令封装在一个Collection的List中,任何对象一旦加入List中,实际上装入了一个封闭的黑盒中,对象的特性消失了,只有取出时,才有可能模糊的分辨出:典型的Command模式需要有一个接口.接口中有一个统一的方法,这就是\u0026quot;将命令/请求封装为对象\u0026quot;:\npublic interface Command { public abstract void execute ( ); } 具体不同命令/请求代码是实现接口Command,下面有三个具体命令\npublic class Engineer implements Command { public void execute( ) { //do Engineer\u0026#39;s command } } public class Programmer implements Command { public void execute( ) { //do programmer\u0026#39;s command } } public class Politician implements Command { public void execute( ) { //do Politician\u0026#39;s command } } 按照通常做法,我们就可以直接调用这三个Command,但是使用Command模式,我们要将他们封装起来,扔到黑盒子List里去:\npublic class producer{ public static List produceRequests() { List queue = new ArrayList(); queue.add( new DomesticEngineer() ); queue.add( new Politician() ); queue.add( new Programmer() ); return queue; } } 这三个命令进入List中后,已经失去了其外表特征,以后再取出,也可能无法分辨出谁是Engineer 谁是Programmer了,看下面客户端如何调用Command模式:\npublic class TestCommand { public static void main(String[] args) { List queue = Producer.produceRequests(); for (Iterator it = queue.iterator(); it.hasNext(); ) //客户端直接调用execute方法，无需知道被调用者的其它更多类的方法名。 ((Command)it.next()).execute(); } } 由此可见,调用者基本只和接口打交道,不合具体实现交互,这也体现了一个原则,面向接口编程,这样,以后增加第四个具体命令时,就不必修改调用者TestCommand中的代码了.\n理解了上面的代码的核心原理,在使用中,就应该各人有自己方法了,特别是在如何分离调用者和具体命令上,有很多实现方法,上面的代码是使用\u0026quot;从List过一遍\u0026quot;的做法.这种做法只是为了演示.\n使用Command模式的一个好理由还因为它能实现Undo功能.每个具体命令都可以记住它刚刚执行的动作,并且在需要时恢复.\nCommand模式在界面设计中应用广泛.Java的Swing中菜单命令都是使用Command模式,由于Java在界面设计的性能上还有欠缺,因此界面设计具体代码我们就不讨论,网络上有很多这样的示例.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.5-command/","summary":"Command模式是最让我疑惑的一个模式,我在阅读了很多代码后,才感觉隐约掌握其大概原理,我认为理解设计模式最主要是掌握起原理构造,这样才对自己实际编程有指导作用.Command模式实际上不是个很具体,规定很多的模式,正是这个灵活性,让人有些confuse.\nCommand命令模式 n 将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。\n这是一种两台机器之间通讯联系性质的模式，类似传统过程语 言的 CallBack功能。\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n优点 解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。\n不少Command模式的代码都是针对图形界面的,它实际就是菜单命令,我们在一个下拉菜单选择一个命令时,然后会执行一些动作.\n将这些命令封装成在一个类中,然后用户(调用者)再对这个类进行操作,这就是Command模式,换句话说,本来用户(调用者)是直接调用这些命令的,如菜单上打开文档(调用者),就直接指向打开文档的代码,使用Command模式,就是在这两者之间增加一个中间者,将这种直接关系拗断,同时两者之间都隔离,基本没有关系了.\n显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式, 从Command模式,我也发现设计模式一个\u0026quot;通病\u0026quot;:好象喜欢将简单的问题复杂化, 喜欢在不同类中增加第三者,当然这样做有利于代码的健壮性 可维护性 还有复用性.\n如何使用? 具体的Command模式代码各式各样,因为如何封装命令,不同系统,有不同的做法.下面事例是将命令封装在一个Collection的List中,任何对象一旦加入List中,实际上装入了一个封闭的黑盒中,对象的特性消失了,只有取出时,才有可能模糊的分辨出:典型的Command模式需要有一个接口.接口中有一个统一的方法,这就是\u0026quot;将命令/请求封装为对象\u0026quot;:\npublic interface Command { public abstract void execute ( ); } 具体不同命令/请求代码是实现接口Command,下面有三个具体命令\npublic class Engineer implements Command { public void execute( ) { //do Engineer\u0026#39;s command } } public class Programmer implements Command { public void execute( ) { //do programmer\u0026#39;s command } } public class Politician implements Command { public void execute( ) { //do Politician\u0026#39;s command } } 按照通常做法,我们就可以直接调用这三个Command,但是使用Command模式,我们要将他们封装起来,扔到黑盒子List里去:","title":"3.5 Command"},{"content":"Chain of Responsibility (职责链模式) Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。\n如何使用? 虽然这一段是如何使用CoR,但是也是演示什么是CoR.\n有一个Handler接口:\npublic interface Handler{ public void handleRequest(); } 这是一个处理request的事例， 如果有多种request,比如 请求帮助 请求打印 或请求格式化：\n最先想到的解决方案是：在接口中增加多个请求：\npublic interface Handler{ public void handleHelp(); public void handlePrint(); public void handleFormat(); } 具体是一段实现接口Handler代码：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleHelp(){ //具体处理请求Help的代码 ... } public void handlePrint(){ //如果是print 转去处理Print successor.handlePrint(); } public void handleFormat(){ //如果是Format 转去处理format successor.handleFormat(); } } 一共有三个这样的具体实现类，上面是处理help,还有处理Print 处理Format这大概是我们最常用的编程思路。\n虽然思路简单明了，但是有一个扩展问题，如果我们需要再增加一个请求request种类,需要修改接口及其每一个实现。\n第二方案:将每种request都变成一个接口，因此我们有以下代码 ：\npublic interface HelpHandler{ public void handleHelp(); } public interface PrintHandler{ public void handlePrint(); } public interface FormatHandler{ public void handleFormat(); } public class ConcreteHandler implements HelpHandler,PrintHandler,FormatHandlet{ private HelpHandler helpSuccessor; private PrintHandler printSuccessor; private FormatHandler formatSuccessor; public ConcreteHandler(HelpHandler helpSuccessor,PrintHandler printSuccessor,FormatHandler formatSuccessor) { this.helpSuccessor=helpSuccessor; this.printSuccessor=printSuccessor; this.formatSuccessor=formatSuccessor; } public void handleHelp(){ ....... } public void handlePrint(){this.printSuccessor=printSuccessor;} public void handleFormat(){this.formatSuccessor=formatSuccessor;} } 这个办法在增加新的请求request情况下，只是节省了接口的修改量，接口实现ConcreteHandler还需要修改。而且代码显然不简单美丽。\n解决方案3: 在Handler接口中只使用一个参数化方法：\npublic interface Handler{ public void handleRequest(String request); } 那么Handler实现代码如下：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleRequest(String request){ if (request.equals(\u0026#34;Help\u0026#34;)){ //这里是处理Help的具体代码 }else //传递到下一个 successor.handle(request); } } } 这里先假设request是String类型，如果不是怎么办？当然我们可以创建一个专门类Request\n最后解决方案:接口Handler的代码如下：\npublic interface Handler{ public void handleRequest(Request request); } Request类的定义:\npublic class Request{ private String type; public Request(String type){this.type=type;} public String getType(){return type;} public void execute(){ //request真正具体行为代码 } } 那么Handler实现代码如下：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleRequest(Request request){ if (request instanceof HelpRequest){ //这里是处理Help的具体代码 }else if (request instanceof PrintRequst){ request.execute(); }else //传递到下一个 successor.handle(request); } } } 这个解决方案就是CoR, 在一个链上,都有相应职责的类,因此叫Chain of Responsibility.\nCoR的优点 因为无法预知来自外界（客户端）的请求是属于哪种类型，每个类如果碰到它不能处理的请求只要放弃就可以。\n缺点是效率低，因为一个请求的完成可能要遍历到最后才可能完成，当然也可以用树的概念优化。 在Java AWT1.0中，对于鼠标按键事情的处理就是使用CoR,到Java.1.1以后，就使用Observer代替CoR\n扩展性差，因为在CoR中，一定要有一个统一的接口Handler.局限性就在这里。\n与Command模式区别 Command 模式需要事先协商客户端和服务器端的调用关系，比如 1 代表 start 2 代表 move 等，这些 都是封装在 request 中，到达服务器端再分解。\nCoR 模式就无需这种事先约定，服务器端可以使用 CoR 模式进行客户端请求的猜测，一个个猜测 试验。\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.4-chain-of-responsibility/","summary":"Chain of Responsibility (职责链模式) Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。\n如何使用? 虽然这一段是如何使用CoR,但是也是演示什么是CoR.\n有一个Handler接口:\npublic interface Handler{ public void handleRequest(); } 这是一个处理request的事例， 如果有多种request,比如 请求帮助 请求打印 或请求格式化：\n最先想到的解决方案是：在接口中增加多个请求：\npublic interface Handler{ public void handleHelp(); public void handlePrint(); public void handleFormat(); } 具体是一段实现接口Handler代码：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleHelp(){ //具体处理请求Help的代码 ... } public void handlePrint(){ //如果是print 转去处理Print successor.handlePrint(); } public void handleFormat(){ //如果是Format 转去处理format successor.","title":"3.4 Chain of Responsibility"},{"content":"Observer(观察者模式)定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n链接\n具体讲解\nJava深入到一定程度,就不可避免的碰到设计模式(design pattern)这一概念,了解设计模式,将使自己对java中的接口或抽象类应用有更深的理解.设计模式在java的中型系统中应用广泛,遵循一定的编程模式,才能使自己的代码便于理解,易于交流,Observer(观察者)模式是比较常用的一个模式,尤其在界面设计中应用广泛,而本站所关注的是Java在电子商务系统中应用,因此想从电子商务实例中分析Observer的应用.\n虽然网上商店形式多样,每个站点有自己的特色,但也有其一般的共性,单就\u0026quot;商品的变化,以便及时通知订户\u0026quot;这一点,是很多网上商店共有的模式,这一模式类似Observer patern观察者模式.\n具体的说,如果网上商店中商品在名称 价格等方面有变化,如果系统能自动通知会员,将是网上商店区别传统商店的一大特色.这就需要在商品product中加入Observer这样角色,以便product细节发生变化时,Observer能自动观察到这种变化,并能进行及时的update或notify动作.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.3-observer/","summary":"Observer(观察者模式)定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n链接\n具体讲解\nJava深入到一定程度,就不可避免的碰到设计模式(design pattern)这一概念,了解设计模式,将使自己对java中的接口或抽象类应用有更深的理解.设计模式在java的中型系统中应用广泛,遵循一定的编程模式,才能使自己的代码便于理解,易于交流,Observer(观察者)模式是比较常用的一个模式,尤其在界面设计中应用广泛,而本站所关注的是Java在电子商务系统中应用,因此想从电子商务实例中分析Observer的应用.\n虽然网上商店形式多样,每个站点有自己的特色,但也有其一般的共性,单就\u0026quot;商品的变化,以便及时通知订户\u0026quot;这一点,是很多网上商店共有的模式,这一模式类似Observer patern观察者模式.\n具体的说,如果网上商店中商品在名称 价格等方面有变化,如果系统能自动通知会员,将是网上商店区别传统商店的一大特色.这就需要在商品product中加入Observer这样角色,以便product细节发生变化时,Observer能自动观察到这种变化,并能进行及时的update或notify动作.","title":"3.3 Observer"},{"content":"Memento(备忘录模式)定义 memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.\nMemento模式相对也比较好理解,我们看下列代码:\npublic class Originator { public int number; public File file = null; public Originator(){} // 创建一个Memento public Memento getMemento(){ return new Memento(this); } // 恢复到原始值 public void setMemento(Memento m){ number = m.number; file = m.file; } } 我们再看看Memento类:\nprivate class Memento implements java.io.Serializable{ public int number; public File file = null; public Memento( Originator o){ number = o.number; file = o.file; } } 可见 Memento中保存了Originator中的number和file的值. 通过调用Originator中number和file值改变的话,通过调用setMemento()方法可以恢复.\nMemento模式的缺点是耗费大,如果内部状态很多,再保存一份,无意要浪费大量内存.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.2-memento/","summary":"Memento(备忘录模式)定义 memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.\nMemento模式相对也比较好理解,我们看下列代码:\npublic class Originator { public int number; public File file = null; public Originator(){} // 创建一个Memento public Memento getMemento(){ return new Memento(this); } // 恢复到原始值 public void setMemento(Memento m){ number = m.number; file = m.file; } } 我们再看看Memento类:\nprivate class Memento implements java.io.Serializable{ public int number; public File file = null; public Memento( Originator o){ number = o.number; file = o.file; } } 可见 Memento中保存了Originator中的number和file的值. 通过调用Originator中number和file值改变的话,通过调用setMemento()方法可以恢复.\nMemento模式的缺点是耗费大,如果内部状态很多,再保存一份,无意要浪费大量内存.","title":"3.2 Memento"},{"content":"Template(模板模式)定义 定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.\n使用Java的抽象类时，就经常会使用到Template模式,因此Template模式使用很普遍.而且很容易理解和使用。\npublic abstract class Benchmark { /** * 下面操作是我们希望在子类中完成 */ public abstract void benchmark(); /** * 重复执行benchmark次数 */ public final long repeat (int count) { if (count \u0026lt;= 0) return 0; else { long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; count; i++) benchmark(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; } } } 在上例中,我们希望重复执行benchmark()操作,但是对benchmark()的具体内容没有说明,而是延迟到其子类中描述:\npublic class MethodBenchmark extends Benchmark { /** * 真正定义benchmark内容 */ public void benchmark() { for (int i = 0; i \u0026lt; Integer.MAX_VALUE; i++){ System.out.printtln(\u0026#34;i=\u0026#34;+i);　} } } 至此,Template模式已经完成,是不是很简单?\n我们称repeat方法为模板方法， 它其中的benchmark()实现被延迟到子类MethodBenchmark中实现了，\n看看如何使用:\nBenchmark operation = new MethodBenchmark(); long duration = operation.repeat(Integer.parseInt(args[0].trim())); System.out.println(\u0026#34;The operation took \u0026#34; + duration + \u0026#34; milliseconds\u0026#34;); 也许你以前还疑惑抽象类有什么用,现在你应该彻底明白了吧? 至于这样做的好处,很显然啊,扩展性强,以后Benchmark内容变化,我只要再做一个继承子类就可以,不必修改其他应用代码.\n","permalink":"https://blog.chalme.top/posts/design-patterns/3.1-template/","summary":"Template(模板模式)定义 定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.\n使用Java的抽象类时，就经常会使用到Template模式,因此Template模式使用很普遍.而且很容易理解和使用。\npublic abstract class Benchmark { /** * 下面操作是我们希望在子类中完成 */ public abstract void benchmark(); /** * 重复执行benchmark次数 */ public final long repeat (int count) { if (count \u0026lt;= 0) return 0; else { long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; count; i++) benchmark(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; } } } 在上例中,我们希望重复执行benchmark()操作,但是对benchmark()的具体内容没有说明,而是延迟到其子类中描述:\npublic class MethodBenchmark extends Benchmark { /** * 真正定义benchmark内容 */ public void benchmark() { for (int i = 0; i \u0026lt; Integer.","title":"3.1 Template"},{"content":"Flyweight(享元模式)定义 避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).\n重点 本质factory的实现，巧妙的设计。 hashtable 或 hashmap 来判断对象是否存在 为什么使用? 面向对象语言的原则就是一切都是对象,但是如果真正使用起来,有时对象数可能显得很庞大,比如,字处理软件,如果以每个文字都作为一个对象,几千个字,对象数就是几千,无疑耗费内存,那么我们还是要\u0026quot;求同存异\u0026quot;,找出这些对象群的共同点,设计一个元类,封装可以被共享的类,另外,还有一些特性是取决于应用(context),是不可共享的,这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分.\n说白点,就是先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象.\nFlyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.\n如何使用?\n我们先从Flyweight抽象接口开始:\npublic interface Flyweight { public void operation( ExtrinsicState state ); } //用于本模式的抽象数据类型(自行设计) public interface ExtrinsicState { }\n下面是接口的具体实现(ConcreteFlyweight) ,并为内部状态增加内存空间, ConcreteFlyweight必须是可共享的,它保存的任何状态都必须是内部(intrinsic),也就是说,ConcreteFlyweight必须和它的应用环境场合无关.\npublic class ConcreteFlyweight implements Flyweight { private IntrinsicState state; public void operation( ExtrinsicState state ) { //具体操作 } } 当然,并不是所有的Flyweight具体实现子类都需要被共享的,所以还有另外一种不共享的ConcreteFlyweight:\npublic class UnsharedConcreteFlyweight implements Flyweight { public void operation( ExtrinsicState state ) { } } Flyweight factory负责维护一个Flyweight池(存放内部状态),当客户端请求一个共享Flyweight时,这个factory首先搜索池中是否已经有可适用的,如果有,factory只是简单返回送出这个对象,否则,创建一个新的对象,加入到池中,再返回送出这个对象.池\npublic class FlyweightFactory { //Flyweight pool private Hashtable flyweights = new Hashtable(); public Flyweight getFlyweight( Object key ) { Flyweight flyweight = (Flyweight) flyweights.get(key); if( flyweight == null ) { //产生新的ConcreteFlyweight flyweight = new ConcreteFlyweight(); flyweights.put( key, flyweight ); } return flyweight; } } 至此,Flyweight模式的基本框架已经就绪,我们看看如何调用:\nFlyweightFactory factory = new FlyweightFactory(); Flyweight fly1 = factory.getFlyweight( \u0026ldquo;Fred\u0026rdquo; ); Flyweight fly2 = factory.getFlyweight( \u0026ldquo;Wilma\u0026rdquo; ); \u0026hellip;\u0026hellip;\n从调用上看,好象是个纯粹的Factory使用,但奥妙就在于Factory的内部设计上.\nFlyweight模式在XML等数据源中应用 我们上面已经提到,当大量从数据源中读取字符串,其中肯定有重复的,那么我们使用Flyweight模式可以提高效率,以唱片CD为例,在一个XML文件中,存放了多个CD的资料.\n每个CD有三个字段: 1.出片日期(year) 2.歌唱者姓名等信息(artist) 3.唱片曲目 (title)\n其中,歌唱者姓名有可能重复,也就是说,可能有同一个演唱者的多个不同时期 不同曲目的CD.我们将\u0026quot;歌唱者姓名\u0026quot;作为可共享的ConcreteFlyweight.其他两个字段作为UnsharedConcreteFlyweight.\n首先看看数据源XML文件的内容:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;collection\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Another Green World\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1978\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Eno, Brian\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Greatest Hits\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1950\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Holiday, Billie\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Taking Tiger Mountain (by strategy)\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1977\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Eno, Brian\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; ....... \u0026lt;/collection\u0026gt; 虽然上面举例CD只有3张,CD可看成是大量重复的小类,因为其中成分只有三个字段,而且有重复的(歌唱者姓名).\nCD就是类似上面接口 Flyweight:\npublic class CD { private String title; private int year; private Artist artist; public String getTitle() {　return title;　} public int getYear() {　return year;　} public Artist getArtist() {　return artist;　} public void setTitle(String t){　title = t;} public void setYear(int y){year = y;} public void setArtist(Artist a){artist = a;} } 将\u0026quot;歌唱者姓名\u0026quot;作为可共享的ConcreteFlyweight:\npublic class Artist { //内部状态 private String name; // note that Artist is immutable. String getName(){return name;} Artist(String n){ name = n; } } 再看看Flyweight factory,专门用来制造上面的可共享的ConcreteFlyweight:Artist\npublic class ArtistFactory { Hashtable pool = new Hashtable(); Artist getArtist(String key){ Artist result; result = (Artist)pool.get(key); ////产生新的Artist if(result == null) { result = new Artist(key); pool.put(key,result); } return result; } } 当你有几千张甚至更多CD时,Flyweight模式将节省更多空间,共享的flyweight越多,空间节省也就越大.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.7-flyweight/","summary":"Flyweight(享元模式)定义 避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).\n重点 本质factory的实现，巧妙的设计。 hashtable 或 hashmap 来判断对象是否存在 为什么使用? 面向对象语言的原则就是一切都是对象,但是如果真正使用起来,有时对象数可能显得很庞大,比如,字处理软件,如果以每个文字都作为一个对象,几千个字,对象数就是几千,无疑耗费内存,那么我们还是要\u0026quot;求同存异\u0026quot;,找出这些对象群的共同点,设计一个元类,封装可以被共享的类,另外,还有一些特性是取决于应用(context),是不可共享的,这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分.\n说白点,就是先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象.\nFlyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.\n如何使用?\n我们先从Flyweight抽象接口开始:\npublic interface Flyweight { public void operation( ExtrinsicState state ); } //用于本模式的抽象数据类型(自行设计) public interface ExtrinsicState { }\n下面是接口的具体实现(ConcreteFlyweight) ,并为内部状态增加内存空间, ConcreteFlyweight必须是可共享的,它保存的任何状态都必须是内部(intrinsic),也就是说,ConcreteFlyweight必须和它的应用环境场合无关.\npublic class ConcreteFlyweight implements Flyweight { private IntrinsicState state; public void operation( ExtrinsicState state ) { //具体操作 } } 当然,并不是所有的Flyweight具体实现子类都需要被共享的,所以还有另外一种不共享的ConcreteFlyweight:\npublic class UnsharedConcreteFlyweight implements Flyweight { public void operation( ExtrinsicState state ) { } } Flyweight factory负责维护一个Flyweight池(存放内部状态),当客户端请求一个共享Flyweight时,这个factory首先搜索池中是否已经有可适用的,如果有,factory只是简单返回送出这个对象,否则,创建一个新的对象,加入到池中,再返回送出这个对象.","title":"2.7 Flyweight"},{"content":"Bridge(桥接模式)定义 将抽象和行为划分开来,各自独立,但能动态的结合。\n在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。\n重点 单例模型的使用和 调用 为什么使用? 不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。\n如果一个抽象类或接口有多个具体实现(子类、concrete subclass),这些子类之间关系可能有以下两种情况:\n这多个子类之间概念是并列的,如前面举例,打桩,有两个concrete class:方形桩和圆形桩;这两个形状上的桩是并列的,没有概念上的重复。\n这多个子类之中有内容概念上重叠.那么需要我们把抽象共同部分和行为共同部分各自独立开来,原来是准备放在一个接口里,现在需要设计两个接口：抽象接口和行为接口，分别放置抽象和行为.\n例如,一杯咖啡为例,子类实现类为四个：中杯加奶、大杯加奶、 中杯不加奶、大杯不加奶。\n但是，我们注意到：上面四个子类中有概念重叠，可从另外一个角度进行考虑，这四个类实际是两个角色的组合：抽象 和行为，其中抽象为：中杯和大杯；行为为：加奶 不加奶（如加橙汁 加苹果汁）.\n实现四个子类在抽象和行为之间发生了固定的绑定关系，如果以后动态增加加葡萄汁的行为，就必须再增加两个类：中杯加葡萄汁和大杯加葡萄汁。显然混乱,扩展性极差。\n那我们从分离抽象和行为的角度，使用Bridge模式来实现。\n如何实现? 以上面提到的咖啡 为例. 我们原来打算只设计一个接口(抽象类),使用Bridge模式后,我们需要将抽象和行为分开,加奶和不加奶属于行为,我们将它们抽象成一个专门的行为接口.\n先看看抽象部分的接口代码:\npublic abstract class Coffee { CoffeeImp coffeeImp; public void setCoffeeImp() { this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp(); } public CoffeeImp getCoffeeImp() {return this.CoffeeImp;} public abstract void pourCoffee(); } 其中CoffeeImp 是加不加奶的行为接口,看其代码如下:\npublic abstract class CoffeeImp { public abstract void pourCoffeeImp(); } 现在我们有了两个抽象类,下面我们分别对其进行继承,实现concrete class:\n//中杯 public class MediumCoffee extends Coffee { public MediumCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.getCoffeeImp(); //我们以重复次数来说明是冲中杯还是大杯 ,重复2次是中杯 for (int i = 0; i \u0026lt; 2; i++) { coffeeImp.pourCoffeeImp(); } } } //大杯 public class SuperSizeCoffee extends Coffee { public SuperSizeCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.getCoffeeImp(); //我们以重复次数来说明是冲中杯还是大杯 ,重复5次是大杯 for (int i = 0; i \u0026lt; 5; i++) { coffeeImp.pourCoffeeImp(); } } } 上面分别是中杯和大杯的具体实现.下面再对行为CoffeeImp进行继承:\n//加奶 public class MilkCoffeeImp extends CoffeeImp { MilkCoffeeImp() {} public void pourCoffeeImp() { System.out.println(\u0026#34;加了美味的牛奶\u0026#34;); } } //不加奶 public class FragrantCoffeeImp extends CoffeeImp { FragrantCoffeeImp() {} public void pourCoffeeImp() { System.out.println(\u0026#34;什么也没加,清香\u0026#34;); } } Bridge模式的基本框架我们已经搭好了,别忘记定义中还有一句:动态结合,我们现在可以喝到至少四种咖啡: 1.中杯加奶 2.中杯不加奶 3.大杯加奶 4.大杯不加奶\n看看是如何动态结合的,在使用之前,我们做个准备工作,设计一个单态类(Singleton)用来hold当前的CoffeeImp:\npublic class CoffeeImpSingleton { private static CoffeeImp coffeeImp; public CoffeeImpSingleton(CoffeeImp coffeeImpIn) {this.coffeeImp = coffeeImpIn;} public static CoffeeImp getTheCoffeeImp() { return coffeeImp; } } 看看中杯加奶 和大杯加奶 是怎么出来的:\n//拿出牛奶 CoffeeImpSingleton coffeeImpSingleton = new CoffeeImpSingleton(new MilkCoffeeImp()); //中杯加奶 MediumCoffee mediumCoffee = new MediumCoffee(); mediumCoffee.pourCoffee(); //大杯加奶 SuperSizeCoffee superSizeCoffee = new SuperSizeCoffee(); superSizeCoffee.pourCoffee(); 注意: Bridge模式的执行类如CoffeeImp和Coffee是一对一的关系, 正确创建CoffeeImp是该模式的关键。\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.6-bridge/","summary":"Bridge(桥接模式)定义 将抽象和行为划分开来,各自独立,但能动态的结合。\n在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。\n重点 单例模型的使用和 调用 为什么使用? 不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。\n如果一个抽象类或接口有多个具体实现(子类、concrete subclass),这些子类之间关系可能有以下两种情况:\n这多个子类之间概念是并列的,如前面举例,打桩,有两个concrete class:方形桩和圆形桩;这两个形状上的桩是并列的,没有概念上的重复。\n这多个子类之中有内容概念上重叠.那么需要我们把抽象共同部分和行为共同部分各自独立开来,原来是准备放在一个接口里,现在需要设计两个接口：抽象接口和行为接口，分别放置抽象和行为.\n例如,一杯咖啡为例,子类实现类为四个：中杯加奶、大杯加奶、 中杯不加奶、大杯不加奶。\n但是，我们注意到：上面四个子类中有概念重叠，可从另外一个角度进行考虑，这四个类实际是两个角色的组合：抽象 和行为，其中抽象为：中杯和大杯；行为为：加奶 不加奶（如加橙汁 加苹果汁）.\n实现四个子类在抽象和行为之间发生了固定的绑定关系，如果以后动态增加加葡萄汁的行为，就必须再增加两个类：中杯加葡萄汁和大杯加葡萄汁。显然混乱,扩展性极差。\n那我们从分离抽象和行为的角度，使用Bridge模式来实现。\n如何实现? 以上面提到的咖啡 为例. 我们原来打算只设计一个接口(抽象类),使用Bridge模式后,我们需要将抽象和行为分开,加奶和不加奶属于行为,我们将它们抽象成一个专门的行为接口.\n先看看抽象部分的接口代码:\npublic abstract class Coffee { CoffeeImp coffeeImp; public void setCoffeeImp() { this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp(); } public CoffeeImp getCoffeeImp() {return this.CoffeeImp;} public abstract void pourCoffee(); } 其中CoffeeImp 是加不加奶的行为接口,看其代码如下:\npublic abstract class CoffeeImp { public abstract void pourCoffeeImp(); } 现在我们有了两个抽象类,下面我们分别对其进行继承,实现concrete class:\n//中杯 public class MediumCoffee extends Coffee { public MediumCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.","title":"2.6 Bridge"},{"content":"Composite(组合模式)定义 将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.\nComposite比较容易理解，想到Composite就应该想到树形结构图。组合体内这些对象都有共同接口,当组合体一个对象的方法被调用执行时，Composite将遍历(Iterator)整个树形结构,寻找同样包含这个方法的对象并实现调用执行。可以用牵一动百来形容。\n所以Composite模式使用到Iterator模式，和Chain of Responsibility模式类似。\n本质 定义 interface 或 abstract class\n核心 在class(继承或实现) 中使用了 arraylist . 可以在其中添加 其他 对象（继承同一class）\nComposite好处 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。 更容易在组合体内加入对象部件. 客户端不必因为加入了新的对象部件而更改代码。 如何使用Composite 首先定义一个接口或抽象类，这是设计模式通用方式了，其他设计模式对接口内部定义限制不多，Composite却有个规定，那就是要在接口内部定义一个用于访问和管理Composite组合体的对象们（或称部件Component）.\n下面的代码是以抽象类定义，一般尽量用接口interface,\npublic abstract class Equipment { private String name; //实价 public abstract double netPrice(); //折扣价格 public abstract double discountPrice(); //增加部件方法　public boolean add(Equipment equipment) { return false; } //删除部件方法 public boolean remove(Equipment equipment) { return false; } //注意这里，这里就提供一种用于访问组合体类的部件方法。 public Iterator iter() { return null; } public Equipment(final String name) { this.name=name; } } 抽象类Equipment就是Component定义，代表着组合体类的对象们,Equipment中定义几个共同的方法。\npublic class Disk extends Equipment { public Disk(String name) { super(name); } //定义Disk实价为1 public double netPrice() { return 1.; } //定义了disk折扣价格是0.5 对折。 public double discountPrice() { return .5; } } Disk是组合体内的一个对象，或称一个部件，这个部件是个单独元素( Primitive)。 还有一种可能是，一个部件也是一个组合体，就是说这个部件下面还有\u0026rsquo;儿子\u0026rsquo;，这是树形结构中通常的情况，应该比较容易理解。现在我们先要定义这个组合体：\nabstract class CompositeEquipment extends Equipment { private int i=0; //定义一个Vector 用来存放\u0026#39;儿子\u0026#39; private Lsit equipment=new ArrayList(); public CompositeEquipment(String name) { super(name); } public boolean add(Equipment equipment) { this.equipment.add(equipment); return true; } public double netPrice() { double netPrice=0.; Iterator iter=equipment.iterator(); for(iter.hasNext()) netPrice+=((Equipment)iter.next()).netPrice(); return netPrice; } public double discountPrice() { double discountPrice=0.; Iterator iter=equipment.iterator(); for(iter.hasNext()) discountPrice+=((Equipment)iter.next()).discountPrice(); return discountPrice; } //注意这里，这里就提供用于访问自己组合体内的部件方法。 //上面dIsk 之所以没有，是因为Disk是个单独(Primitive)的元素. public Iterator iter() { return equipment.iterator() ; { //重载Iterator方法 public boolean hasNext() { return i\u0026lt;equipment.size(); } //重载Iterator方法 public Object next() { if(hasNext()) return equipment.elementAt(i++); else throw new NoSuchElementException(); } } 上面CompositeEquipment继承了Equipment,同时为自己里面的对象们提供了外部访问的方法,重载了Iterator,Iterator是Java的Collection的一个接口，是Iterator模式的实现.\n我们再看看CompositeEquipment的两个具体类:盘盒Chassis和箱子Cabinet，箱子里面可以放很多东西，如底板，电源盒，硬盘盒等；盘盒里面可以放一些小设备，如硬盘 软驱等。无疑这两个都是属于组合体性质的。\npublic class Chassis extends CompositeEquipment { public Chassis(String name) { super(name); } public double netPrice() { return 1.+super.netPrice(); } public double discountPrice() { return .5+super.discountPrice(); } } public class Cabinet extends CompositeEquipment { public Cabinet(String name) { super(name); } public double netPrice() { return 1.+super.netPrice(); } public double discountPrice() { return .5+super.discountPrice(); } } 至此我们完成了整个Composite模式的架构。\n我们可以看看客户端调用Composote代码:\nCabinet cabinet=new Cabinet(\u0026#34;Tower\u0026#34;); Chassis chassis=new Chassis(\u0026#34;PC Chassis\u0026#34;); //将PC Chassis装到Tower中 (将盘盒装到箱子里) cabinet.add(chassis); //将一个10GB的硬盘装到 PC Chassis (将硬盘装到盘盒里) chassis.add(new Disk(\u0026#34;10 GB\u0026#34;)); //调用 netPrice()方法; System.out.println(\u0026#34;netPrice=\u0026#34;+cabinet.netPrice()); System.out.println(\u0026#34;discountPrice=\u0026#34;+cabinet.discountPrice()); 上面调用的方法netPrice()或discountPrice()，实际上Composite使用Iterator遍历了整个树形结构,寻找同样包含这个方法的对象并实现调用执行.\nComposite是个很巧妙体现智慧的模式，在实际应用中，如果碰到树形结构，我们就可以尝试是否可以使用这个模式。\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.4-composite/","summary":"Composite(组合模式)定义 将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.\nComposite比较容易理解，想到Composite就应该想到树形结构图。组合体内这些对象都有共同接口,当组合体一个对象的方法被调用执行时，Composite将遍历(Iterator)整个树形结构,寻找同样包含这个方法的对象并实现调用执行。可以用牵一动百来形容。\n所以Composite模式使用到Iterator模式，和Chain of Responsibility模式类似。\n本质 定义 interface 或 abstract class\n核心 在class(继承或实现) 中使用了 arraylist . 可以在其中添加 其他 对象（继承同一class）\nComposite好处 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。 更容易在组合体内加入对象部件. 客户端不必因为加入了新的对象部件而更改代码。 如何使用Composite 首先定义一个接口或抽象类，这是设计模式通用方式了，其他设计模式对接口内部定义限制不多，Composite却有个规定，那就是要在接口内部定义一个用于访问和管理Composite组合体的对象们（或称部件Component）.\n下面的代码是以抽象类定义，一般尽量用接口interface,\npublic abstract class Equipment { private String name; //实价 public abstract double netPrice(); //折扣价格 public abstract double discountPrice(); //增加部件方法　public boolean add(Equipment equipment) { return false; } //删除部件方法 public boolean remove(Equipment equipment) { return false; } //注意这里，这里就提供一种用于访问组合体类的部件方法。 public Iterator iter() { return null; } public Equipment(final String name) { this.","title":"2.4 Composite"},{"content":"Decorator(装饰者模式) 定义 动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.\n本质 interface(一般都要)\n主要是编写 被装饰者，在构造函数中加入装饰者，然后在被装饰者类中注意对装饰者类的调用\n为什么使用Decorator? 我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.\n使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了\u0026quot;即插即用\u0026quot;的方法,在运行期间决定何时增加何种功能.\n如何使用? 举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.\n我们先建立一个接口:\npublic interface Work { public void insert(); } 接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:\npublic class SquarePeg implements Work{ public void insert(){ System.out.println(\u0026#34;方形桩插入\u0026#34;); } } 现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).\n那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些\u0026quot;油漆\u0026quot;,这些油漆就是那些额外的功能.\npublic class Decorator implements Work{ private Work work; //额外增加的功能被打包在这个List中 private ArrayList others = new ArrayList(); //在构造器中使用组合new方式,引入Work对象; public Decorator(Work work) { this.work=work; others.add(\u0026#34;挖坑\u0026#34;); others.add(\u0026#34;钉木板\u0026#34;); } public void insert(){ newMethod(); } //在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 public void newMethod() { otherMethod(); work.insert(); } public void otherMethod() { ListIterator listIterator = others.listIterator(); while (listIterator.hasNext()) { System.out.println(((String)(listIterator.next())) + \u0026#34; 正在进行\u0026#34;); } } } 在上例中,我们把挖坑和钉木板都排在了打桩insert前面,这里只是举例说明额外功能次序可以任意安排.\n好了,Decorator模式出来了,我们看如何调用:\nWork squarePeg = new SquarePeg(); Work decorator = new Decorator(squarePeg); decorator.insert(); Decorator模式至此完成.\n如果你细心,会发现,上面调用类似我们读取文件时的调用:\nFileReader fr = new FileReader(filename); BufferedReader br = new BufferedReader(fr);\n实际上Java 的I/O API就是使用Decorator实现的,I/O变种很多,如果都采取继承方法,将会产生很多子类,显然相当繁琐.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.5-decorator/","summary":"Decorator(装饰者模式) 定义 动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.\n本质 interface(一般都要)\n主要是编写 被装饰者，在构造函数中加入装饰者，然后在被装饰者类中注意对装饰者类的调用\n为什么使用Decorator? 我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.\n使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了\u0026quot;即插即用\u0026quot;的方法,在运行期间决定何时增加何种功能.\n如何使用? 举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.\n我们先建立一个接口:\npublic interface Work { public void insert(); } 接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:\npublic class SquarePeg implements Work{ public void insert(){ System.out.println(\u0026#34;方形桩插入\u0026#34;); } } 现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).\n那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些\u0026quot;油漆\u0026quot;,这些油漆就是那些额外的功能.\npublic class Decorator implements Work{ private Work work; //额外增加的功能被打包在这个List中 private ArrayList others = new ArrayList(); //在构造器中使用组合new方式,引入Work对象; public Decorator(Work work) { this.work=work; others.add(\u0026#34;挖坑\u0026#34;); others.add(\u0026#34;钉木板\u0026#34;); } public void insert(){ newMethod(); } //在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 public void newMethod() { otherMethod(); work.","title":"2.5 Decorator"},{"content":"Adapter(适配者模式) 定义 将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份.\n为何使用? 我们经常碰到要将两个没有关系的类组合在一起使用,第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?\n使用Adapter，在这两种接口之间创建一个混合接口(混血儿).\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.3-adapter/","summary":"Adapter(适配者模式) 定义 将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份.\n为何使用? 我们经常碰到要将两个没有关系的类组合在一起使用,第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?\n使用Adapter，在这两种接口之间创建一个混合接口(混血儿).","title":"2.3 Adapter"},{"content":"Proxy(代理模式)定义 为其他对象提供一种代理以控制对这个对象的访问.\n代理模式是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结构,Proxy是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理.\n为什么要使用Proxy? 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.\n某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况:\n如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.\n如何使用Proxy? 以Jive论坛系统为例,访问论坛系统的用户有多种类型:注册普通用户 论坛管理者 系统管理者 游客,注册普通用户才能发言;论坛管理者可以管理他被授权的论坛;系统管理者可以管理所有事务等,这些权限划分和管理是使用Proxy完成的.\nForum是Jive的核心接口,在Forum中陈列了有关论坛操作的主要行为,如论坛名称 论坛描述的获取和修改,帖子发表删除编辑等.\n在ForumPermissions中定义了各种级别权限的用户:\npublic class ForumPermissions implements Cacheable { /** * Permission to read object. */ public static final int READ = 0; /** * Permission to administer the entire sytem. */ public static final int SYSTEM_ADMIN = 1; /** * Permission to administer a particular forum. */ public static final int FORUM_ADMIN = 2; /** * Permission to administer a particular user. */ public static final int USER_ADMIN = 3; /** * Permission to administer a particular group. */ public static final int GROUP_ADMIN = 4; /** * Permission to moderate threads. */ public static final int MODERATE_THREADS = 5; /** * Permission to create a new thread. */ public static final int CREATE_THREAD = 6; /** * Permission to create a new message. */ public static final int CREATE_MESSAGE = 7; /** * Permission to moderate messages. */ public static final int MODERATE_MESSAGES = 8; ..... public boolean isSystemOrForumAdmin() { return (values[FORUM_ADMIN] || values[SYSTEM_ADMIN]); } ..... } 因此,Forum中各种操作权限是和ForumPermissions定义的用户级别有关系的,作为接口Forum的实现:ForumProxy正是将这种对应关系联系起来.比如,修改Forum的名称,只有论坛管理者或系统管理者可以修改,代码如下:\npublic class ForumProxy implements Forum { private ForumPermissions permissions; private Forum forum; this.authorization = authorization; public ForumProxy(Forum forum, Authorization authorization, ForumPermissions permissions) { this.forum = forum; this.authorization = authorization; this.permissions = permissions; } ..... public void setName(String name) throws UnauthorizedException, ForumAlreadyExistsException { //只有是系统或论坛管理者才可以修改名称 if (permissions.isSystemOrForumAdmin()) { forum.setName(name); } else { throw new UnauthorizedException(); } } ... } 而DbForum才是接口Forum的真正实现,以修改论坛名称为例:\npublic class DbForum implements Forum, Cacheable { ... public void setName(String name) throws ForumAlreadyExistsException { .... this.name = name; //这里真正将新名称保存到数据库中 saveToDb(); .... } ... } 凡是涉及到对论坛名称修改这一事件,其他程序都首先得和ForumProxy打交道,由ForumProxy决定是否有权限做某一样事情,ForumProxy是个名副其实的\u0026quot;网关\u0026quot;,\u0026ldquo;安全代理系统\u0026rdquo;.\n在平时应用中,无可避免总要涉及到系统的授权或安全体系,不管你有无意识的使用Proxy,实际你已经在使用Proxy了.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.2-proxy/","summary":"Proxy(代理模式)定义 为其他对象提供一种代理以控制对这个对象的访问.\n代理模式是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结构,Proxy是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理.\n为什么要使用Proxy? 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.\n某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况:\n如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.\n如何使用Proxy? 以Jive论坛系统为例,访问论坛系统的用户有多种类型:注册普通用户 论坛管理者 系统管理者 游客,注册普通用户才能发言;论坛管理者可以管理他被授权的论坛;系统管理者可以管理所有事务等,这些权限划分和管理是使用Proxy完成的.\nForum是Jive的核心接口,在Forum中陈列了有关论坛操作的主要行为,如论坛名称 论坛描述的获取和修改,帖子发表删除编辑等.\n在ForumPermissions中定义了各种级别权限的用户:\npublic class ForumPermissions implements Cacheable { /** * Permission to read object. */ public static final int READ = 0; /** * Permission to administer the entire sytem. */ public static final int SYSTEM_ADMIN = 1; /** * Permission to administer a particular forum. */ public static final int FORUM_ADMIN = 2; /** * Permission to administer a particular user.","title":"2.2 Proxy"},{"content":"Facade (外观 总管模式）定义 为子系统中的一组接口提供一个一致的界面.\n链接\nFacade一个典型应用就是数据库JDBC的应用\n所有程序对数据库访问都是使用改接口,降低系统的复杂性,增加了灵活性.\n如果我们要使用连接池,也只要针对facade接口修改就可以.\n","permalink":"https://blog.chalme.top/posts/design-patterns/2.1-facade/","summary":"Facade (外观 总管模式）定义 为子系统中的一组接口提供一个一致的界面.\n链接\nFacade一个典型应用就是数据库JDBC的应用\n所有程序对数据库访问都是使用改接口,降低系统的复杂性,增加了灵活性.\n如果我们要使用连接池,也只要针对facade接口修改就可以.","title":"2.1 Facade"},{"content":"Builder(建造者模式）定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.\nBuilder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.\n为何使用? 是为了将构建复杂对象的过程和它的部件解耦.注意: 是解耦过程和部件.\n因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.\n如何使用? 首先假设一个复杂对象是由多个部件组成的,Builder模式是把复杂对象的创建和部件的创建分别开来,分别用Builder类和Director类来表示.\n首先,需要一个接口,它定义如何创建复杂对象的各个部件:\npublic interface Builder { //创建部件A　比如创建汽车车轮 void buildPartA(); //创建部件B 比如创建汽车方向盘 void buildPartB(); //创建部件C 比如创建汽车发动机 void buildPartC(); //返回最后组装成品结果 (返回最后装配好的汽车) //成品的组装过程不在这里进行,而是转移到下面的Director类中进行. //从而实现了解耦过程和部件 Product getResult(); } 用Director构建最后的复杂对象,而在上面Builder接口中封装的是如何创建一个个部件(复杂对象是由这些部件组成的),也就是说Director的内容是如何将部件最后组装成成品:\npublic class Director { private Builder builder; public Director( Builder builder ) { this.builder = builder; } // 将部件partA partB partC最后组成复杂对象 //这里是将车轮 方向盘和发动机组装成汽车的过程 public void construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); } } Builder的具体实现ConcreteBuilder:\n通过具体完成接口Builder来构建或装配产品的部件; 定义并明确它所要创建的是什么具体东西; 提供一个可以重新获取产品的接口: public class ConcreteBuilder implements Builder { Part partA, partB, partC; public void buildPartA() { //这里是具体如何构建partA的代码 }; public void buildPartB() { //这里是具体如何构建partB的代码 }; public void buildPartC() { //这里是具体如何构建partB的代码 }; public Product getResult() { //返回最后组装成品结果 }; } 复杂对象:产品Product:\npublic interface Product { } 复杂对象的部件:\npublic interface Part { } 我们看看如何调用Builder模式:\nConcreteBuilder builder = new ConcreteBuilder(); Director director = new Director( builder ); director.construct(); Product product = builder.getResult(); 应用 在Java实际使用中,我们经常用到\u0026quot;池\u0026quot;(Pool)的概念,当资源提供者无法提供足够的资源,并且这些资源需要被很多用户反复共享时,就需要使用池.\n\u0026ldquo;池\u0026quot;实际是一段内存,当池中有一些复杂的资源的\u0026quot;断肢\u0026rdquo;(比如数据库的连接池,也许有时一个连接会中断),如果循环再利用这些\u0026quot;断肢\u0026quot;,将提高内存使用效率,提高池的性能.修改Builder模式中Director类使之能诊断\u0026quot;断肢\u0026quot;断在哪个部件上,再修复这个部件.\n","permalink":"https://blog.chalme.top/posts/design-patterns/1.4-builder/","summary":"Builder(建造者模式）定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.\nBuilder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.\n为何使用? 是为了将构建复杂对象的过程和它的部件解耦.注意: 是解耦过程和部件.\n因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.\n如何使用? 首先假设一个复杂对象是由多个部件组成的,Builder模式是把复杂对象的创建和部件的创建分别开来,分别用Builder类和Director类来表示.\n首先,需要一个接口,它定义如何创建复杂对象的各个部件:\npublic interface Builder { //创建部件A　比如创建汽车车轮 void buildPartA(); //创建部件B 比如创建汽车方向盘 void buildPartB(); //创建部件C 比如创建汽车发动机 void buildPartC(); //返回最后组装成品结果 (返回最后装配好的汽车) //成品的组装过程不在这里进行,而是转移到下面的Director类中进行. //从而实现了解耦过程和部件 Product getResult(); } 用Director构建最后的复杂对象,而在上面Builder接口中封装的是如何创建一个个部件(复杂对象是由这些部件组成的),也就是说Director的内容是如何将部件最后组装成成品:\npublic class Director { private Builder builder; public Director( Builder builder ) { this.builder = builder; } // 将部件partA partB partC最后组成复杂对象 //这里是将车轮 方向盘和发动机组装成汽车的过程 public void construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); } } Builder的具体实现ConcreteBuilder:\n通过具体完成接口Builder来构建或装配产品的部件; 定义并明确它所要创建的是什么具体东西; 提供一个可以重新获取产品的接口: public class ConcreteBuilder implements Builder { Part partA, partB, partC; public void buildPartA() { //这里是具体如何构建partA的代码 }; public void buildPartB() { //这里是具体如何构建partB的代码 }; public void buildPartC() { //这里是具体如何构建partB的代码 }; public Product getResult() { //返回最后组装成品结果 }; } 复杂对象:产品Product:","title":"1.4 Builder"},{"content":"Singleton (单例模式）定义 Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。\n在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作. 还有, singleton能够被状态化; 这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要论坛中的帖子计数器，每次浏览一次需要计数，单态类能否保持住这个计数，并且能synchronize的安全自动加1，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。\n另外方面，Singleton也能够被无状态化。提供工具性质的功能，\nSingleton模式就为我们提供了这样实现的可能。使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。\n我们常常看到工厂模式中类装入器(class loader)中也用Singleton模式实现的,因为被装入的类实际也属于资源。\n如何使用 public class Singleton { private Singleton(){} //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问　public static Singleton getInstance() { return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class TestInstance{ private static TestInstance instance; public static TestInstance getInstance{ if(instance==null){ synchronized(TestInstance.class){ if(instance==null){ instance=new TestInstance(); } } return instance; } } public class SingleClass2{ private static class SingleInstance{ private static SingleClass2 instance = new SingleClass2(); } private SingleClass2(){ } public static SingleClass2 CreateInstance(){ return SingleInstance.instance; } } ","permalink":"https://blog.chalme.top/posts/design-patterns/1.3-singleton/","summary":"Singleton (单例模式）定义 Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。\n在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作. 还有, singleton能够被状态化; 这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要论坛中的帖子计数器，每次浏览一次需要计数，单态类能否保持住这个计数，并且能synchronize的安全自动加1，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。\n另外方面，Singleton也能够被无状态化。提供工具性质的功能，\nSingleton模式就为我们提供了这样实现的可能。使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。\n我们常常看到工厂模式中类装入器(class loader)中也用Singleton模式实现的,因为被装入的类实际也属于资源。\n如何使用 public class Singleton { private Singleton(){} //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问　public static Singleton getInstance() { return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class TestInstance{ private static TestInstance instance; public static TestInstance getInstance{ if(instance==null){ synchronized(TestInstance.","title":"1.3 Singleton"},{"content":"Prototype Prototype （原型模式）定义 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 使用 java中有 clone 方法来实现对象的克隆，所以。。。 以 勺子为例\npublic abstract class AbstractSpoon implements Cloneable { String spoonName; public void setSpoonName(String spoonName) {this.spoonName = spoonName;} public String getSpoonName() {return this.spoonName;} public Object clone() { Object object = null; try { object = super.clone(); } catch (CloneNotSupportedException exception) { System.err.println(\u0026#34;AbstractSpoon is not Cloneable\u0026#34;); } return object; } } public class SoupSpoon extends AbstractSpoon { public SoupSpoon() { setSpoonName(\u0026#34;Soup Spoon\u0026#34;); } } 调用Prototype模式很简单:\nAbstractSpoon spoon = new SoupSpoon(); AbstractSpoon spoon2 = spoon.clone(); 当然也可以结合工厂模式来创建AbstractSpoon实例。 实质： java 使用object 类的clone 方法\n","permalink":"https://blog.chalme.top/posts/design-patterns/1.2-prototype/","summary":"Prototype Prototype （原型模式）定义 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 使用 java中有 clone 方法来实现对象的克隆，所以。。。 以 勺子为例\npublic abstract class AbstractSpoon implements Cloneable { String spoonName; public void setSpoonName(String spoonName) {this.spoonName = spoonName;} public String getSpoonName() {return this.spoonName;} public Object clone() { Object object = null; try { object = super.clone(); } catch (CloneNotSupportedException exception) { System.err.println(\u0026#34;AbstractSpoon is not Cloneable\u0026#34;); } return object; } } public class SoupSpoon extends AbstractSpoon { public SoupSpoon() { setSpoonName(\u0026#34;Soup Spoon\u0026#34;); } } 调用Prototype模式很简单:","title":"1.2 Prototype"},{"content":"工厂模式定义 提供创建对象的接口\n详细1\n详细2\n简介 简单工厂模式\n工厂方法模式\n抽象工厂模式\n简单工厂模式 它由三种角色组成（关系见下面的类图）：\n工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。\n抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。\n具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。\n本质 : 在Creator 中 create 方法中 使用 equals(string name)方法来创建 Product。\n//抽象产品角色 public interface Car{ public void drive(); } //具体产品角色 public class Benz implements Car{ public void drive() { System.out.println(\u0026#34;Driving Benz \u0026#34;); } } public class Bmw implements Car{ public void drive() { System.out.println(\u0026#34;Driving Bmw \u0026#34;); } } 。。。（奥迪我就不写了:P） //工厂类角色 public class Driver{ //工厂方法 //注意 返回类型为抽象产品角色 public static Car driverCar(String s)throws Exception { //判断逻辑，返回具体的产品角色给Client if(s.equalsIgnoreCase(\u0026#34;Benz\u0026#34;)) return new Benz(); else if(s.equalsIgnoreCase(\u0026#34;Bmw\u0026#34;)) return new Bmw(); ...... else throw new Exception(); 。。。 //欢迎暴发户出场...... public class Magnate{ public static void main(String[] args){ try{ //告诉司机我今天坐奔驰 Car car = Driver.driverCar(\u0026#34;benz\u0026#34;); //下命令：开车 car.drive(); 。。。 工厂方法模式 先来看下它的组成吧：\n抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4、具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 //抽象工厂角色 public interface Driver{ public Car driverCar(); } public class BenzDriver implements Driver{ public Car driverCar(){ return new Benz(); } } public class BmwDriver implements Driver{ public Car driverCar() { return new Bmw(); } } ......//应该和具体产品形成对应关系，这里略... //有请暴发户先生 public class Magnate { public static void main(String[] args) { try{ Driver driver = new BenzDriver(); Car car = driver.driverCar(); car.drive(); }catch(Exception e) { } } } 抽象工厂模式 抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。而且使用抽象工厂模式还要满足一下条件：\n系统中有多个产品族，而系统一次只可能消费其中一族产品 同属于同一个产品族的产品一起使用时。 来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：\n抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 ","permalink":"https://blog.chalme.top/posts/design-patterns/1.1-factory/","summary":"工厂模式定义 提供创建对象的接口\n详细1\n详细2\n简介 简单工厂模式\n工厂方法模式\n抽象工厂模式\n简单工厂模式 它由三种角色组成（关系见下面的类图）：\n工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。\n抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。\n具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。\n本质 : 在Creator 中 create 方法中 使用 equals(string name)方法来创建 Product。\n//抽象产品角色 public interface Car{ public void drive(); } //具体产品角色 public class Benz implements Car{ public void drive() { System.out.println(\u0026#34;Driving Benz \u0026#34;); } } public class Bmw implements Car{ public void drive() { System.out.println(\u0026#34;Driving Bmw \u0026#34;); } } 。。。（奥迪我就不写了:P） //工厂类角色 public class Driver{ //工厂方法 //注意 返回类型为抽象产品角色 public static Car driverCar(String s)throws Exception { //判断逻辑，返回具体的产品角色给Client if(s.","title":"1.1 Factory"},{"content":"设计模式(Patterns in Java) 链接 另类的设计模式\n图说设计模式\n如今设计模式已经成为架构师和程序员之间沟通的必备语言，也是普通程序员成长为资深程序员的必备基础之一。只有掌握了设计模式，才能更好地掌握DDD领域驱动设计等OO分析设计方法，也才能更熟练地学习使用不断涌现的新语言。\n创建模式（5） Factory(工厂模式）\nPrototype(原型模式）\nBuilder\nSingleton(单例模式）\n结构模式（7） Facade\nProxy\nAdapter\nComposite\nDecorator\nBridge\nFlyweight\n行为模式（11） Template(模板模式）\nMemento(备忘录模式）\nObserver(观察者模式）\nChain of Responsibility(CoR)\nCommand\nState\nStrategy\nmediator\nInterperter\nVivistor\nIterator\n","permalink":"https://blog.chalme.top/posts/design-patterns/0.0-outline/","summary":"设计模式(Patterns in Java) 链接 另类的设计模式\n图说设计模式\n如今设计模式已经成为架构师和程序员之间沟通的必备语言，也是普通程序员成长为资深程序员的必备基础之一。只有掌握了设计模式，才能更好地掌握DDD领域驱动设计等OO分析设计方法，也才能更熟练地学习使用不断涌现的新语言。\n创建模式（5） Factory(工厂模式）\nPrototype(原型模式）\nBuilder\nSingleton(单例模式）\n结构模式（7） Facade\nProxy\nAdapter\nComposite\nDecorator\nBridge\nFlyweight\n行为模式（11） Template(模板模式）\nMemento(备忘录模式）\nObserver(观察者模式）\nChain of Responsibility(CoR)\nCommand\nState\nStrategy\nmediator\nInterperter\nVivistor\nIterator","title":"0.0 outline"},{"content":"","permalink":"https://blog.chalme.top/categories/","summary":"categories","title":"Category"}]