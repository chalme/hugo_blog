[{"content":" 技术关注点无外乎稳定性、成本、体验、合规、效率。 （公司）\n一个优秀工程师和一个平庸工程师的最大区别就是，谁有火眼金睛及时识别到问题在哪里，危机在哪里，及时提前准备解决这些危机，而不是在问题发生后，不知所措，两眼一抹黑，自乱阵脚，毫无解决思路。（玄恩）\n稳定性 系统的稳定性是项目很重要的一部分。\n身在商品部门，在商品发布这一侧经常会出现发布不可用的或成功率暴跌的情况。\n从我个人的角度，谈谈对稳定性整体的理解。 根本上讲，是属于研发规范的范畴。 这边会从三个维度来说明，发生事故前、发生事故时、发生事故后。\n发生事故前 这个阶段实际上属于研发规范的范畴，个人理解，如果按照研发规范来开发系统，实际上绝大多数问题都可以避免。\n每一个环节实际上细节还挺多的。 当然每一个环节，可以细化如何做，有些是必须要求，有些是可选的，我们可以分级指明。\n比如： 设计阶段，比如完整的大需求，在设计方面要求全面，背景、概念图、设计图等都需要完整；面对一些小需求，可以按需选择。\n发生事故时 一般来讲，系统有完善的监控，制订相应的标准，我们都可以在第一时间收到响应的异常信息。进而根据一些项目相关信息及预案，来快速恢复系统。\n发生事故后 通常需要反思回顾，主要目的是防止事故再次发生，同时也给其他同事提醒。\n提供一个模版。\n事件概述：（现状描述：谁发现问题影响到什么） 事件影响：影响现状描述 事件范围：影响范围 事件原因：初步原因和结论原因 事件进度：描述进展 事件结果：处理结果 事件方案：如何处理和后续改进 成本 目的： 一方面 可以减少 成本的支出， 另一个方面 增加开发 owner 对项目的了解程度。\n一般开发成本有以下部分：\nDB： mysql, redis, mq, opensearch , maxcompute， hbash，日志山云 SLS 机器资源： cpu， 内存， 磁盘， 网络带宽 中间件： blink（实时数据处理），精卫， 监控 sunfire（日志收集存储，） 人员成本： 开发/测试/产品/leader 成本控制作为工程师的重要素养之一，大到系统架构、技术选型，小到一个函数方法的执行性能，都会涉及到成本。以前成本强调的不多，可能会时常出现方案设计未考虑成本、申请资源相对随意浪费等情况，如今对大家也都提出了更高的要求。但成本又不是我们面临的唯一因素，如何在支持业务高速发展、保障系统稳定的情况下高效地做这件事，这是一个需要长期修炼的课题，也相信未来大家都会越做越好~\n效率 效率不仅仅与工程师素质有紧密联系，与公司制度、文化也有很大关系。\n效率可以从各方面来做，简单的\n熟练掌握工具使用。比如，开发 IDEA，VI；办公：截图，全局剪贴板；等等 熟练掌握常用 API 的使用。 比如，guava, apache-common; 命令行工具；源码的使用； 熟悉体系结构。 对整体有了解，知道什么在什么地方，有什么作用。 熟悉底层原理。 对于疑难杂症的处理方式。 流程层面：\n主干开发，主干发布，自动集成。这个确实很难，需要有完善的工具，优秀的工程师。 抽象层次，复用。不管是代码层面、系统角度，都是一样的。 理论体系：\nDDD 的软件结构。 声明式设计。麻烦留给自己，简单留给别人。 沟通:\n开会模式。开会主要是对提案做选择。 表达方式。 图标表达，结构化表达，目的是为了让对方更快更好的理解。 合规 主要是法律意识。尤其在境外，不同国家法律要求不同，我们对于这些需要有一些相应的技术调整。\n体验 为用户做的系统，必然在客户/用户的角度思考，如果做才能让用户使用方便。个人感觉，设计和功能都很重要。\n小结 其实在很多点方面，都有很多细节可以讲。本文主要从概念的角度，从全局看一个项目有哪些方面，需要注意。\n","permalink":"http://blog.chalme.top/posts/think/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","summary":"技术关注点无外乎稳定性、成本、体验、合规、效率。 （公司）\n一个优秀工程师和一个平庸工程师的最大区别就是，谁有火眼金睛及时识别到问题在哪里，危机在哪里，及时提前准备解决这些危机，而不是在问题发生后，不知所措，两眼一抹黑，自乱阵脚，毫无解决思路。（玄恩）\n稳定性 系统的稳定性是项目很重要的一部分。\n身在商品部门，在商品发布这一侧经常会出现发布不可用的或成功率暴跌的情况。\n从我个人的角度，谈谈对稳定性整体的理解。 根本上讲，是属于研发规范的范畴。 这边会从三个维度来说明，发生事故前、发生事故时、发生事故后。\n发生事故前 这个阶段实际上属于研发规范的范畴，个人理解，如果按照研发规范来开发系统，实际上绝大多数问题都可以避免。\n每一个环节实际上细节还挺多的。 当然每一个环节，可以细化如何做，有些是必须要求，有些是可选的，我们可以分级指明。\n比如： 设计阶段，比如完整的大需求，在设计方面要求全面，背景、概念图、设计图等都需要完整；面对一些小需求，可以按需选择。\n发生事故时 一般来讲，系统有完善的监控，制订相应的标准，我们都可以在第一时间收到响应的异常信息。进而根据一些项目相关信息及预案，来快速恢复系统。\n发生事故后 通常需要反思回顾，主要目的是防止事故再次发生，同时也给其他同事提醒。\n提供一个模版。\n事件概述：（现状描述：谁发现问题影响到什么） 事件影响：影响现状描述 事件范围：影响范围 事件原因：初步原因和结论原因 事件进度：描述进展 事件结果：处理结果 事件方案：如何处理和后续改进 成本 目的： 一方面 可以减少 成本的支出， 另一个方面 增加开发 owner 对项目的了解程度。\n一般开发成本有以下部分：\nDB： mysql, redis, mq, opensearch , maxcompute， hbash，日志山云 SLS 机器资源： cpu， 内存， 磁盘， 网络带宽 中间件： blink（实时数据处理），精卫， 监控 sunfire（日志收集存储，） 人员成本： 开发/测试/产品/leader 成本控制作为工程师的重要素养之一，大到系统架构、技术选型，小到一个函数方法的执行性能，都会涉及到成本。以前成本强调的不多，可能会时常出现方案设计未考虑成本、申请资源相对随意浪费等情况，如今对大家也都提出了更高的要求。但成本又不是我们面临的唯一因素，如何在支持业务高速发展、保障系统稳定的情况下高效地做这件事，这是一个需要长期修炼的课题，也相信未来大家都会越做越好~\n效率 效率不仅仅与工程师素质有紧密联系，与公司制度、文化也有很大关系。\n效率可以从各方面来做，简单的\n熟练掌握工具使用。比如，开发 IDEA，VI；办公：截图，全局剪贴板；等等 熟练掌握常用 API 的使用。 比如，guava, apache-common; 命令行工具；源码的使用； 熟悉体系结构。 对整体有了解，知道什么在什么地方，有什么作用。 熟悉底层原理。 对于疑难杂症的处理方式。 流程层面：","title":"项目管理"},{"content":"快离开一家公司了，一些想法想记录一下。\n为什么选择这家公司？ 客观说， 当时我想的并不清楚，对社会的了解，对自身能力的评估了解，在和一些朋友的沟通中，薪资压的很低。 简单来讲，想去一个大公司，获得成长。\n在这边的收获？ 说实在的， 在工作上是有收获的，但确实感觉收获不大。但是在思想上、思考力上，提升了很多，对未来有一些明确目标。 个人认为，很多时候我们成长是靠自己的，自己有一些想法，去实践，去反思。 在阿里确实有很多牛人，有内部的博客，大家可以在分享自己的想法，总结，实践。\n有些东西分享一下。有思考力的人真的很有魅力！\n生活与工作的平衡？ 南门 - 慎言平衡。 我认为“平衡”这个提法是不对的。我认为要提“帕累托改进”：例如：在不降低质量和增加时间的前提下，让成本下降；在不降低质量和增加成本的前提下，让时间缩短；在不增加时间和成本的前提下让质量提升。 不过，据我的观察，通常来说，在很多事情上我们都没有达到“帕累托最优”。比如，工作和生活的平衡，绝大多数人都没有达到“帕累托最优”，都是有很多办法可以在不降低生活质量的前提下提升工作成绩、在不降低工作成绩的前提下提升生活质量。或者可以这么说，我认为，在所有的问题上，我们都可以默认的认为我们还远未达到“帕累托最优”。\n如何衡量一个研发团队的效率？ 如何衡量一个研发团队的效率。我现在更倾向于觉得，这个问题就好像“怎么衡量一个人的幸福程度”，很难有一个很好的科学量化的度量。 有人说，可不可以用需求来度量：\n需求平均周期：一个需求提出到上线的时间 需求吞吐量：一个月或者一年内人均承接需求个数 但是这两个指标和需求大小关系很大，比较难衡量研发效率。需求的大小、复杂度，难量化，难对比。 如果一定要找一个指标，我倒宁可用 code velocity 来衡量一个研发团队的效率。Code velocity 指的是：一个代码变更，从提交入库开始计时，到这段代码被 100%的用户用到，中间经过了多少时间。 Code velocity 这个指标，也参杂了业务因素在里面：1）很多时候，具体的业务形态决定了 code velocity 并不需要很高；2）很多时候，code velocity 的高低有很多非研发团队的因素在里面。但是，code velocity 这个指标的优点是：1）很简单、很容易理解；2）很容易度量，而且普遍适用于各种形态的产品和技术栈；3）code velocity 提高了，大概率是因为研发过程中一些东西有了提高。 Code velocity 和需求大小并没有太大关系。一个巨大的需求，也可以把代码拆细，小块小块代码，细水长流得发布上线。就像“蚂蚁搬家”一样，今天搬个桌子，明天办个锅子。如果可以做到“蚂蚁搬家”，code velocity 就能很快。要做到能够“蚂蚁搬家”，是需要在架构、工具、测试等方面下一番苦功的。 能够做到Push on Green的研发团队，它的效率是很高的，它的 code velocity 也是很高的。\n离开原因 公司的变化。 这块之前和部门 leader，也聊了很多。给了我很多建议。第二点，也是部门领导和我聊的原因。 自身的成长。 应该说长期处于一线的开发，各方面也体会的很多，经验也很多。自己也有自己想要做的人。 希望自身可以承担一大块业务，甚至是 leader 的指责。 未来 自身是一个理想化的个体。 思辨、思考能力是非常重要的，这块是继续加强。\n待续。。。\n","permalink":"http://blog.chalme.top/posts/think/%E7%A6%BB%E5%BC%80lazada%E7%9A%84%E9%9A%8F%E6%83%B3/","summary":"快离开一家公司了，一些想法想记录一下。\n为什么选择这家公司？ 客观说， 当时我想的并不清楚，对社会的了解，对自身能力的评估了解，在和一些朋友的沟通中，薪资压的很低。 简单来讲，想去一个大公司，获得成长。\n在这边的收获？ 说实在的， 在工作上是有收获的，但确实感觉收获不大。但是在思想上、思考力上，提升了很多，对未来有一些明确目标。 个人认为，很多时候我们成长是靠自己的，自己有一些想法，去实践，去反思。 在阿里确实有很多牛人，有内部的博客，大家可以在分享自己的想法，总结，实践。\n有些东西分享一下。有思考力的人真的很有魅力！\n生活与工作的平衡？ 南门 - 慎言平衡。 我认为“平衡”这个提法是不对的。我认为要提“帕累托改进”：例如：在不降低质量和增加时间的前提下，让成本下降；在不降低质量和增加成本的前提下，让时间缩短；在不增加时间和成本的前提下让质量提升。 不过，据我的观察，通常来说，在很多事情上我们都没有达到“帕累托最优”。比如，工作和生活的平衡，绝大多数人都没有达到“帕累托最优”，都是有很多办法可以在不降低生活质量的前提下提升工作成绩、在不降低工作成绩的前提下提升生活质量。或者可以这么说，我认为，在所有的问题上，我们都可以默认的认为我们还远未达到“帕累托最优”。\n如何衡量一个研发团队的效率？ 如何衡量一个研发团队的效率。我现在更倾向于觉得，这个问题就好像“怎么衡量一个人的幸福程度”，很难有一个很好的科学量化的度量。 有人说，可不可以用需求来度量：\n需求平均周期：一个需求提出到上线的时间 需求吞吐量：一个月或者一年内人均承接需求个数 但是这两个指标和需求大小关系很大，比较难衡量研发效率。需求的大小、复杂度，难量化，难对比。 如果一定要找一个指标，我倒宁可用 code velocity 来衡量一个研发团队的效率。Code velocity 指的是：一个代码变更，从提交入库开始计时，到这段代码被 100%的用户用到，中间经过了多少时间。 Code velocity 这个指标，也参杂了业务因素在里面：1）很多时候，具体的业务形态决定了 code velocity 并不需要很高；2）很多时候，code velocity 的高低有很多非研发团队的因素在里面。但是，code velocity 这个指标的优点是：1）很简单、很容易理解；2）很容易度量，而且普遍适用于各种形态的产品和技术栈；3）code velocity 提高了，大概率是因为研发过程中一些东西有了提高。 Code velocity 和需求大小并没有太大关系。一个巨大的需求，也可以把代码拆细，小块小块代码，细水长流得发布上线。就像“蚂蚁搬家”一样，今天搬个桌子，明天办个锅子。如果可以做到“蚂蚁搬家”，code velocity 就能很快。要做到能够“蚂蚁搬家”，是需要在架构、工具、测试等方面下一番苦功的。 能够做到Push on Green的研发团队，它的效率是很高的，它的 code velocity 也是很高的。\n离开原因 公司的变化。 这块之前和部门 leader，也聊了很多。给了我很多建议。第二点，也是部门领导和我聊的原因。 自身的成长。 应该说长期处于一线的开发，各方面也体会的很多，经验也很多。自己也有自己想要做的人。 希望自身可以承担一大块业务，甚至是 leader 的指责。 未来 自身是一个理想化的个体。 思辨、思考能力是非常重要的，这块是继续加强。\n待续。。。","title":"离开lazada的随想"},{"content":" 世界上的人分为两种：一种是“思辨者”，而另一种就是“吃瓜群众”。\n这是一个有趣且深刻的问题。作为一个开发者，通常我们都专于研发方面，在整体方面思考的比较少。作为人，我个人认为都需要进行发展。\nchatGPT的一种答案 通用能力是指一个人具有的广泛的、综合的能力，包括以下几个方面：\n语言能力：能够清晰、流畅地表达思想。 数学能力：对数学知识的理解和运用能力。 逻辑思维能力：能够系统地分析和解决问题。 创造力：具有创造性思维和创新意识。 学习能力：具有自主学习的能力。 社交能力：能够与他人进行有效的沟通和合作。 情绪管理：能够积极面对挑战，并保持良好的情绪状态。 自我调节：具有自我规划和自我调节的能力。 全面发展：关注身体、心理、精神和社会等方面的全面发展。 通用能力是每个人都应该具备的能力，它不仅是一个人的个人发展的重要指标，也是他的社会价值的体现。\n个人认知 chatGPT的答案在各个角度都有涉及，是一个比较完美的回答。 通过它的回答，对应到自己，确实在某些方面还是有比较多的不足。\n最近在看一本书 《麦肯锡结构化战略思维》，对于个人来讲，结构化战旅思维有了具象的了解，不过，还需多读几次。\n文中有一句话记得比较深刻，“焦虑”很大程度上源于对未来的不确定。...我们需要在思维层面突破舒适区的束缚和人脑快速思考的惯性，养成理性思辨的习惯。...\n确实我们焦虑主要是来源于对未来的不确定。我们需要养成理性思辨的习惯。\n","permalink":"http://blog.chalme.top/posts/think/%E4%BA%BA%E7%9A%84%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9B/","summary":"世界上的人分为两种：一种是“思辨者”，而另一种就是“吃瓜群众”。\n这是一个有趣且深刻的问题。作为一个开发者，通常我们都专于研发方面，在整体方面思考的比较少。作为人，我个人认为都需要进行发展。\nchatGPT的一种答案 通用能力是指一个人具有的广泛的、综合的能力，包括以下几个方面：\n语言能力：能够清晰、流畅地表达思想。 数学能力：对数学知识的理解和运用能力。 逻辑思维能力：能够系统地分析和解决问题。 创造力：具有创造性思维和创新意识。 学习能力：具有自主学习的能力。 社交能力：能够与他人进行有效的沟通和合作。 情绪管理：能够积极面对挑战，并保持良好的情绪状态。 自我调节：具有自我规划和自我调节的能力。 全面发展：关注身体、心理、精神和社会等方面的全面发展。 通用能力是每个人都应该具备的能力，它不仅是一个人的个人发展的重要指标，也是他的社会价值的体现。\n个人认知 chatGPT的答案在各个角度都有涉及，是一个比较完美的回答。 通过它的回答，对应到自己，确实在某些方面还是有比较多的不足。\n最近在看一本书 《麦肯锡结构化战略思维》，对于个人来讲，结构化战旅思维有了具象的了解，不过，还需多读几次。\n文中有一句话记得比较深刻，“焦虑”很大程度上源于对未来的不确定。...我们需要在思维层面突破舒适区的束缚和人脑快速思考的惯性，养成理性思辨的习惯。...\n确实我们焦虑主要是来源于对未来的不确定。我们需要养成理性思辨的习惯。","title":"人的通用能力"},{"content":" 本文主要是从极客时间课程中记录的理论笔记及个人练题的记录。\n总体结构 时间及空间复杂度 主定理 相关资料\nBig-O Complexity Chart 常见数据结构时间复杂度和空间复杂度\nleetcode习题 数组/链表 反转链表 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode resNode = null; ListNode tempNode = null; while(head != null) { tempNode = head.next; head.next = resNode; resNode = head; head = tempNode; } return resNode; } } 24. 两两交换链表中的节点 141. 环形链表 /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow=head, quick = head; while (slow != null \u0026amp;\u0026amp; quick != null) { slow = slow.next; if (quick.next == null) { return false; } else { quick = quick.next.next; } if (slow == quick) { return true; } } return false; } } 堆栈 Stack push pop peek Queue offer poll peek\n844. 比较含退格的字符串 栈处理数据后，再对比 逆序对比（巧妙） 225. 用队列实现栈 两个队列： 将一个队列数据 offer 到另一个 232. 用栈实现队列 两个堆栈 20. 有效的括号 堆栈处理 class Solution { public boolean isValid(String s) { if (s == null) { return false; } Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); Map\u0026lt;Character, Character\u0026gt; base = new HashMap\u0026lt;\u0026gt;(); base.put(\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;); base.put(\u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;); base.put(\u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;); for (int i=0; i\u0026lt;s.length(); i++) { Character c = s.charAt(i); if (base.containsKey(c)) { stack.push(c); } else { if (!stack.isEmpty() \u0026amp;\u0026amp; base.get(stack.pop()) == c) { } else { return false; } } } return stack.isEmpty(); } } 优先队列 实现机制：\n堆 (Strict Fibonacci) 二叉搜索树 703. 数据流中的第 K 大元素 最小堆 O(n*logk) class KthLargest { private PriorityQueue\u0026lt;Integer\u0026gt; priorityQueue; private int k; public KthLargest(int k, int[] nums) { this.k = k; this.priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(k); for (int n: nums) { add(n); } } public int add(int val) { if (priorityQueue.size() \u0026lt; k) { priorityQueue.offer(val); } else if (priorityQueue.peek() \u0026lt; val) { priorityQueue.poll(); priorityQueue.offer(val); } return priorityQueue.peek(); } } /** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ MAP \u0026amp; SET Hash function 碰撞 1. 两数之和 Map (key, value) 查找 map o(n) map(value, key) class Solution { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i=0; i\u0026lt;nums.length; i++) { if (map.get(target - nums[i]) != null) { return new int[]{map.get(target - nums[i]), i}; } else { map.put(nums[i], i); } } return new int[]{}; } } 15. 三数之和 排序\u0026amp;双指针 —注意边界，判断重复 O(n^2) class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { int length = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); for (int i=0; i\u0026lt;length; i++) { if (i != 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]){ continue; } int l = i + 1, r = length -1; while (l \u0026lt; r) { int three = -(nums[i] + nums[l]); while (nums[r] \u0026gt; three \u0026amp;\u0026amp; r-1 \u0026gt; l) { r --; } if (nums[r] == three) { List\u0026lt;Integer\u0026gt; item = new ArrayList\u0026lt;\u0026gt;(); item.add(nums[i]); item.add(nums[l]); item.add(nums[r]); result.add(item); while (l \u0026lt; r-1 \u0026amp;\u0026amp; nums[r] == nums[r-1]) { r = r-1; } while (l+1 \u0026lt; r \u0026amp;\u0026amp; nums[l+1] == nums[l]){ l = l+1; } } l = l+1; } } return result; } } 树 二叉树 二叉搜索树 98. 验证二叉搜索树 中序 array 生序。 o(n) 递归 左子树最大值；右子树最小值. o(n) /** * 中序遍历 */ private boolean stack(TreeNode root) { Integer tmp = null; Deque\u0026lt;TreeNode\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); while(root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (tmp == null) { tmp = root.val; } else { if (root.val \u0026lt;= tmp) { return false; } else { tmp = root.val; } } root = root.right; } return true; } 235. 二叉搜索树的最近公共祖先 利用二叉搜索树的排序的特点 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { while (root != null) { if (p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { root = root.left; } else if (p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { root = root.right; } else { return root; } } return root; } } 236. 二叉树的最近公共祖先 递归 findPorQ(root, P, Q). O(n) /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left == null) { return right; } else if (right == null) { return left; } else { return root; } } } 递归、分治 50. Pow(x, n) Pow 暴力 快速幂 + 递归 快速幂 + 迭代 class Solution { // public double myPow(double x, int n) { // if (n == 0) { // return 1.0; // } else { // return n \u0026gt; 0 ? quickPow(x, n) : 1.0 / quickPow(x, n); // } // } public double myPow(double x,int n) { long t = n; if (t \u0026lt; 0) { t = -t; x = 1/x; } double pow = 1.0; while (t \u0026gt; 0) { if ((t\u0026amp;1) == 1) { pow *= x; } t \u0026gt;\u0026gt;= 1; x = x*x; } return pow; } private double quickPow(double x, int n) { if (n == 0) { return 1.0; } double y = quickPow(x, n/2); return n % 2 == 0 ? y*y : y*y*x; } } 169. 多数元素 哈希表 排序 投票 class Solution { /** * 1. hash O(n)/O(n) * 2. 排序 O(nlgn)/O(nlogn) * 3. 投票 O(n)/O(n) */ public int majorityElement(int[] nums) { Integer candidate = null; int count = 0; for (int num : nums) { if (count == 0) { candidate = num; } count += (candidate == num) ? 1 : -1; } return candidate; } } 贪心算法 greedy 适用 Greedy 的场景\n简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题 的最优解。这种子问题最优解成为最优子结构。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能 回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择 有回退功能。 搜索 # 广度优先 （队列\u0026amp;visited set) def BFS(graph. start, end) queue = [] quaue.append([start]) visited.add(start) while queue; node = queue.pop() visited.add (node) process(node) nodes = generate_related_nodes(node) queue.push (nodes) # 深度优先 (stack \u0026amp; visited set) visited = set() def dfs(node ,visited)： visited.add(node) # process current node here. ... for next_node in node. chilgren(): if not next node in visited: dfs(next_node, visited) 102. 二叉树的层序遍历 BFS。o(n) DFS. /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return res; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { List\u0026lt;Integer\u0026gt; item = new ArrayList\u0026lt;\u0026gt;(); int size = queue.size(); for (int i=0; i\u0026lt;size; i++) { TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } item.add(node.val); } res.add(item); } return res; } } 104. 二叉树的最大深度 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { /** * 1. BFS. O(n) * 2. DFS. O(n) */ public int maxDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int ans = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i=0; i\u0026lt;size; i++) { TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } ans ++; } return ans; } } class Solution { /** * 1. BFS. O(n) * 2. DFS. O(n) */ public int maxDepth(TreeNode root) { if (root == null) { return 0; } // DFS int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight, rightHeight) + 1; } } 22. 括号生成 递归-剪值 class Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); generateParenthesis(\u0026#34;\u0026#34;, res, n, n); return res; } private void generateParenthesis(String sub, List\u0026lt;String\u0026gt; res, int left, int right) { if (left == 0 \u0026amp;\u0026amp; right == 0) { res.add(sub); return; } if (left \u0026gt; 0) { generateParenthesis(sub + \u0026#34;(\u0026#34;, res, left - 1, right); } if (right \u0026gt; left) { generateParenthesis(sub + \u0026#34;)\u0026#34;, res, left, right -1); } } } 51. N 皇后 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int[] queens = new int[n]; Arrays.fill(queens, -1); Set\u0026lt;Integer\u0026gt; cols = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; pie = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; na = new HashSet\u0026lt;\u0026gt;(); backtrack(res, queens, n, 0, cols, pie, na); return res; } public void backtrack(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; res, int[] queens, int n, int row, Set\u0026lt;Integer\u0026gt; cols, Set\u0026lt;Integer\u0026gt; pie, Set\u0026lt;Integer\u0026gt; na) { if (row == n) { res.add(generateBoard(queens, n)); return; } else { for (int i=0; i\u0026lt;n; i++) { if (cols.contains(i)) { continue; } int pi = row - i; if (pie.contains(pi)) { continue; } int ni = row + i; if (na.contains(ni)) { continue; } queens[row] = i; cols.add(i); pie.add(pi); na.add(ni); backtrack(res, queens, n, row+1, cols, pie, na); queens[row] = -1; cols.remove(i); pie.remove(pi); na.remove(ni); } } } public List\u0026lt;String\u0026gt; generateBoard(int[] queens, int n) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;String\u0026gt;(); for (int i=0; i\u0026lt;n; i++) { char[] item = new char[n]; Arrays.fill(item, \u0026#39;.\u0026#39;); item[queens[i]] = \u0026#39;Q\u0026#39;; res.add(new String(item)); } return res; } } 36. 有效的数独 37. 解数独\n回溯 line[9], col[9], block[3][3] 状态压缩 class Solution { /** * 回溯\u0026amp;状态压缩（位运算） */ private int[] row = new int[9]; private int[] column = new int[9]; private int[][] block = new int[3][3]; private List\u0026lt;int[]\u0026gt; spaces = new ArrayList\u0026lt;\u0026gt;(); private boolean valid = false; public void solveSudoku(char[][] board) { for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { if (board[i][j] == \u0026#39;.\u0026#39;) { spaces.add(new int[]{i, j}); } else { int digit = board[i][j] - \u0026#39;0\u0026#39; - 1; flip(i, j, digit); } } } dfs(board, 0); } public void dfs(char[][] board, int pos) { if (pos == spaces.size()) { valid = true; return ; } int[] space = spaces.get(pos); int i = space[0], j = space[1]; // 获取可填写的数字 int mask = ~(row[i] | column[j] | block[i/3][j/3]) \u0026amp; 0x1ff; for (; mask!=0 \u0026amp;\u0026amp; !valid; mask \u0026amp;= (mask-1)) { // 最低一位 int maskDigit = mask \u0026amp; (-mask); int digit = Integer.bitCount(maskDigit - 1); flip(i, j, digit); board[i][j] = (char)(\u0026#39;0\u0026#39; + digit + 1); dfs(board, pos + 1); flip(i, j, digit); } } public void flip(int i, int j, int digit) { row[i] ^= 1\u0026lt;\u0026lt;digit; column[j] ^= 1\u0026lt;\u0026lt;digit; block[i/3][j/3] ^= 1\u0026lt;\u0026lt;digit; } } 二分查找 sorted bounded accessible by index 69. x 的平方根\u0026mdash;（浮点数，精度） 二分 牛顿迭代 public class BSearch { static double sqrt2 = 1.4142135624; static double delta = 0.0000000001; public static void main(String[] args) { double l = 1.0; double r = 2.0; int cnt = 0; while (l \u0026lt; r) { double mid = (l + r) / 2; if (Math.abs(l - sqrt2) \u0026lt; delta) { break; } if (mid * mid \u0026gt; 2.0) { r = mid; } else { l = mid; } cnt++; } System.out.println(\u0026#34;经过\u0026#34; + cnt + \u0026#34;次迭代后得\u0026#34; + l); } } class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } } class Solution { public int mySqrt(int x) { if (x == 0) { return 0; } double C = x, x0 = x; while (true) { double xi = 0.5 * (x0 + C / x0); if (Math.abs(x0 - xi) \u0026lt; 1e-7) { break; } x0 = xi; } return (int) x0; } } trie 字典树 wikipedia\n208. 实现 Trie (前缀树) class Trie { private Trie[] children; private boolean isEnd; /** Initialize your data structure here. */ public Trie() { children = new Trie[26]; isEnd = false; } /** Inserts a word into the trie. */ public void insert(String word) { Trie root = this; for (int i = 0; i \u0026lt; word.length(); i++) { char c = word.charAt(i); int index = c - \u0026#39;a\u0026#39;; if (root.children[index] == null) { root.children[index] = new Trie(); } root = root.children[index]; } root.isEnd = true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Trie root = this; for (int i = 0; i \u0026lt; word.length(); i++) { char c = word.charAt(i); if (root.children[c - \u0026#39;a\u0026#39;] == null) { return false; } root = root.children[c - \u0026#39;a\u0026#39;]; } return root.isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Trie root = this; for (int i = 0; i \u0026lt; prefix.length(); i++) { char c = prefix.charAt(i); if (root.children[c - \u0026#39;a\u0026#39;] == null) { return false; } root = root.children[c - \u0026#39;a\u0026#39;]; } return true; } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 212. 单词搜索 II DFS trie 位运算 191. 位 1 的个数 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int cnt = 0; while (n != 0) { cnt ++; n \u0026amp;= (n-1); } return cnt; } } 231. 2 的幂 class Solution { public boolean isPowerOfTwo(int n) { return n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; (n-1)) == 0; } } 338. 比特位计数 class Solution { /** * bit[i] = bit[i\u0026amp;(i-1)] + 1 */ public int[] countBits(int n) { int[] bits = new int[n+1]; for (int i = 1; i \u0026lt;= n; i++) { bits[i] = bits[i \u0026amp; (i-1)] + 1; } return bits; } } 动态规划（DP dynamic programming | Echo …） 递归+记忆化 一＞递推 状态的定义：optinj, dpinj, fibin] 状态转移方程：optin] = best_of(optin-11, optin-2], .. 最优子结构 贪心 一 永远局部最优 DP 一 记录局部最优子结构 / 多种记录值\n并查集 wikipedia\n岛屿的数量 并查集 bfs class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r \u0026lt; nr; ++r) { for (int c = 0; c \u0026lt; nc; ++c) { if (grid[r][c] == \u0026#39;1\u0026#39;) { ++num_islands; grid[r][c] = \u0026#39;0\u0026#39;; Queue\u0026lt;Integer\u0026gt; neighbors = new LinkedList\u0026lt;\u0026gt;(); neighbors.add(r * nc + c); while (!neighbors.isEmpty()) { int id = neighbors.remove(); int row = id / nc; int col = id % nc; if (row - 1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row-1][col] == \u0026#39;1\u0026#39;) { neighbors.add((row-1) * nc + col); grid[row-1][col] = \u0026#39;0\u0026#39;; } if (row + 1 \u0026lt; nr \u0026amp;\u0026amp; grid[row+1][col] == \u0026#39;1\u0026#39;) { neighbors.add((row+1) * nc + col); grid[row+1][col] = \u0026#39;0\u0026#39;; } if (col - 1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row][col-1] == \u0026#39;1\u0026#39;) { neighbors.add(row * nc + col-1); grid[row][col-1] = \u0026#39;0\u0026#39;; } if (col + 1 \u0026lt; nc \u0026amp;\u0026amp; grid[row][col+1] == \u0026#39;1\u0026#39;) { neighbors.add(row * nc + col+1); grid[row][col+1] = \u0026#39;0\u0026#39;; } } } } } return num_islands; } } // 并查集 class Solution { class UnionFind { int count; int[] parent; int[] rank; public UnionFind(char[][] grid) { count = 0; int m = grid.length; int n = grid[0].length; parent = new int[m * n]; rank = new int[m * n]; for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == \u0026#39;1\u0026#39;) { parent[i * n + j] = i * n + j; ++count; } rank[i * n + j] = 0; } } } public int find(int i) { if (parent[i] != i) parent[i] = find(parent[i]); return parent[i]; } public void union(int x, int y) { int rootx = find(x); int rooty = find(y); if (rootx != rooty) { if (rank[rootx] \u0026gt; rank[rooty]) { parent[rooty] = rootx; } else if (rank[rootx] \u0026lt; rank[rooty]) { parent[rootx] = rooty; } else { parent[rooty] = rootx; rank[rootx] += 1; } --count; } } public int getCount() { return count; } } public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; UnionFind uf = new UnionFind(grid); for (int r = 0; r \u0026lt; nr; ++r) { for (int c = 0; c \u0026lt; nc; ++c) { if (grid[r][c] == \u0026#39;1\u0026#39;) { grid[r][c] = \u0026#39;0\u0026#39;; if (r - 1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[r-1][c] == \u0026#39;1\u0026#39;) { uf.union(r * nc + c, (r-1) * nc + c); } if (r + 1 \u0026lt; nr \u0026amp;\u0026amp; grid[r+1][c] == \u0026#39;1\u0026#39;) { uf.union(r * nc + c, (r+1) * nc + c); } if (c - 1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[r][c-1] == \u0026#39;1\u0026#39;) { uf.union(r * nc + c, r * nc + c - 1); } if (c + 1 \u0026lt; nc \u0026amp;\u0026amp; grid[r][c+1] == \u0026#39;1\u0026#39;) { uf.union(r * nc + c, r * nc + c + 1); } } } } return uf.getCount(); } } ","permalink":"http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"本文主要是从极客时间课程中记录的理论笔记及个人练题的记录。\n总体结构 时间及空间复杂度 主定理 相关资料\nBig-O Complexity Chart 常见数据结构时间复杂度和空间复杂度\nleetcode习题 数组/链表 反转链表 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode resNode = null; ListNode tempNode = null; while(head != null) { tempNode = head.next; head.next = resNode; resNode = head; head = tempNode; } return resNode; } } 24.","title":"算法与数据结构"},{"content":"缓存 基本上来说，在分布式系统中最耗性能的地方就是最后端的数据库了。\n一般来说，只要小心维护好，数据库四种操作（select、update、insert 和 delete）中的三个写操作 insert、update 和 delete 不太会出现性能问题（insert 一般不会有性能问题，update 和 delete 一般会有主键，所以也不会太慢）。除非索引建得太多，而数据库里的数据又太多，这三个操作才会变慢。 绝大多数情况下，select 是出现性能问题最大的地方。一方面，select 会有很多像 join、group、order、like 等这样丰富的语义，而这些语义是非常耗性能的；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。 分布式系统中远程调用也会消耗很多资源，因为网络开销会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。 设计的重点：\n在分布式架构下，一般都需要一个外部的缓存集群。关于这个缓存集群，你需要保证的是内存要足够大，网络带宽也要好，因为缓存本质上是个内存和 IO 密集型的应用。 缓存的好坏要看命中率。缓存的命中率高说明缓存有效，一般来说命中率到 80% 以上就算很高了。当然，有的网络为了追求更高的性能，要做到 95% 以上，甚至可能会把数据库里的数据几乎全部装进缓存中。 缓存是通过牺牲强一致性来提高性能的，这世上任何事情都不是免费的 缓存数据的时间周期也需要好好设计 使用缓存的时候，一般会使用 LRU 策略 缓存是提高性能最好的方式，一般来说，缓存有以下三种模式。\nCache Aside 更新模式 失效：应用程序先从 Cache 取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从 Cache 中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。\n当然，最好还是为缓存设置好过期时间。\n为什么不去直接更新？ 主要是怕两个并发的写操作导致脏数据。\nCache Aside 就不会有并发问题了？ 比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。\nRead/Write Through 更新模式 缓存由数据库代理。 缓存和数据库为一体。\nwirte 更新模式 直接写数据库， 通过中间件（精卫）写入缓存。\n异步处理 异步通讯的设计模式 ： 提高系统的稳定性和容错能力。 增加整个系统的吞吐量，从而可以面对更高的并发，并可以从容地利用好现有的系统资源。\n当你在做一件事的时候，如果有别人来找你做其它事，你就会被打断而要去干别的事。而如果你可以统筹安排这些事情，本来五件事只需要 2 个小时，如果不能，或者老被别人打乱思路，那你可能就要花 5 个小时。异步处理任务可以让你更好地利用好时间和资源。利用好了时间和资源，性能自然就会提升上来。\n这就好像邮递业务一样，你寄东西的时候，邮递公司会把大量的去往同一个方向的订单合并处理，并统一地调配物流交通工具，从而在整体上更为节省资源和时间。\n也就是说，merge 是把相同的操作合并，相同的读操作只读一次，相同的写操作，只写最后一次，而 sort 是把不同的操作排个序，这样可以让硬盘向一个方向转一次就可以把所有的数据读出来，而不是来来回回地转。这样可以极大地提高硬盘的吞吐率。 多说一句，就算是有延时，异步处理在用户体验上也可以给用户带来一个不错的用户体验，那就是用户可以有机会反悔之前的操作。 这就是异步系统所带来的好处——让我们的系统可以统一调度。\n设计： 首先，我们需要一个前台系统，把用户发来的请求一一记录下来，有点像请求日志。这样，我们的操作在数据库或是存储上只会有追加的操作，性能会很高。我们收到请求后，给客户端返回“收到请求，正在处理中”。\n然后，我们有个任务处理系统来真正地处理收到的这些请求。为了解耦，我们需要一个任务派发器，这里就会出来两个事，一个是推模型 Push，一个是拉模型 Pull。\n异步处理的设计要点： 异步处理中的事件驱动和事件溯源是两个比较关键的技术。 异步处理可能会因为一些故障导致我们的一些任务没有被处理，比如消息丢失，没有通知到，或通知到了，没有处理。有这一系列的问题，异步通知的方式需要任务处理方处理完成后，给任务发起方回传状态，这样确保不会有漏掉的。 发起方也需要有个定时任务，把一些超时没有回传状态的任务再重新做一遍，你可以认为这是异步系统中的 \u0026quot; 对账 \u0026quot; 功能。当然，如果要重做的话，就需要处理方支持幂等性处理。 异步处理的整体业务事务问题，也就是说，异步处理在处理任务的时候，并不知道能否处理成功，于是就会一步一步地处理，如果到最后一步不能成功，那么你就需要回滚。这个时候，需要走我们在弹力设计中说的补偿事务的流程。\n异步处理系统的本质是把被动的任务处理变成主动的任务处理，其本质是在对任务进行调度和统筹管理。\n事件溯源 主要想解决的问题是，我们可以看到数据库中的一个数据的值（状态），但我们完全不知道这个值是怎么得出来的。就像银行的存折一样，我们可以在银行的存折看到我们收支的所有记录，也能看得到每一笔记录后的余额。\n当然，如果我们有了所有的收支流水账的记录，我们完全不需要保存余额，因为我们只需要回放一下所有的收支事件，就可以得到最终的数据状态。这样一来，我们的系统就会变得非常简单，只需要追加不可修改的数据操作事件，而不是保存最终状态。除了可以提高性能和响应时间之外，还可以提供事务数据一致性，并保留了可以启用补偿操作的完整记录和历史记录。 还有一个好处，就是如果我们的代码里有了 bug，在记录状态的系统里，我们修改 bug 后还需要做数据修正。然而，在 Event Sourcing 的系统里，我们只需要把所有事件重新播放一遍就好了，因为整个系统没有状态了。\n事件不可变，并且可使用只追加操作进行存储。 用户界面、工作流或启动事件的进程可继续，处理事件的任务可在后台异步运行。 此外，处理事务期间不存在争用，这两点可极大提高应用程序的性能和可伸缩性。\n最重要的是，异步处理 + 事件溯源的方式，可以很好地让我们的整个系统进行任务的统筹安排、批量处理，可以让整体处理过程达到性能和资源的最大化利用。\n数据库扩展 读写分离 CQRS 这样的方法好处是：\n比较容易实现。数据库的 master-slave 的配置和服务框架里的读写分离都比较成熟，应用起来也很快。 可以很好地把各个业务隔离开来。不会因为一个业务把数据库拖死而导致所有的业务都死掉。 可以很好地分担数据库的读负载，毕竟读操作是最耗数据库 CPU 的操作。 CQRS 全称 Command and Query Responsibility Segregation，也就是命令与查询职责分离。其原理是，用户对于一个应用的操作可以分成两种，一种是 Command 也就是我们的写操作（增，删，改），另一种是 Query 操作（查），也就是读操作。Query 操作基本上是在做数据整合显现，而 Command 操作这边会有更重的业务逻辑。分离开这两种操作可以在语义上做好区分。\n分库分表 Sharding 影响数据库最大的性能问题有两个，一个是对数据库的操作，一个是数据库中数据的大小。\n对于前者，我们需要从业务上来优化。一方面，简化业务，不要在数据库上做太多的关联查询，而对于一些更为复杂的用于做报表或是搜索的数据库操作，应该把其移到更适合的地方。比如，用 ElasticSearch 来做查询，用 Hadoop 或别的数据分析软件来做报表分析。 对于后者，如果数据库里的数据越来越多，那么也会影响我们的数据操作。而且，对于我们的分布式系统来说，后端服务都可以做成分布式的，而数据库最好也是可以拆开成分布式的。读写分离也因为数据库里的数据太多而变慢，于是，分库分表就成了我们必须用的手段。 带来的问题：\nMax/Min/Count 这样的操作。 合并返回 join 事务 分库分片策略：\n租户 ID 按数据的种类来分 通过范围来分 通过哈希散列算法来分（比如：主键 id % 3 之类的算法。）此策略的目的是降低形成热点的可能性（接收不成比例的负载的分片）。 分片模式选择：\n数据库分片必须考虑业务，从业务的角度入手，而不是从技术的角度入手，如果你不清楚业务，那么无法做出好的分片策略。 请只考虑业务分片。请不要走哈希散列的分片方式，除非有个人拿着刀把你逼到墙角，你马上就有生命危险，你才能走哈希散列的分片方式。 设计重点： 在一个单体的库上做读写分离或是做分片都是一件治标不治本的事，真正治本的方法就是**要和服务一起拆解。**有两种分片模式，一种是水平分片，一种是垂直分片。\n水平分片需要有以下一些注意事项：\n随着数据库中数据的变化，我们有可能需要定期重新平衡分片，以保证均匀分布并降低形成热点的可能性。 减少平衡的次数。 快速重新平衡分片的工具和脚本。 分片是静态的，而数据的访问则是不可预期的，可能需要经常性地调整我们的分片，这样一来成本太高。所以，我们最好使用一个索引表的方式来进行分片。 数据分片后，我们很难在分片之间保持引用完整性和一致性，也就是所谓的跨分片的事务，因此应尽量减少会影响多个分片中的数据的操作。如果应用程序必须跨分片修改数据，那么我们需要评估一致性以及评估是否采用两阶段提交的方式。 配置和管理大量分片可能是一个挑战。在做相应的变更时，一定要先从生产线上拉出数据，然后根据数据计划好新的分片方式，并做好相当的测试工作。否则，这个事出了问题会是一个灾难性的问题。 秒杀 场景： “秒杀”其实是商家为了促销，使用非常低的价格销售商品，比如，1 元卖 iPhone，100 台，于是来了一百万人抢购。\n用户或产品的角度：\n首先，你需要一个秒杀的 landing page，在这个秒杀页上有一个倒计时的按钮。 一旦这个倒计时的时间到了，按钮就被点亮，让你可以点击按钮下单。 一般来说下单时需要你填写一个校验码，以防止是机器来抢。 细节： 倒计时时间需要校准； 需要向后端发送有没有开始， 如果开始， 返回前端一个 URL。\n技术挑战：\n100 万的同时并发会导致我们的网站瞬间就崩溃了。 网络带宽、100w 的 TPS 需要非常多的机器。 所有的请求都会集中在同一条数据库记录上，无论是怎么分库分表，还是使用了分布式数据库都无济于事，因为你面对的是单条的热点数据。 技术方案：\n**CDN。**上百个 CDN 的边缘结点，于是就能够扛得住。 我们需要把小服务部署到 CDN 结点上去。当前端页面来问开没开始时，这个小服务除了告诉前端开没开始外，它还可以统计下有多少人在线。 假设，我们知道有大约 100 万的人在线等着抢，那么，在我们快要开始的时候，由数据中心向各个部署在 CDN 结点上的小服务上传递一个概率值，比如说是 0.02%。 过滤用户请求。 其他实例： 12306 抢票 场景： 他们完全不知道用户来是要买哪张火车票的。不知道这个信息，很不好过滤用户，而且用户在买票前需要有很多查询操作，然后在查询中选择自己的车票。\n方案：\n12306 最好的应对方式，除了不要一次把所有的票放出来，而是分批在不同的时间段把票放出来，这样可以让人们不要集中在一个时间点来抢票，做到人肉分流，可以降低一些并发度。 12306 最好是用预售的方式，让大家把自己的购票先输入到系统中。系统并不真正放票，而是把大家的需求都收集好，然后做整体统筹安排，该增加车次的增加车次，该加车厢的加车厢，这样可以确保大家都能走。实在不行，那就抽签了。 更多的思考 场景： 双 11 那样，想尽可能多地卖出商品，那么就不像秒杀了。这是要尽可能多地收订单，但又不能超过库存，其中还有大量的银行支付，各大仓库的库存查询和分配，这些都是非常慢的操作。为了保证一致性，还要能够扛得住像双 11 这样的大规模并发访问，那么，应该怎么做呢？\n方案： 这个时候就需要认认真真地做高并发的架构和测试了，需要各个系统把自己的性能调整上去，还要小心地做性能规划，更要把分布式的弹力设计做好，最后是要不停地做性能测试，找到整个架构的系统瓶颈，然后不断地做水平扩展，以解决大规模的并发。\n小结 像我们用边缘结点来解决秒杀这样的场景的玩法，是否也有一定的普适性？这里，我想说，一定是有的。 更好的性能，成本。\n边缘计算 所谓边缘计算， 它是相对于数据中心而言。数据中心喜欢把所有的服务放在一个机房里集中处理用户的数据和请求，集中式部署一方面便于管理和运维，另一方面也便于服务间的通讯有一个比较好的网络保障。的确没错。不过，我们依然需要像CDN 这样的边缘式的内容发布网络，把我们的静态内容推到离用户最近的地方，然后获得更好的性能。\n为什么要有边缘计算 从趋势上： 整个计算机发展的本质就是我们人类生活信息化建设的过程。 这个过程中，计算机硬件的发展也是非常迅猛的。CPU 的处理速度，硬盘的大小和速度，网络的带宽和速度都在拼命地升级和降价。我们用越来越低的成本，获得越来越快的速度、越来越大的带宽、越来越快的存储…… 所有的这一切，其实都是和信息还有数据有关。我们的信息和数据越来越多，越来越大，所以，我们需要更好、更快、更便宜的硬件和基础设施。这个演化过程中，在我参加工作这 20 年来就没有停止过，而且，我也不认为未来会停下来，这个过程只会越来越快。 我们可以看到，数量越来越大，分析结果的速度需要越来越快，这两个需求，只会把我们逼到边缘计算上去。 如果你还是在数据中心处理，你会发现你的成本只会越来越高，到一定时候就完全玩不下去了。\n从成本： 根据我过去服务过的 40 多家公司的经验，可以看到如下的投入：\n几十万用户的公司，只需要处理百级 QPS 的量，只需要 10 台左右的服务器； 上百万用户的公司，只需要处理千级 QPS 的量，需要有 50 台左右的服务器； 上千万用户的公司，需要处理万级到十万级 QPS 的量，需要 700 台左右的服务器； 上亿用户的公司，其需要处理百万级 QPS 的量，需要上万台的服务器。 边缘计算的业务场景 处理一些实时响应的业务。它和用户靠得很近，所以可以实时响应用户的一些本地请求，比如，某公司的人脸门禁系统、共享单车的开锁。 处理一些简单的业务逻辑。比如像秒杀、抢红包这样的业务场景。 收集并结构化数据。比如，把视频中的车牌信息抠出来，转成文字，传回数据中心。 实时设备监控。主要是线下设备的数据采集和监控。 。。。\n关键技术 API Gateway Serverless/FaaS。就是服务函数化，这个技术就像是 AWS Lambda 服务一样，你写好一个函数，然后不用关心这个函数运行在哪里，直接发布就好了。然后就可以用了。 ","permalink":"http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1-%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/","summary":"缓存 基本上来说，在分布式系统中最耗性能的地方就是最后端的数据库了。\n一般来说，只要小心维护好，数据库四种操作（select、update、insert 和 delete）中的三个写操作 insert、update 和 delete 不太会出现性能问题（insert 一般不会有性能问题，update 和 delete 一般会有主键，所以也不会太慢）。除非索引建得太多，而数据库里的数据又太多，这三个操作才会变慢。 绝大多数情况下，select 是出现性能问题最大的地方。一方面，select 会有很多像 join、group、order、like 等这样丰富的语义，而这些语义是非常耗性能的；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。 分布式系统中远程调用也会消耗很多资源，因为网络开销会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。 设计的重点：\n在分布式架构下，一般都需要一个外部的缓存集群。关于这个缓存集群，你需要保证的是内存要足够大，网络带宽也要好，因为缓存本质上是个内存和 IO 密集型的应用。 缓存的好坏要看命中率。缓存的命中率高说明缓存有效，一般来说命中率到 80% 以上就算很高了。当然，有的网络为了追求更高的性能，要做到 95% 以上，甚至可能会把数据库里的数据几乎全部装进缓存中。 缓存是通过牺牲强一致性来提高性能的，这世上任何事情都不是免费的 缓存数据的时间周期也需要好好设计 使用缓存的时候，一般会使用 LRU 策略 缓存是提高性能最好的方式，一般来说，缓存有以下三种模式。\nCache Aside 更新模式 失效：应用程序先从 Cache 取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从 Cache 中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。\n当然，最好还是为缓存设置好过期时间。\n为什么不去直接更新？ 主要是怕两个并发的写操作导致脏数据。\nCache Aside 就不会有并发问题了？ 比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。\nRead/Write Through 更新模式 缓存由数据库代理。 缓存和数据库为一体。\nwirte 更新模式 直接写数据库， 通过中间件（精卫）写入缓存。\n异步处理 异步通讯的设计模式 ： 提高系统的稳定性和容错能力。 增加整个系统的吞吐量，从而可以面对更高的并发，并可以从容地利用好现有的系统资源。\n当你在做一件事的时候，如果有别人来找你做其它事，你就会被打断而要去干别的事。而如果你可以统筹安排这些事情，本来五件事只需要 2 个小时，如果不能，或者老被别人打乱思路，那你可能就要花 5 个小时。异步处理任务可以让你更好地利用好时间和资源。利用好了时间和资源，性能自然就会提升上来。","title":"分布式关键设计 性能设计"},{"content":"分布式锁 场景： 我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。分布式环境下， 这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。\n特点： 安全性（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）。 避免死锁：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。 容错性：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。\n设计： 我是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。 一般可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务。\n需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。 超时时间。 分布式锁服务应该是高可用的，而且是需要持久化的。 要提供非阻塞方式的锁服务。 还要考虑锁的可重入性。 具体实现 redis：\nSET resource_name my_random_value NX PX 30000 if redis.call(\u0026#34;get\u0026#34;,KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;,KEYS[1]) else return 0 end 问题： 解决方案： 乐观锁，版本号递增；\n锁服务的时候，单调递增的版本号； 写数据的时候也需要增加版本号； 数据库保存版本号， 对情况进行校验； 从乐观锁到 CAS 数据库中也保留着版本号 ， 可以使用 乐观锁处理(fence token)； UPDATE table_name SET xxx = #{xxx}, version=version+1 where version =#{version}; 数据库那边一般会用 timestamp 时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。\n有时候都不需要增加额外的版本字段或是 fence token。\nSELECT stock FROM tb_product where product_id=#{product_id}; UPDATE tb_product SET stock=stock-#{num} WHERE product_id=#{product_id} AND stock=#{stock}; 无锁结构： 乐观锁 CAS 。 cas 的 ABA 问题： double-CAS（双保险的 CAS）。 无锁队列： 1）无锁队列主要是通过 CAS、FAA 这些原子操作，和 Retry-Loop 实现。 2）对于 Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD 和 TAIL 这两个关键资源。而不是整个数据结构。\ntrade-off 悲观锁因为对读写都加锁，所以它的性能比较低，对于现在互联网提倡的三高(高性能、高可用、高并发)来说，悲观锁的实现用的越来越少了，但是一般多读的情况下还是需要使用悲观锁的，因为虽然加锁的性能比较低，但是也阻止了像乐观锁一样，遇到写不一致的情况下一直重试的时间。 相对而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。\n管理设计 我们知道，除了代码之外，软件还有一些配置信息，比如数据库的用户名和密码，还有一些我们不想写死在代码里的东西，像线程池大小、队列长度等运行参数，以及日志级别、算法策略等，还有一些是软件运行环境的参数，如 Java 的内存大小，应用启动的参数，包括操作系统的一些参数配置……\n配置中心的设计 把软件的配置分成静态配置和动态配置。操作系统的网络配置，软件运行时 Docker 进程的配置，这些配置在软件环境初始化时就确定了，未来基本不会修改了。而所谓动态配置其实就是软件运行时的一些配置，在运行时会被修改。比如，日志级别、降级开关、活动开关。 动态配置的管理，做好区分， 三个部分：\n按运行环境分。 开发，测试，生产。 按依赖区分。一种是依赖配置，一种是不依赖的内部配置。比如，外部依赖的 MySQL 或 Redis 的连接配置。还有一种完全是自己内部的配置。 按层次分。 分成 IaaS、PaaS、SaaS 三层。基础层的配置是操作系统的配置，中间平台层的配置是中间件的配置，如 Tomcat 的配置，上层软件层的配置是应用自己的配置。 配置中心的模型 软件配置基本上来说，每个配置项就是 key/value 的模型\n配置中心的架构 在这个图中可以看到，我们把配置录入后，配置中心发出变更通知，配置变更控制器会来读取最新的配置，然后应用配置。 为什么需要一个变更通知的组件，而不是让配置中心直接推送？ 分布式环境下，服务器太多，推送不太现实，而采用一个 Pub/Sub 的通知服务可以让数据交换经济一些。\n配置中心的设计重点 配置中心主要的用处是统一和规范化管理所有的服务配置，也算是一种配置上的治理活动。所以，配置中心的设计重点应该放在如何统一和标准化软件的配置项，其还会涉及到软件版本、运行环境、平台、中间件等一系列的配置参数。\n配置的实时： 写少读多的场景\n基于拉模型的客户端轮询的方案 大多数轮询请求都是没有意义的 .基于推模型的客户端长轮询的方案 基于 Http 长轮询模型，实现了让客户端在没有发生动态配置变更的时候减少轮询。这样减少了无意义的轮询请求量，提高了轮询的效率；也降低了系统负载，提升了整个系统的资源利用率。 这种推拉结合的策略，做到了在长连接和短连接之间的平衡，实现上让服务端不用太关注连接的管理，效果上又获得了类似 TCP 长连接的信息推送的实时性。\n边车模式 编程的本质就是将控制和逻辑分离和解耦，而边车模式也是异曲同工，同样是让我们在分布式架构中做到逻辑和控制分离。 所谓的边车模式，对应于我们生活中熟知的边三轮摩托车。也就是说，我们可以通过给一个摩托车加上一个边车的方式来扩展现有的服务和功能。这样可以很容易地做到 \u0026quot; 控制 \u0026quot; 和 \u0026quot; 逻辑 \u0026quot; 的分离。 也就是说，我们不需要在服务中实现控制面上的东西，如监视、日志记录、限流、熔断、服务注册、协议适配转换等这些属于控制面上的东西，而只需要专注地做好和业务逻辑相关的代码，然后，由“边车”来实现这些与业务逻辑没有关系的控制功能。\n对于监视、日志、限流、熔断、服务注册、协议转换等等这些功能，其实都是大同小异，甚至是完全可以做成标准化的组件和模块的 一般来说，我们有两种方式。一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。 另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。\n集成在软件 sidecar 优点 以软件包的方式可以和应用密切集成，有利于资源的利用和应用的性能 对应用服务没有侵入性，并且不用受到应用服务的语言和技术的限制，而且可以做到控制和逻辑的分开升级和部署 缺点 对应用有侵入，而且受应用的编程语言和技术限制 增加了每个应用服务的依赖性，也增加了应用的延迟，并且也会大大增加管理、托管、部署的复杂度。 Sidecar 可以帮助服务注册到相应的服务发现系统，并对服务做相关的健康检查。 当应用服务要调用外部服务时， Sidecar 可以帮助从服务发现中找到相应外部服务的地址，然后做服务路由。 Sidecar 接管了进出的流量，我们就可以做相应的日志监视、调用链跟踪、流控熔断……这些都可以放在 Sidecar 里实现。然后，服务控制系统可以通过控制 Sidecar 来控制应用服务，如流控、下线等。 |\n边车设计的重点 重点解决什么样的问题\n控制和逻辑的分离。 服务调用中上下文的问题。 我们知道，熔断、路由、服务发现、计量、流控、监视、重试、幂等、鉴权等控制面上的功能，以及其相关的配置更新，本质来上来说，和服务的关系并不大。但是传统的工程做法是在开发层面完成这些功能，这就会导致各种维护上的问题，而且还会受到特定语言和编程框架的约束和限制。\n设计的重点：\n进程间通讯机制是这个设计模式的重点 服务协议方面，也请使用标准统一的方式。这里有两层协议，一个是 Sidecar 到 service 的内部协议，另一个是 Sidecar 到远端 Sidecar 或 service 的外部协议。 使用这样的模式，需要在服务的整体打包、构建、部署、管控、运维上设计好。 等等 适用的场景：\n把控制和逻辑分离，标准化控制面上的动作和技术，从而提高系统整体的稳定性和可用性。也有利于分工——并不是所有的程序员都可以做好控制面上的开发的。 一个比较明显的场景是对老应用系统的改造和扩展。 不适用于什么样的场景：\n架构并不复杂的时候，不需要使用这个模式，直接使用 API Gateway 或者 Nginx 和 HAProxy 等即可。 服务间的协议不标准且无法转换。 不需要分布式的架构。 服务网格 Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。\nService Mesh 是一个基础设施。Service Mesh 是一个轻量的服务通讯的网络代理。Service Mesh 对于应用服务来说是透明无侵入的。Service Mesh 用于解耦和分离分布式系统架构中控制层面上的东西。\nService Mesh 开源软件是 Istio 和 Linkerd，它们都可以在 Kubernetes 中集成。当然，还有一个新成员 Conduit，它是由 Linkerd 的作者出来自己搞的，由 Rust 和 Go 写成的。Rust 负责数据层面，Go 负责控制面。号称吸取了很多 Linkerd 的 Scala 的教训，比 Linkerd 更快，还轻，更简单。\n首先，边车模式进化的下一阶段，就是把它的功能标准化成一个集群，其结果就是服务网格。它在分布式系统中的地位，类似于七层网络模型中的传输层协议，而服务本身则只需要关心业务逻辑，因此类似于应用层协议。然后，我介绍了几个实现了服务网格的开源软件。\n网关模式 我们讲了 Sidecar 和 Service Mesh 这两种设计模式，它们都是在不侵入业务逻辑的情况下，把控制面（control plane）和数据面（data plane）的处理解耦分离。但是这两种模式都让我们的运维成本变得特别大，因为每个服务都需要一个 Sidecar，这让本来就复杂的分布式系统的架构就更为复杂和难以管理了。\n在谈 Service Mesh 的时候，我们提到了 Gateway。我个人觉得并不需要为每个服务的实例都配置上一个 Sidecar。其实，一个服务集群配上一个 Gateway 就可以了，或是一组类似的服务配置上一个 Gateway。 这样一来，Gateway 方式下的架构，可以细到为每一个服务的实例配置一个自己的 Gateway，也可以粗到为一组服务配置一个，甚至可以粗到为整个架构配置一个接入的 Gateway。于是，整个系统架构的复杂度就会变得简单可控起来。 网关模式设计 非常类似 阿里 Aserver. 功能：\n请求路由。 服务注册。 负载均衡。 弹力设计。 安全方面。SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。 设计重点:\n高性能 高可用 集群化。 自己可以同步信息。 服务化。网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。 持续化。比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。 高扩展。Nginx 那样通过 Module；像 AWS Lambda 那样的方式； 运维方面：\n业务松耦合，协议紧耦合。 应用监视，提供分析数据。 用弹力设计保护后端服务。 DevOps Gateway、Sidecar 和 Service Mesh Sidecar Service Mesh Gateway 用途 Sidecar 的方式主要是用来改造已有服务。 Sidecar 在架构中越来越多时，需要我们对 Sidecar 进行统一的管理。像一个服务的 PaaS 平台。 Service Mesh 的架构和部署太过于复杂，会让我们运维层面上的复杂度变大。 简易 总而言之，我觉得 Gateway 的方式比 Sidecar 和 Service Mesh 更好。当然，具体问题还要具体分析。\n部署升级策略 一般来说，有如下几种：\n停机部署（Big Bang / Recreate） 蓝绿部署（Blue/Green /Stage）：部署好新版本后，把流量从老服务那边切过来。 滚动部署（Rolling Update / Ramped）： 一点一点地升级现有的服务。 灰度部署（Canary）：把一部分用户切到新版本上来，然后看一下有没有问题。如果没有问题就继续扩大升级，直到全部升级完成。 AB 测试（A/B Testing）：同时上线两个版本，然后做相关的比较。 总结： 部署应用有很多种方法，实际采用哪种方式取决于需求和预算。 当发布到开发或者模拟环境时，停机或者滚动部署是一个好选择，因为干净和快速。 当发布到生产环境时，滚动部署或者蓝绿部署通常是一个好选择，但新平台的主流程测试是必须的。\n蓝绿部署也不错，但需要额外的资源。如果应用缺乏测试或者对软件的功能和稳定性影响缺乏信心，那么可以使用金丝雀部署或者 AB 测试发布。如果业务需要根据地理位置、语言、操作系统或者浏览器特征等参数来给一些特定的用户测试，那么可以采用 AB 测试技术。 ","permalink":"http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1-%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1/","summary":"分布式锁 场景： 我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。分布式环境下， 这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。\n特点： 安全性（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）。 避免死锁：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。 容错性：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。\n设计： 我是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。 一般可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务。\n需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。 超时时间。 分布式锁服务应该是高可用的，而且是需要持久化的。 要提供非阻塞方式的锁服务。 还要考虑锁的可重入性。 具体实现 redis：\nSET resource_name my_random_value NX PX 30000 if redis.call(\u0026#34;get\u0026#34;,KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;,KEYS[1]) else return 0 end 问题： 解决方案： 乐观锁，版本号递增；\n锁服务的时候，单调递增的版本号； 写数据的时候也需要增加版本号； 数据库保存版本号， 对情况进行校验； 从乐观锁到 CAS 数据库中也保留着版本号 ， 可以使用 乐观锁处理(fence token)； UPDATE table_name SET xxx = #{xxx}, version=version+1 where version =#{version}; 数据库那边一般会用 timestamp 时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。","title":"分布式关键设计 管理设计"},{"content":"隔离设计 按服务的种类来做分离： 比如： 我们将系统分成了用户、商品、社区三个板块。 不好： 如果我们需要同时获得多个板块的数据，那么就需要调用多个服务，这会降低性能。注意，这里性能降低指的是响应时间，而不是吞吐量（相反，在这种架构下，吞吐量可以得到提高）。 一般： 很多： 这样的系统通常会引入大量的异步处理模型。\n按用户的请求来做分离 多租户 ： 我们将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。 完全独立的设计。每个租户有自己完全独立的服务和数据。 独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。 共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。 分析 如果使用完全独立的方案，在开发实现上和资源隔离度方面会非常好，然而，成本会比较高，计算资源也会有一定的浪费。如果使用完全共享的方案，在资源利用和成本上会非常好，然而，开发难度非常大，而且数据和资源隔离非常不好。\n隔离设计的重点 我们需要定义好隔离业务的大小和粒度，过大和过小都不好。这需要认真地做业务上的需求和系统分析。 无论是做系统板块还是多租户的隔离，你都需要考虑系统的复杂度、成本、性能、资源使用的问题，找到一个合适的均衡方案，或是分布实施的方案尤其重要，这其中需要你定义好要什么和不要什么。因为，我们不可能做出一个什么都能满足的系统。 隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。 不要忘记了分布式系统中的运维的复杂度的提升，要能驾驭得好的话，还需要很多自动化运维的工具，尤其是使用像容器或是虚拟机这样的虚拟化技术可以帮助我们更方便地管理，和对比资源更好地利用。否则做出来了也管理不好。 最后，你需要一个非常完整的能够看得到所有服务的监控系统，这点非常重要。 异步通讯设计 同步调用虽然让系统间只耦合于接口，而且实时性也会比异步调用要高，但是我们也需要知道同步调用会带来如下几个问题。\n同步调用需要被调用方的吞吐不低于调用方的吞吐。 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。 同步调用只能是一对一的，很难做到一对多。 同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。 异步通讯的三种方式 请求响应式。 在这种情况下，发送方（sender）会直接请求接收方（receiver），被请求方接收到请求后，直接返回——收到请求，正在处理。对于返回结果，有两种方法，一种是发送方时不时地去轮询一下，问一下干没干完。另一种方式是发送方注册一个回调方法，也就是接收方处理完后回调请求方。 通过订阅的方式。 这种情况下，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。 通过 Broker 的机制。 所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。 事件驱动设计 事件驱动最好是使用 Broker 方式，服务间通过交换消息来完成交流和整个流程的驱动。 事件驱动方式的好处\n服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。 服务的开发、测试、运维，以及故障处理都是高度隔离的。 服务间通过事件关联，所以服务间是不会相互 block 的。 在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。 服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。 坏处：\n业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。 事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。 事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。 幂等性设计 订单创建接口，第一次调用超时了，然后调用方重试了一次。是否会多创建一笔订单？\n两种处理方式。\n超时下游系统提供相应的查询接口。 通过幂等性的方式。 对于第一种方式，需要对方提供一个查询接口来做配合。而第二种方式则需要下游的系统提供支持幂等性的交易接口。\n唯一 ID 绍一个 Twitter 的开源项目 Snowflake 具体的方式 对于幂等性的处理流程来说，说白了就是要过滤一下已经收到的交易。要做到这个事，我们需要一个存储来记录收到的交易。\n于是，当收到交易请求的时候，我们就会到这个存储中去查询。如果查找到了，那么就不再做查询了，并把上次做的结果返回。如果没有查到，那么我们就记录下来。\n但是，上面这个流程有个问题。因为绝大多数请求应该都不会是重新发过来的，所以让 100% 的请求都到这个存储里去查一下，这会导致处理流程变得很慢。所以，最好是当这个存储出现冲突的时候会报错。也就是说，我们收到交易请求后，直接去存储里记录这个 ID（相对于数据的 Insert 操作），如果出现 ID 冲突了的异常，那么我们就知道这个之前已经有人发过来了，所以就不用再做了。比如，数据库中你可以使用 insert into … values … on DUPLICATE KEY UPDATE … 这样的操作。\n对于更新的场景来说，如果只是状态更新，可以使用如下的方式。如果出错，要么是非法操作，要么是已被更新，要么是状态不对，总之多次调用是不会有副作用的。update table set status = “paid” where id = xxx and status = “unpaid”;\n服务状态 所谓“状态”，就是为了保留程序的一些数据或是上下文。\n程序调用的结果。 服务组合下的上下文。 服务的配置。\n无状态的服务 Stateless 为了做出无状态的服务，我们通常需要把状态保存到其他的地方。 比如，不太重要的数据可以放到 Redis 中，重要的数据可以放到 MySQL 中，或是像 ZooKeeper/Etcd 这样的高可用的强一致性的存储中，或是分布式文件系统中。 于是，我们为了做成无状态的服务，会导致这些服务需要耦合第三方有状态的存储服务。一方面是有依赖，另一方面也增加了网络开销，导致服务的响应时间也会变慢。所以，第三方的这些存储服务也必须要做成高可用高扩展的方式。 而且，为了减少网络开销，还需要在无状态的服务中增加缓存机制。然而，下次这个用户的请求并不一定会在同一台机器，所以，这个缓存会在所有的机器上都创建，也算是一种浪费吧。\n有状态的服务 Stateful 补偿事务 分布式系统有一个比较明显的问题就是，一个业务流程需要组合一组服务。这样的事情在微服务下就更为明显了，因为这需要业务上一致性的保证。也就是说，如果一个步骤失败了，那么要么回滚到以前的服务调用，要么不断重试保证所有的步骤都成功。\nACID 和 BASE 传统关系型数据库系统的事务都有 ACID 属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 Basic Availability：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。Soft-state：软状态。它是我们前面的“有状态”和“无状态”的服务的一种中间状态。也就是说，为了提高性能，我们可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。Eventual Consistency：最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。\nBASE 系统是允许或是容忍系统出现暂时性问题的，这样一来，我们的系统就能更有弹力。因为我们知道，在分布式系统的世界里，故障是不可避免的，我们能做的就是把故障处理当成功能写入代码中，这就是 Design for Failure。\n买书： ACID 的玩法就是，大家在买同一本书的过程中，每个用户的购买请求都需要把库存锁住，等减完库存后，把锁释放出来，后续的人才能进行购买。于是，在 ACID 的玩法下，我们在同一时间不可能有多个用户下单，我们的订单流程需要有排队的情况，这样一来，我们就不可能做出性能比较高的系统来。\n用户库存， 真实库存 。 亚马逊的方式， 要根据用户的地址去不同的仓库查看库存，很耗时。 异步邮件发送。 业务补偿 我们知道，在很多情况下，我们是无法做到强一致的 ACID 的。特别是我们需要跨多个系统的时候，而且这些系统还不是由一个公司所提供的。\n一般来说，业务的事务补偿都是需要一个工作流引擎的。亚马逊是一个超级喜欢工作流引擎的公司，这个工作流引擎把各式各样的服务给串联在一起，并在工作流上做相应的业务补偿，整个过程设计成为最终一致性的。\n一个好的业务补偿机制需要做到下面这几点。\n要能清楚地描述出要达到什么样的状态（比如：请假、机票、酒店这三个都必须成功，租车是可选的），以及如果其中的条件不满足，那么，我们要回退到哪一个状态。这就是所谓的整个业务的起始状态定义。 当整条业务跑起来的时候，我们可以串行或并行地做这些事。对于旅游订票是可以并行的，但是对于网购流程（下单、支付、送货）是不能并行的。总之，我们的系统需要努力地通过一系列的操作达到一个我们想要的状态。如果达不到，就需要通过补偿机制回滚到之前的状态。这就是所谓的状态拟合。 对于已经完成的事务进行整体修改，可以考虑成一个修改事务。 业务补偿的设计重点 业务补偿主要做两件事。\n努力地把一个业务流程执行完成。 如果执行不下去，需要启动补偿机制，回滚业务流程。 把一个业务流程执行完成，需要这个流程中所涉及的服务方支持幂等性。并且在上游有重试机制。 我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。 补偿的业务逻辑和流程不一定非得是严格反向操作。有时候可以并行，有时候可以串行，可能会更简单。 业务补偿的业务逻辑是强业务相关的，很难做成通用的。 重试 场景 “重试”的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试。 设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。 一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP 的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。\n策略 都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。 ，Exponential Backoff 的策略，也就是所谓的“指数级退避”。（TCP 拥塞控制） Spring 的重试策略。个单独实现重试功能的项目 设计的重点 要确定什么样的错误下需要重试； 重试的时间和重试的次数。 不同场景可能需要不同的策略。 （比如流控，那么应该使用指数退避的方式，以避免造成更多的流量。） 如果超过重试次数，或是一段时间，那么重试就没有意义了。 重试还需要考虑被调用方是否有幂等的设计。 对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。 记录请求。 熔断设计 熔断机制这个词对你来说肯定不陌生，它的灵感来源于我们电闸上的“保险丝”。 在我们的分布式系统设计中，也应该有这样的方式。前面说过重试机制，如果错误太多，或是在短时间内得不到修复，那么我们重试也没有意义了，此时应该开启我们的熔断操作，尤其是后端太忙的时候，使用熔断设计可以保护后端不会过载。 熔断设计是受了电路设计中保险丝的启发，其需要实现三个状态：闭合、断开和半开，分别对应于正常、故障和故障后检测故障是否已被修复的场景，并介绍了 Netflix 的 Hystrix 对熔断的实现。\n限流设计 目的： 保护系统不会在过载的情况下出现问题，我们就需要限流。\n限流策略 拒绝服务。把多出来的请求拒绝掉 服务降级。关闭或是把后端服务做降级处理。 特权请求。 vip 延时处理。 短暂的峰值。 弹性伸缩。 数据库压力过大，没用。 限流的实现方式 计数器方式，\n队列算法（优先级），漏桶法，令牌桶法。 基本原理都是 队列缓存。 固定窗口，滑动窗口： (sentinel) https://ata.alibaba-inc.com/articles/249558 环形数组 LeapArray 来统计实时的秒级指标数据. 写多于读的高并发场景。 环形数组：\n构建 数组长度， 数据的时间 。 每个窗口时间 定位： 时间戳/ 窗口时间 % 数据长度 。 窗口开始 = 时间戳 - 时间戳%时间间隔 判断当前窗口 ？ 为空，直接创建新的窗口， cas 不为空， old 窗口时间起始时间 = 当前 ， 直接返回； 部位空， old 窗口时间起始时间 ！= 当前， reset 当前窗口。 根据响应时间自动限流： 就是需要设置一个确定的限流值。这就要求我们每次发布服务时都做相应的性能测试，找到系统最大的性能值。 很多时候， 很难给出一个合适的值。\n实际情况下，很多服务会依赖于数据库。 数据类型， 数据量。 所以，不同的用户请求，会对不同的数据集进行操作。就算是相同的请求，可能数据集也不一样，比如，现在很多应用都会有一个时间线 Feed 流，不同的用户关心的主题人人不一样，数据也不一样。 不同的 API 有不同的性能。我们要在线上为每一个 API 配置不同的限流值，这点太难配置，也很难管理。 而且，现在的服务都是能自动化伸缩的，不同大小的集群的性能也不一样，所以，在自动化伸缩的情况下，我们要动态地调整限流的阈值，这点太难做到了。 如何设计？ 如何做？ 不再设定一个特定的流控值，而是能够动态地感知系统的压力来自动化地限流。 典范是 TCP 协议的拥塞控制的算法。 具体： 我们记录下每次调用后端请求的响应时间，然后在一个时间区间内（比如，过去 10 秒）的请求计算一个响应时间的 P90 或 P99 值，也就是把过去 10 秒内的请求的响应时间排个序，然后看 90% 或 99% 的位置是多少。\nP90 或 P99 值： 消耗内存和 CPU。 1) 采样 。 动态流控需要像 TCP 那样，你需要记录一个当前的 QPS。如果发现后端的 P90/P99 响应太慢，那么就可以把这个 QPS 减半，然后像 TCP 一样走慢启动的方式，直接到又开始变慢，然后减去 1/4 的 QPS，再慢启动，然后再减去 1/8 的 QPS。\n限流的设计要点 目的：\n为了向用户承诺 SLA。 多租户的情况下，某一用户把资源耗尽。 应对突发的流量 节约成本。我们不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。 设计上，我们还要有以下的考量。\n限流模块性能必须好，而且对流量的变化也是非常灵敏的，否则太过迟钝的限流，系统早因为过载而挂掉了。 限流应该有个手动的开关，这样在应急的时候，可以手动操作。 当限流发生时，应该有个监控事件通知。 运维跟进。 自动扩容。 当限流发生时，对于拒掉的请求，我们应该返回一个特定的限流错误码。 看到这些错误码， 调整发送速度，或走重试机制。 限流应该让后端的服务感知到。 比如： 在协议头中塞进一个标识 。 看到标识， 可以降级。 降级 所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。暂时牺牲掉一些东西，以保障整个系统的平稳运行。\n一般的降级：\n降低一致性。从强一致性变成最终一致性。 停止次要功能。停止访问不重要的功能，从而释放出更多的资源。 简化功能。把一些功能简化掉，比如，简化业务流程，或是不再返回全量数据，只返回部分数据。 我们现在的降级分为功能降级和服务降级。我们目前将降级开关放到配置中心。 一、功能降级 1、通过降级开关控制功能可用不可用，一般为页面和按钮 2、简化业务操作流程，当降级后简化业务操作步骤，快速完成业务操作 二、服务降级 1、读降级，降级前会读缓存，缓存中不存在的话读数据库，降级后读缓存，缓存中不存在的话，返回默认值，不再读数据库 2、写降级，将之前的同步写数据库降级为先写缓存，然后异步写库 3、服务调用降级，之前两个系统模块通过 mq 来交互，当 mq 消息积压或 mq 宕机出问题后，降级为服务直接调用\n总结 弹力设计总图 服务不是单点。\n负载均衡 + 服务健康检查。 （nginx 或 haproxy) 服务发现 + 动态路由 + 服务健康检查。 (zookeeper + consul) 自动化运维，Kubernetes 服务调度、伸缩和故障迁移. 隔离我们的业务，要隔离我们的服务我们就需要对服务进行解耦和拆分\nbulkheads 模式：业务分片 、用户分片、数据库拆分。 自包含系统：所谓自包含的系统是从单体到微服务的中间状态，其把一组密切相关的微服务给拆分出来，只需要做到没有外部依赖就行。 异步通讯：服务发现、事件驱动、消息队列、业务工作流。 自动化运维：需要一个服务调用链和性能监控的监控系统。 接受失败的相关处理设计，也就是所谓的容错设计\n错误方面：调用重试 + 熔断 + 服务的幂等性设计。 一致性方面：强一致性使用两阶段提交、最终一致性使用异步通讯方式。 流控方面：使用限流 + 降级技术。 自动化运维方面：网关流量调度，服务监控。 有三大块的东西\n冗余服务。通过冗余服务的复本数可以消除单点故障。 服务解耦。通过解耦可以做到把业务隔离开来，不让服务受影响，这样就可以有更好的稳定性。 服务容错。服务容错方面，需要有重试机制，重试机制会带来幂等操作，对于服务保护来说，熔断，限流，降级都是为了保护整个系统的稳定性，并在可用性和一致性方面在出错的情况下做一部分的妥协。 当然，除了这一切的架构设计外，你还需要一个或多个自动运维的工具。否则，如果是人肉运维的话，那么在故障发生的时候，不能及时地做出运维决定，也就空有这些弹力设计了。比如：监控到服务性能不够了，就自动或半自动地开始进行限流或降级。\n","permalink":"http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1-%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1/","summary":"隔离设计 按服务的种类来做分离： 比如： 我们将系统分成了用户、商品、社区三个板块。 不好： 如果我们需要同时获得多个板块的数据，那么就需要调用多个服务，这会降低性能。注意，这里性能降低指的是响应时间，而不是吞吐量（相反，在这种架构下，吞吐量可以得到提高）。 一般： 很多： 这样的系统通常会引入大量的异步处理模型。\n按用户的请求来做分离 多租户 ： 我们将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。 完全独立的设计。每个租户有自己完全独立的服务和数据。 独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。 共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。 分析 如果使用完全独立的方案，在开发实现上和资源隔离度方面会非常好，然而，成本会比较高，计算资源也会有一定的浪费。如果使用完全共享的方案，在资源利用和成本上会非常好，然而，开发难度非常大，而且数据和资源隔离非常不好。\n隔离设计的重点 我们需要定义好隔离业务的大小和粒度，过大和过小都不好。这需要认真地做业务上的需求和系统分析。 无论是做系统板块还是多租户的隔离，你都需要考虑系统的复杂度、成本、性能、资源使用的问题，找到一个合适的均衡方案，或是分布实施的方案尤其重要，这其中需要你定义好要什么和不要什么。因为，我们不可能做出一个什么都能满足的系统。 隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。 不要忘记了分布式系统中的运维的复杂度的提升，要能驾驭得好的话，还需要很多自动化运维的工具，尤其是使用像容器或是虚拟机这样的虚拟化技术可以帮助我们更方便地管理，和对比资源更好地利用。否则做出来了也管理不好。 最后，你需要一个非常完整的能够看得到所有服务的监控系统，这点非常重要。 异步通讯设计 同步调用虽然让系统间只耦合于接口，而且实时性也会比异步调用要高，但是我们也需要知道同步调用会带来如下几个问题。\n同步调用需要被调用方的吞吐不低于调用方的吞吐。 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。 同步调用只能是一对一的，很难做到一对多。 同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。 异步通讯的三种方式 请求响应式。 在这种情况下，发送方（sender）会直接请求接收方（receiver），被请求方接收到请求后，直接返回——收到请求，正在处理。对于返回结果，有两种方法，一种是发送方时不时地去轮询一下，问一下干没干完。另一种方式是发送方注册一个回调方法，也就是接收方处理完后回调请求方。 通过订阅的方式。 这种情况下，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。 通过 Broker 的机制。 所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。 事件驱动设计 事件驱动最好是使用 Broker 方式，服务间通过交换消息来完成交流和整个流程的驱动。 事件驱动方式的好处\n服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。 服务的开发、测试、运维，以及故障处理都是高度隔离的。 服务间通过事件关联，所以服务间是不会相互 block 的。 在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。 服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。 坏处：\n业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。 事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。 事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。 幂等性设计 订单创建接口，第一次调用超时了，然后调用方重试了一次。是否会多创建一笔订单？\n两种处理方式。\n超时下游系统提供相应的查询接口。 通过幂等性的方式。 对于第一种方式，需要对方提供一个查询接口来做配合。而第二种方式则需要下游的系统提供支持幂等性的交易接口。","title":"分布式关键设计 弹力设计"},{"content":"分布式系统中一些比较关键的设计模式，其中包括容错、性能、管理等几个方面。\n容错设计又叫弹力设计，其中着眼于分布式系统的各种“容忍”能力，包括容错能力（服务隔离、异步调用、请求幂等性）、可伸缩性（有 / 无状态的服务）、一致性（补偿事务、重试）、应对大流量的能力（熔断、降级）。可以看到，在确保系统正确性的前提下，系统的可用性是弹力设计保障的重点。 管理篇会讲述一些管理分布式系统架构的一些设计模式，比如网关方面的，边车模式，还有一些刚刚开始流行的，如 Service Mesh 相关的设计模式。 性能设计篇会讲述一些缓存、CQRS、索引表、优先级队列、业务分片等相关的架构模式。\n故障原因 网络问题。网络链接出现问题，网络带宽出现拥塞…… 性能问题。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足…… 安全问题。被网络攻击，如 DDoS 等。 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题…… 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……\n","permalink":"http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/","summary":"分布式系统中一些比较关键的设计模式，其中包括容错、性能、管理等几个方面。\n容错设计又叫弹力设计，其中着眼于分布式系统的各种“容忍”能力，包括容错能力（服务隔离、异步调用、请求幂等性）、可伸缩性（有 / 无状态的服务）、一致性（补偿事务、重试）、应对大流量的能力（熔断、降级）。可以看到，在确保系统正确性的前提下，系统的可用性是弹力设计保障的重点。 管理篇会讲述一些管理分布式系统架构的一些设计模式，比如网关方面的，边车模式，还有一些刚刚开始流行的，如 Service Mesh 相关的设计模式。 性能设计篇会讲述一些缓存、CQRS、索引表、优先级队列、业务分片等相关的架构模式。\n故障原因 网络问题。网络链接出现问题，网络带宽出现拥塞…… 性能问题。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足…… 安全问题。被网络攻击，如 DDoS 等。 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题…… 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……","title":"分布式关键设计概述"},{"content":" 此系列主要是阅读陈皓极客时间的课程《左耳听风》的分布式理论笔记。非常系统的讲解分布式系统的方方面面。\n分布式 主要是两个：\n增大系统容量 加强系统可用 另外：\n系统模块化，重用性提高 开发和发布 并行，更快 系统扩展性 团队协作 微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线……还有像 Kubernetes 提供的各式各样的部署和调度方式。\n没有这些 PaaS 层的支撑，微服务也是很难被管理和运维的。\n技术栈 提供系统的性能 缓存系统。 从前端的浏览器，到网络，服务，数据库，文件系统，磁盘和 CPU。 负载均衡技术。 是水平扩展的关键技术。 异步调用。 数据分区和数据镜像。 数据分区是把数据按一定方式分成多个区。每个不同的数据区分担不同区的流量。 数据镜像。 把一个数据库镜像 成多分一样的数据。 提高架构的稳定性 服务拆分。两个目的： 隔离故障，重用。 引入 服务依赖的问题。 服务冗余。 目的： 去除单点故障，并可以弹性伸缩和故障转移。 限流降级。 系统扛不住压力。 只能通过限流 ， 拒绝一部分用户。功能降级，停掉一部分服务。 高可用架构。 比如，多租户隔离，灾备多活。 冗余 不出单点故障。 高可用运维。 DevOps 中的 CI/CD（持续集成/持续部署）。 一个良好的运维应该是一条很流畅的发布管线。其中做了足够的自动化测试，还可以做灰度发布，以及线上系统的自动化控制。 分布式系统的关键技术 全栈系统监控 服务 / 资源调度 流量调度； 状态/ 数据调度； 开发和运维的自动化。 ","permalink":"http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%89%8D%E8%A8%80/","summary":" 此系列主要是阅读陈皓极客时间的课程《左耳听风》的分布式理论笔记。非常系统的讲解分布式系统的方方面面。\n分布式 主要是两个：\n增大系统容量 加强系统可用 另外：\n系统模块化，重用性提高 开发和发布 并行，更快 系统扩展性 团队协作 微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线……还有像 Kubernetes 提供的各式各样的部署和调度方式。\n没有这些 PaaS 层的支撑，微服务也是很难被管理和运维的。\n技术栈 提供系统的性能 缓存系统。 从前端的浏览器，到网络，服务，数据库，文件系统，磁盘和 CPU。 负载均衡技术。 是水平扩展的关键技术。 异步调用。 数据分区和数据镜像。 数据分区是把数据按一定方式分成多个区。每个不同的数据区分担不同区的流量。 数据镜像。 把一个数据库镜像 成多分一样的数据。 提高架构的稳定性 服务拆分。两个目的： 隔离故障，重用。 引入 服务依赖的问题。 服务冗余。 目的： 去除单点故障，并可以弹性伸缩和故障转移。 限流降级。 系统扛不住压力。 只能通过限流 ， 拒绝一部分用户。功能降级，停掉一部分服务。 高可用架构。 比如，多租户隔离，灾备多活。 冗余 不出单点故障。 高可用运维。 DevOps 中的 CI/CD（持续集成/持续部署）。 一个良好的运维应该是一条很流畅的发布管线。其中做了足够的自动化测试，还可以做灰度发布，以及线上系统的自动化控制。 分布式系统的关键技术 全栈系统监控 服务 / 资源调度 流量调度； 状态/ 数据调度； 开发和运维的自动化。 ","title":"分布式理论前言"},{"content":"前言 博客在大学时代就建立了，主要使用 github page 的能力搭建。刚开始使用 hexo , 虽然具有不错的能力。但总归在构建编译效率比较低，影响心情书写内容及写作效率。\nhugo 很早之前就注意到 hugo，这是非常高效的博客工具（其主要使用 go 语言编写）。 最终决定迁移到 hugo。 简单的对比如下：\nhexo hugo 社区支持 好 好 编译速度 快 慢 主题 少 多且功能完善 小结 ：在 github star 的维度上看，hugo 已经超越 hexo。 虽然在主题这个维度，很多主题功能都还在在完善； 不可忽视的是用户体验， hugo 的构建编译速度很快，这个是我个人最看重的点。 通过社区的反应来看，未来 hugo 会有更好的发展。\n迁移 迁移的过程还是有点痛苦。 一方面，毕竟是一个新的东西，需要熟悉一下。另外，旧的文章也需要迁移到新的模式下，还是有点麻烦的。\n在主题使用方面使用的是 PaperMod, 该主题社区使用的比较多的，并且维护积极。\n后续 最近在整理过去几年的内容，发现记录了很多各种各样的知识和体会，还是很欣慰的。 不过使用了很多笔记软件（从印象 -\u0026gt; 为知 -\u0026gt; 语雀 -\u0026gt; Fsnotes) ，这块需要大量的时间整理，这个是必须要做的。 后面，也会将一些有价值内容及体会发布到博客上。 主要两个原因：\n一方面 写作整理的过程，是一个重新认识体会的重要时刻; 另一个方面，也可以记录成长的过程。 ","permalink":"http://blog.chalme.top/posts/think/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/","summary":"前言 博客在大学时代就建立了，主要使用 github page 的能力搭建。刚开始使用 hexo , 虽然具有不错的能力。但总归在构建编译效率比较低，影响心情书写内容及写作效率。\nhugo 很早之前就注意到 hugo，这是非常高效的博客工具（其主要使用 go 语言编写）。 最终决定迁移到 hugo。 简单的对比如下：\nhexo hugo 社区支持 好 好 编译速度 快 慢 主题 少 多且功能完善 小结 ：在 github star 的维度上看，hugo 已经超越 hexo。 虽然在主题这个维度，很多主题功能都还在在完善； 不可忽视的是用户体验， hugo 的构建编译速度很快，这个是我个人最看重的点。 通过社区的反应来看，未来 hugo 会有更好的发展。\n迁移 迁移的过程还是有点痛苦。 一方面，毕竟是一个新的东西，需要熟悉一下。另外，旧的文章也需要迁移到新的模式下，还是有点麻烦的。\n在主题使用方面使用的是 PaperMod, 该主题社区使用的比较多的，并且维护积极。\n后续 最近在整理过去几年的内容，发现记录了很多各种各样的知识和体会，还是很欣慰的。 不过使用了很多笔记软件（从印象 -\u0026gt; 为知 -\u0026gt; 语雀 -\u0026gt; Fsnotes) ，这块需要大量的时间整理，这个是必须要做的。 后面，也会将一些有价值内容及体会发布到博客上。 主要两个原因：\n一方面 写作整理的过程，是一个重新认识体会的重要时刻; 另一个方面，也可以记录成长的过程。 ","title":"迁移博客"},{"content":" 此文章主要整理了 macos 个人常用的软件。软件分为 appstore 和 brew两个来源。 brew软件来源一般都是开源的项目。\nappstore 工具 Justfocus 番茄工作\nCaffeinated 避免 mac 睡眠\niShot 截图软件，功能齐全。 也可以用 xnip 等代替。\nbrew 资源 软件 clashx github\nClashX 旨在提供一个简单轻量化的代理客户端\ncalibre github\nThe official source code repository for the calibre ebook manager\nmotrix A full-featured download manager\nlisten1 github\nListen 1 可以搜索和播放来自多个主流音乐网站的歌曲，让你的曲库更全面。并支持收藏功能，方便的创建自己的歌单。\nNetNewsWire github\nIt’s a free and open source feed reader for macOS and iOS.\namethyst github\nAutomatic tiling window manager for macOS à la xmonad.\nrectangle github\nMove and resize windows on macOS with keyboard shortcuts and snap areas\naerial github\nApple TV Aerial Screensaver for Mac. 屏幕保护程序\nblurred github\nA macOS utility that helps reduce distraction by dimming your inactive noise.（专注当前的 app）\nhidden github An ultra-light MacOS utility that helps hide menu bar icons\ncheatsheet official\nJust hold the ⌘-Key a bit longer to get a list of all active shortcuts of the current application. It\u0026rsquo;s as simple as that.(展示当前 App 快捷键或修改）\nclean-me github\nA macOS system analyser and cleaner\neul github\n🖥️ macOS status monitoring app written in SwiftUI.\nkeka github\nThe macOS file archiver\nmonitorcontrol github\n🖥 Control your display\u0026rsquo;s brightness \u0026amp; volume on your Mac as if it was a native Apple Display. Use Apple Keyboard keys or custom shortcuts. Shows the native macOS OSDs.(控制显示器)\nmaccy github\nLightweight clipboard manager for macOS\nuPic github\n📤uPic is a native, powerful, beautiful and simple picture and file upload tool for macOS.\n笔记 fsnotes github\nNotes manager for macOS/iOS\nnotable github\nThe Markdown-based note-taking app that doesn\u0026rsquo;t suck.\n开发 AnotherRedisDesktopManager github\nintellij-idea iterm2 syncthing github\nOpen Source Continuous File Synchronization\nvimrc github\ngit clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime sh ~/.vim_runtime/install_awesome_vimrc.sh 其他 swiftbar github\nPowerful macOS menu bar customization tool\nHammerspoon github\nThis is a tool for powerful automation of OS X. At its core, Hammerspoon is just a bridge between the operating system and a Lua scripting engine.\nCakebrew Manage your Homebrew formulas with style using Cakebrew. github\niptv https://github.com/iptv-org/iptv\ncommand fzf fzf is a general-purpose command-line fuzzy finder.\nwrk github\na HTTP benchmarking tool\nmkcert github\nA simple zero-config tool to make locally trusted development certificates with any names you\u0026rsquo;d like.\nbrew install clashx; brew install netnewswire; brew install calibre; brew install motrix; brew install listen1; brew install netnewswire; brew install amethyst; brew install rectangle; brew install aerial; brew install blurred; brew install hiddenbar; brew install cheatsheet; brew install clean-me; brew install eul; brew install fsnotes; brew install keka; brew install maccy; brew install monitorcontrol; brew install rectangle; brew install upic; brew install another-redis-desktop-manager; brew install cakebrew; brew install iterm2; brew install intellij-idea; brew install syncthing; brew install swiftbar; brew install hammerspoon; brew install fzf; brew install wrk; ","permalink":"http://blog.chalme.top/posts/macos/macos-software/","summary":"此文章主要整理了 macos 个人常用的软件。软件分为 appstore 和 brew两个来源。 brew软件来源一般都是开源的项目。\nappstore 工具 Justfocus 番茄工作\nCaffeinated 避免 mac 睡眠\niShot 截图软件，功能齐全。 也可以用 xnip 等代替。\nbrew 资源 软件 clashx github\nClashX 旨在提供一个简单轻量化的代理客户端\ncalibre github\nThe official source code repository for the calibre ebook manager\nmotrix A full-featured download manager\nlisten1 github\nListen 1 可以搜索和播放来自多个主流音乐网站的歌曲，让你的曲库更全面。并支持收藏功能，方便的创建自己的歌单。\nNetNewsWire github\nIt’s a free and open source feed reader for macOS and iOS.\namethyst github\nAutomatic tiling window manager for macOS à la xmonad.","title":"Macos Software"},{"content":"概述 sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n基础 -E -- use extended regular expressions -a -- delay opening files listed with w function -e -- specify sed commands to run -f -- add contents of file to commands to run -i -- edit files in-place, running scripts separately for each file -l -- make output line buffered -n -- suppress automatic printing of pattern space a,append 追加 i,insert 插入 d,delete 删除 s,substitution 替换 c,change 修改 y,transform 转换 替换 替换标记 s（substitution）默认情况下只替换每行中出现的第一处。使用替换标记（substitution flag）指定替换位置。替换标记在替换命令字符串之后设置。 s/pattern/replacement/flags 有4种可用的替换标记：\n数字，表明新文本将替换第几处模式匹配的地方； g，表明新文本将会替换所有匹配的文本； p，表明替换过的行要打印出来； w file，将替换的结果写到文件中。 替换字符 sed允许选择其他字符来作为替换命令中的字符串分隔符：\nsed \u0026#39;s!/bin/bash!/bin/csh!\u0026#39; /etc/passwd 使用地址 默认情况下，sed命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（line addressing）。\n以数字形式表示行区间 用文本模式来过滤出行 格式 [address]command 以数字形式表示行区间 sed \u0026#39;2s/dog/cat/\u0026#39; data1.txt sed \u0026#39;2,3s/dog/cat/\u0026#39; data1.txt sed \u0026#39;2,$s/dog/cat/\u0026#39; data1.txt 使用文本模式过滤器 sed编辑器允许指定文本模式来过滤出命令要作用的行 /pattern/command\nsed -n \u0026#39;/special/s/test/dog/p\u0026#39; data1.txt 命令组合 sed \u0026#39;2{ \u0026gt; s/fox/elephant/ \u0026gt; s/dog/cat/ \u0026gt; }\u0026#39; data1.txt 删除行 删除命令d删除匹配指定寻址模式的所有行。如果没有加入寻址模式，流中的所有文本行都会被删除。\nsed \u0026#39;1d\u0026#39; data1.txt sed \u0026#39;/spe/d\u0026#39; data1.txt 插入和附加文本 插入（insert）命令（i）会在指定行前增加一个新行； 附加（append）命令（a）会在指定行后增加一个新行。 sed \u0026#39;[address]command\\ new line\u0026#39; $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;i\\Test Line 1\u0026#39; Test Line 1 Test Line 2 $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;a\\Test Line 1\u0026#39; Test Line 2 Test Line 1 #在命令行上使用sed时，会看到次提示符来提醒输入新的行数据。必须在该行完成sed编辑器命令。 $ echo \u0026#34;Test Line 2\u0026#34; | sed \u0026#39;i\\ \u0026gt; Test Line 1\u0026#39; Test Line 1 Test Line 2 修改行 修改（change）命令(c)允许修改(替换)数据流中整行文本的内容.如果作用于地址区间，sed会用一行文本代替区间内的所有行，而非逐一替换。\nsed \u0026#39;1,2c\\ hello \u0026#39; data1.txt 转换命令 转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。转换命令格式如下: [address]y/inchars/outchars/\n回顾打印 3个命令也能用来打印数据流中的信息： p命令用来打印文本行； 等号（=）命令用来打印行号； l（小写的L）命令用来列出行。\n使用sed处理文件 写入文件 w命令用来向文件写入行 [address]w filename\n从文件读取数据 读取（read）命令（r）将一个独立文件中的数据插入到数据流中 [address]r filename\nhttps://jixiaocan.github.io/posts/cmd-sed/ https://markrepo.github.io/commands/2018/06/26/sed/ ","permalink":"http://blog.chalme.top/posts/linux/command/sed/","summary":"概述 sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为\u0026quot;pattern space\u0026quot;，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。\n基础 -E -- use extended regular expressions -a -- delay opening files listed with w function -e -- specify sed commands to run -f -- add contents of file to commands to run -i -- edit files in-place, running scripts separately for each file -l -- make output line buffered -n -- suppress automatic printing of pattern space a,append 追加 i,insert 插入 d,delete 删除 s,substitution 替换 c,change 修改 y,transform 转换 替换 替换标记 s（substitution）默认情况下只替换每行中出现的第一处。使用替换标记（substitution flag）指定替换位置。替换标记在替换命令字符串之后设置。 s/pattern/replacement/flags 有4种可用的替换标记：","title":"Sed"},{"content":"之前在逛博客的时候，发现 zsh 的一篇配置文档，用上十分爽。才过了没几天，又看到了 fish 这个 shell，确实感觉比 zsh 强。感觉好善变啊。 -_-!!不过确实好用！！！\nzsh 使用 (oh-my-zsh) 来提升体检，还是不错的，github 有 40000+的星\nfish（推荐） fish (Friendly Interactive Shell)\nfish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you\u0026rsquo;re looking for!\n为什么我喜欢 不需要过多配置，用户友好。 快，相比（过多配置的 zsh 来说） vi 模式支持 (Oh-my-zsh)的功能基本都支持 使用 Oh-my-fish来管理插件主题等等（和 oh-my-zsh)功能差不多\ntheme 我的主题 推荐 batman, es(目前我使用的主题) plugin z(类似 autojump 功能，根据历史快捷进入目录) re-search (向后搜索历史命令) 参考 zsh 1 2 3\n","permalink":"http://blog.chalme.top/posts/history/%E5%85%B3%E4%BA%8Eshell/","summary":"之前在逛博客的时候，发现 zsh 的一篇配置文档，用上十分爽。才过了没几天，又看到了 fish 这个 shell，确实感觉比 zsh 强。感觉好善变啊。 -_-!!不过确实好用！！！\nzsh 使用 (oh-my-zsh) 来提升体检，还是不错的，github 有 40000+的星\nfish（推荐） fish (Friendly Interactive Shell)\nfish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you\u0026rsquo;re looking for!","title":"关于shell"},{"content":"Iterator pattern(迭代器模式) 这个模式已经被整合入Java的Collection.在大多数场合下无需自己制造一个Iterator,只要将对象装入Collection中，直接使用Iterator进行对象遍历.更多\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.11-iterator/","summary":"Iterator pattern(迭代器模式) 这个模式已经被整合入Java的Collection.在大多数场合下无需自己制造一个Iterator,只要将对象装入Collection中，直接使用Iterator进行对象遍历.更多","title":"3.11 Iterator"},{"content":"Visitor pattern (访问者模式) 作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.\n在Java中,Visitor模式实际上是分离了collection结构中的元素和对这些元素进行操作的行为. 为何使用Visitor? Java的Collection(包括Vector和Hashtable)是我们最经常使用的技术,可是Collection好象是个黑色大染缸,本来有各种鲜明类型特征的对象一旦放入后,再取出时,这些类型就消失了.那么我们势必要用If来判断,如:\nIterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Collection) messyPrintCollection((Collection)o); else if (o instanceof String) System.out.println(\u0026#34;\u0026#39;\u0026#34;+o.toString()+\u0026#34;\u0026#39;\u0026#34;); else if (o instanceof Float) System.out.println(o.toString()+\u0026#34;f\u0026#34;); else System.out.println(o.toString()); } 在上例中,我们使用了 instanceof来判断 o的类型.\n很显然,这样做的缺点代码If else if 很繁琐.我们就可以使用Visitor模式解决它.\n如何使用Visitor? 针对上例,定义接口叫Visitable,用来定义一个Accept操作,也就是说让Collection每个元素具备可访问性.\n被访问者是我们Collection的每个元素Element,我们要为这些Element定义一个可以接受访问的接口(访问和被访问是互动的,只有访问者,被访问者如果表示不欢迎,访问者就不能访问),取名为Visitable，也可取名为Element。\npublic interface Visitable { public void accept(Visitor visitor); } 被访问的具体元素继承这个新的接口Visitable：\npublic class StringElement implements Visitable { private String value; public StringElement(String string) { value = string; } public String getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.visitString(this); } } 上面是被访问者是字符串类型，下面再建立一个Float类型的：\npublic class FloatElement implements Visitable { private Float value; public FloatElement(Float value) { this.value = value; } public Float getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.visitFloat(this); } } 我们设计一个接口visitor访问者，在这个接口中,有一些访问操作，这些访问操作是专门访问对象集合Collection中有可能的所有类，目前我们假定有三个行为：访问对象集合中的字符串类型；访问对象集合中的Float类型；访问对象集合中的对象集合类型。注意最后一个类型是集合嵌套，通过这个嵌套实现可以看出使用访问模式的一个优点。\n接口visitor访问者如下：\npublic interface Visitor { public void visitString(StringElement stringE); public void visitFloat(FloatElement floatE); public void visitCollection(Collection collection); } 访问者的实现:\npublic class ConcreteVisitor implements Visitor { //在本方法中,我们实现了对Collection的元素的成功访问 public void visitCollection(Collection collection) { Iterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Visitable) ((Visitable)o).accept(this); } ｝ public void visitString(StringElement stringE) { System.out.println(\u0026#34;\u0026#39;\u0026#34;+stringE.getValue()+\u0026#34;\u0026#39;\u0026#34;); } public void visitFloat(FloatElement floatE){ System.out.println(floatE.getValue().toString()+\u0026#34;f\u0026#34;); } } 在上面的visitCollection我们实现了对Collection每个元素访问,只使用了一个判断语句,只要判断其是否可以访问.\nStringElement只是一个实现，可以拓展为更多的实现，整个核心奥妙在accept方法中，在遍历Collection时，通过相应的accept方法调用具体类型的被访问者。这一步确定了被访问者类型，\n如果是StringElement，而StringElement则回调访问者的visiteString方法，这一步实现了行为操作方法。\n客户端代码：\nVisitor visitor = new ConcreteVisitor(); StringElement stringE = new StringElement(\u0026#34;I am a String\u0026#34;); visitor.visitString(stringE); Collection list = new ArrayList(); list.add(new StringElement(\u0026#34;I am a String1\u0026#34;)); list.add(new StringElement(\u0026#34;I am a String2\u0026#34;)); list.add(new FloatElement(new Float(12))); list.add(new StringElement(\u0026#34;I am a String3\u0026#34;)); visitor.visitCollection(list); 客户端代码中的list对象集合中放置了多种数据类型，对对象集合中的访问不必象一开始那样，使用instance of逐个判断，而是通过访问者模式巧妙实现了。\n至此,我们完成了Visitor模式基本结构.\n使用Visitor模式的前提 使用访问者模式是对象群结构中(Collection) 中的对象类型很少改变。\n在两个接口Visitor和Visitable中,确保Visitable很少变化,也就是说，确保不能老有新的Element元素类型加进来，可以变化的是访问者行为或操作，也就是Visitor的不同子类可以有多种,这样使用访问者模式最方便.\n如果对象集合中的对象集合经常有变化, 那么不但Visitor实现要变化，Visistable也要增加相应行为，GOF建议是,不如在这些对象类中直接逐个定义操作，无需使用访问者设计模式。\n但是在Java中，Java的Reflect技术解决了这个问题，因此结合reflect反射机制，可以使得访问者模式适用范围更广了。\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.10-visitor/","summary":"Visitor pattern (访问者模式) 作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.\n在Java中,Visitor模式实际上是分离了collection结构中的元素和对这些元素进行操作的行为. 为何使用Visitor? Java的Collection(包括Vector和Hashtable)是我们最经常使用的技术,可是Collection好象是个黑色大染缸,本来有各种鲜明类型特征的对象一旦放入后,再取出时,这些类型就消失了.那么我们势必要用If来判断,如:\nIterator iterator = collection.iterator() while (iterator.hasNext()) { Object o = iterator.next(); if (o instanceof Collection) messyPrintCollection((Collection)o); else if (o instanceof String) System.out.println(\u0026#34;\u0026#39;\u0026#34;+o.toString()+\u0026#34;\u0026#39;\u0026#34;); else if (o instanceof Float) System.out.println(o.toString()+\u0026#34;f\u0026#34;); else System.out.println(o.toString()); } 在上例中,我们使用了 instanceof来判断 o的类型.\n很显然,这样做的缺点代码If else if 很繁琐.我们就可以使用Visitor模式解决它.\n如何使用Visitor? 针对上例,定义接口叫Visitable,用来定义一个Accept操作,也就是说让Collection每个元素具备可访问性.\n被访问者是我们Collection的每个元素Element,我们要为这些Element定义一个可以接受访问的接口(访问和被访问是互动的,只有访问者,被访问者如果表示不欢迎,访问者就不能访问),取名为Visitable，也可取名为Element。\npublic interface Visitable { public void accept(Visitor visitor); } 被访问的具体元素继承这个新的接口Visitable：\npublic class StringElement implements Visitable { private String value; public StringElement(String string) { value = string; } public String getValue(){ return value; } //定义accept的具体内容 这里是很简单的一句调用 public void accept(Visitor visitor) { visitor.","title":"3.10 Visitor"},{"content":"Interpreter pattern(解释者模式) 定义 定义语言的文法 ,并且建立一个解释器来解释该语言中的句子.\nInterpreter似乎使用面不是很广,它描述了一个语言解释器是如何构成的,在实际应用中,我们可能很少去构造一个语言的文法.我们还是来简单的了解一下: 首先要建立一个接口,用来描述共同的操作.\npublic interface AbstractExpression { void interpret( Context context ); } 再看看包含解释器之外的一些全局信息\npublic interface Context { } AbstractExpression的具体实现分两种:终结符表达式和非终结符表达式:\npublic class TerminalExpression implements AbstractExpression { public void interpret( Context context ) { } } 对于文法中没一条规则,非终结符表达式都必须的:\npublic class NonterminalExpression implements AbstractExpression { private AbstractExpression successor; public void setSuccessor( AbstractExpression successor ) { this.successor = successor; } public AbstractExpression getSuccessor() { return successor; } public void interpret( Context context ) { } } ","permalink":"http://blog.chalme.top/posts/design-patterns/3.9-interpreter/","summary":"Interpreter pattern(解释者模式) 定义 定义语言的文法 ,并且建立一个解释器来解释该语言中的句子.\nInterpreter似乎使用面不是很广,它描述了一个语言解释器是如何构成的,在实际应用中,我们可能很少去构造一个语言的文法.我们还是来简单的了解一下: 首先要建立一个接口,用来描述共同的操作.\npublic interface AbstractExpression { void interpret( Context context ); } 再看看包含解释器之外的一些全局信息\npublic interface Context { } AbstractExpression的具体实现分两种:终结符表达式和非终结符表达式:\npublic class TerminalExpression implements AbstractExpression { public void interpret( Context context ) { } } 对于文法中没一条规则,非终结符表达式都必须的:\npublic class NonterminalExpression implements AbstractExpression { private AbstractExpression successor; public void setSuccessor( AbstractExpression successor ) { this.successor = successor; } public AbstractExpression getSuccessor() { return successor; } public void interpret( Context context ) { } } ","title":"3.9 Interpreter"},{"content":"Mediator pattern(中介者模式) 定义 用一个中介对象来封装一系列关于对象交互行为.\n为何使用Mediator? 各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性.\n如何使用? 首先 有一个接口,用来定义成员对象之间的交互联系方式:\npublic interface Mediator { } Meiator具体实现,真正实现交互操作的内容:\npublic class ConcreteMediator implements Mediator { //假设当前有两个成员. private ConcreteColleague1 colleague1 = new ConcreteColleague1(); private ConcreteColleague2 colleague2 = new ConcreteColleague2(); ... } 再看看另外一个参与者:成员,因为是交互行为,都需要双方提供一些共同接口,这种要求在Visitor Observer等模式中都是相同的.\npublic class Colleague { private Mediator mediator; public Mediator getMediator() { return mediator; } public void setMediator( Mediator mediator ) { this.mediator = mediator; } } public class ConcreteColleague1 { } public class ConcreteColleague2 { } 每个成员都必须知道Mediator,并且和 Mediator联系,而不是和其他成员联系.\n至此,Mediator模式框架完成,可以发现Mediator模式规定不是很多,大体框架也比较简单,但实际使用起来就非常灵活.\nMediator模式在事件驱动类应用中比较多,例如界面设计GUI.;聊天,消息传递等,在聊天应用中,需要有一个MessageMediator,专门负责request/reponse之间任务的调节. MVC是J2EE的一个基本模式,View Controller是一种Mediator,它是Jsp和服务器上应用程序间的Mediator.\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.8-mediator/","summary":"Mediator pattern(中介者模式) 定义 用一个中介对象来封装一系列关于对象交互行为.\n为何使用Mediator? 各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性.\n如何使用? 首先 有一个接口,用来定义成员对象之间的交互联系方式:\npublic interface Mediator { } Meiator具体实现,真正实现交互操作的内容:\npublic class ConcreteMediator implements Mediator { //假设当前有两个成员. private ConcreteColleague1 colleague1 = new ConcreteColleague1(); private ConcreteColleague2 colleague2 = new ConcreteColleague2(); ... } 再看看另外一个参与者:成员,因为是交互行为,都需要双方提供一些共同接口,这种要求在Visitor Observer等模式中都是相同的.\npublic class Colleague { private Mediator mediator; public Mediator getMediator() { return mediator; } public void setMediator( Mediator mediator ) { this.mediator = mediator; } } public class ConcreteColleague1 { } public class ConcreteColleague2 { } 每个成员都必须知道Mediator,并且和 Mediator联系,而不是和其他成员联系.","title":"3.8 Mediator"},{"content":"Strategy pattern(策略模式) 定义 属于设计模式中 对象行为型模式,主要是定义一系列的算法,把这些算法一个个封装成单独的类.\nStratrgy应用比较广泛,比如, 公司经营业务变化图, 可能有两种实现方式,一个是线条曲线,一个是框图(bar),这是两种算法,可以使用Strategy实现. 如何使用? 这里以字符串替代为例, 有一个文件,我们需要读取后,希望替代其中相应的变量,然后输出.关于替代其中变量的方法可能有多种方法,这取决于用户的要求,所以我们要准备几套变量字符替代方案. 首先,我们建立一个抽象类RepTempRule 定义一些公用变量和方法:\npublic abstract class RepTempRule{ protected String oldString=\u0026#34;\u0026#34;; public void setOldString(String oldString){ this.oldString=oldString; } protected String newString=\u0026#34;\u0026#34;; public String getNewString(){ return newString; } public abstract void replace() throws Exception; } 在RepTempRule中 有一个抽象方法abstract需要继承明确,这个replace里其实是替代的具体方法. 我们现在有两个字符替代方案, 1.将文本中aaa替代成bbb; 2.将文本中aaa替代成ccc;\n对应的类分别是RepTempRuleOne RepTempRuleTwo\npublic class RepTempRuleOne extends RepTempRule{ public void replace() throws Exception{ //replaceFirst是jdk1.4新特性 newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;) System.out.println(\u0026#34;this is replace one\u0026#34;); } } public class RepTempRuleTwo extends RepTempRule{ public void replace() throws Exception{ newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;ccc\u0026#34;) System.out.println(\u0026#34;this is replace Two\u0026#34;);　} } 第二步：我们要建立一个算法解决类，用来提供客户端可以自由选择算法。\npublic class RepTempRuleSolve { private RepTempRule strategy; public RepTempRuleSolve(RepTempRule rule){ this.strategy=rule; } public String getNewContext(Site site,String oldString) { return strategy.replace(site,oldString); } public void changeAlgorithm(RepTempRule newAlgorithm) { strategy = newAlgorithm; } } 调用如下:\npublic class test{ ...... public void testReplace(){ //使用第一套替代方案 RepTempRuleSolve solver=new RepTempRuleSolve(new RepTempRuleOne()); solver.getNewContext(site,context); //使用第二套 solver=new RepTempRuleSolve(new RepTempRuleTwo()); solver.getNewContext(site,context); } ..... } 我们达到了在运行期间，可以自由切换算法的目的。\n实际整个Strategy的核心部分就是抽象类的使用,使用Strategy模式可以在用户需要变化时,修改量很少,而且快速.\nStrategy和Factory有一定的类似,Strategy相对简单容易理解,并且可以在运行时刻自由切换。Factory重点是用来创建对象。\nStrategy适合下列场合: 以不同的格式保存文件;\n以不同的算法压缩文件;\n以不同的算法截获图象;\n以不同的格式输出同样数据的图形,比如曲线 或框图bar等\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.7-strategy/","summary":"Strategy pattern(策略模式) 定义 属于设计模式中 对象行为型模式,主要是定义一系列的算法,把这些算法一个个封装成单独的类.\nStratrgy应用比较广泛,比如, 公司经营业务变化图, 可能有两种实现方式,一个是线条曲线,一个是框图(bar),这是两种算法,可以使用Strategy实现. 如何使用? 这里以字符串替代为例, 有一个文件,我们需要读取后,希望替代其中相应的变量,然后输出.关于替代其中变量的方法可能有多种方法,这取决于用户的要求,所以我们要准备几套变量字符替代方案. 首先,我们建立一个抽象类RepTempRule 定义一些公用变量和方法:\npublic abstract class RepTempRule{ protected String oldString=\u0026#34;\u0026#34;; public void setOldString(String oldString){ this.oldString=oldString; } protected String newString=\u0026#34;\u0026#34;; public String getNewString(){ return newString; } public abstract void replace() throws Exception; } 在RepTempRule中 有一个抽象方法abstract需要继承明确,这个replace里其实是替代的具体方法. 我们现在有两个字符替代方案, 1.将文本中aaa替代成bbb; 2.将文本中aaa替代成ccc;\n对应的类分别是RepTempRuleOne RepTempRuleTwo\npublic class RepTempRuleOne extends RepTempRule{ public void replace() throws Exception{ //replaceFirst是jdk1.4新特性 newString=oldString.replaceFirst(\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;) System.out.println(\u0026#34;this is replace one\u0026#34;); } } public class RepTempRuleTwo extends RepTempRule{ public void replace() throws Exception{ newString=oldString.","title":"3.7 Strategy"},{"content":"State(状态模式)的定义 不同的状态,不同的行为;或者说,每个状态有着相应的行为.\n何时使用? State模式在实际使用中比较多,适合\u0026quot;状态的切换\u0026quot;.因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.\n不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.\n是否使用? 在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度.\n这里要阐述的是\u0026quot;开关切换状态\u0026quot; 和\u0026quot; 一般的状态判断\u0026quot;是有一些区别的, \u0026quot; 一般的状态判断\u0026quot;也是有 if..elseif结构,例如:\nif (which==1) state=\u0026ldquo;hello\u0026rdquo;; else if (which==2) state=\u0026ldquo;hi\u0026rdquo;; else if (which==3) state=\u0026ldquo;bye\u0026rdquo;;\n这是一个 \u0026quot; 一般的状态判断\u0026quot;,state值的不同是根据which变量来决定的,which和state没有关系.如果改成:\nif (state.euqals(\u0026ldquo;bye\u0026rdquo;)) state=\u0026ldquo;hello\u0026rdquo;; else if (state.euqals(\u0026ldquo;hello\u0026rdquo;)) state=\u0026ldquo;hi\u0026rdquo;; else if (state.euqals(\u0026ldquo;hi\u0026rdquo;)) state=\u0026ldquo;bye\u0026rdquo;;\n这就是 \u0026ldquo;开关切换状态\u0026rdquo;,是将state的状态从\u0026quot;hello\u0026quot;切换到\u0026quot;hi\u0026quot;,再切换到\u0026quot;\u0026ldquo;bye\u0026rdquo;;在切换到\u0026quot;hello\u0026quot;,好象一个旋转开关,这种状态改变就可以使用State模式了.\n如果单纯有上面一种将\u0026quot;hello\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;hi\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;bye\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;hello\u0026quot;这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.\n请看下例:\npublic class Context{ private Color state=null; public void push(){ //如果当前red状态 就切换到blue if (state==Color.red) state=Color.blue; //如果当前blue状态 就切换到green else if (state==Color.blue) state=Color.green; //如果当前black状态 就切换到red else if (state==Color.black) state=Color.red; //如果当前green状态 就切换到black else if (state==Color.green) state=Color.black; Sample sample=new Sample(state); sample.operate(); } public void pull(){ //与push状态切换正好相反 if (state==Color.green) state=Color.blue; else if (state==Color.black) state=Color.green; else if (state==Color.blue) state=Color.red; else if (state==Color.red) state=Color.black; Sample2 sample2=new Sample2(state); sample2.operate(); } } 在上例中,我们有两个动作push推和pull拉,这两个开关动作,改变了Context颜色,至此,我们就需要使用State模式优化它.\n另外注意:但就上例,state的变化,只是简单的颜色赋值,这个具体行为是很简单的,State适合巨大的具体行为,因此在,就本例,实际使用中也不一定非要使用State模式,这会增加子类的数目,简单的变复杂.\n例如: 银行帐户, 经常会在Open 状态和Close状态间转换.\n例如: 经典的TcpConnection, Tcp的状态有创建 侦听 关闭三个,并且反复转换,其创建 侦听 关闭的具体行为不是简单一两句就能完成的,适合使用State\n例如:信箱POP帐号, 会有四种状态, start HaveUsername Authorized quit,每个状态对应的行为应该是比较大的.适合使用State\n例如:在工具箱挑选不同工具,可以看成在不同工具中切换,适合使用State.如 具体绘图程序,用户可以选择不同工具绘制方框 直线 曲线,这种状态切换可以使用State.\n如何使用 State需要两种类型实体参与:\nstate manager 状态管理器 ,就是开关 ,如上面例子的Context实际就是一个state manager, 在state manager中有对状态的切换动作. 用抽象类或接口实现的父类,,不同状态就是继承这个父类的不同子类. 以上面的Context为例.我们要修改它,建立两个类型的实体.\n第一步: 首先建立一个父类: public abstract class State{ public abstract void handlepush(Context c); public abstract void handlepull(Context c); public abstract void getcolor(); } 父类中的方法要对应state manager中的开关行为,在state manager中 本例就是Context中,有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作:handlepush() handlepull(); 同时还需要一个获取push或pull结果的方法getcolor()\n下面是具体子类的实现:\npublic class BlueState extends State{ public void handlepush(Context c){ //根据push方法\u0026#34;如果是blue状态的切换到green\u0026#34; ; c.setState(new GreenState()); } public void handlepull(Context c){ //根据pull方法\u0026#34;如果是blue状态的切换到red\u0026#34; ; c.setState(new RedState()); } public abstract void getcolor(){ return (Color.blue)} } 同样 其他状态的子类实现如blue一样.\n第二步: 要重新改写State manager 也就是本例的Context: public class Context{ private Sate state=null; //我们将原来的 Color state 改成了新建的State state; //setState是用来改变state的状态 使用setState实现状态的切换 pulic void setState(State state){ this.state=state; } public void push(){ //状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心 state.handlepush(this); //因为sample要使用state中的一个切换结果,使用getColor() Sample sample=new Sample(state.getColor()); sample.operate(); } public void pull(){ state.handlepull(this); Sample2 sample2=new Sample2(state.getColor()); sample2.operate(); } } 至此,我们也就实现了State的refactorying过程.\n以上只是相当简单的一个实例,在实际应用中,handlepush或handelpull的处理是复杂的.\n状态模式优点： （1） 封装转换过程，也就是转换规则 （2） 枚举可能的状态，因此，需要事先确定状态种类。\n状态模式可以允许客户端改变状态的转换行为，而状态机则是能够自动改变状态，状态机是一个比较独立的而且复杂的机制，具体可参考一个状态机开源项目：http://sourceforge.net/projects/smframework/\n状态模式在工作流或游戏等各种系统中有大量使用，甚至是这些系统的核心功能设计，例如政府OA中，一个批文的状态有多种：未办；正在办理；正在批示；正在审核；已经完成等各种状态，使用状态机可以封装这个状态的变化规则，从而达到扩充状态时，不必涉及到状态的使用者。\n在网络游戏中，一个游戏活动存在开始；开玩；正在玩；输赢等各种状态，使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面，使用状态模式可以对整个游戏架构功能实现起到决定的主导作用。\n状态模式实质 使用状态模式前，客户端外界需要介入改变状态，而状态改变的实现是琐碎或复杂的。\n使用状态模式后，客户端外界可以直接使用事件Event实现，根本不必关心该事件导致如何状态变化，这些是由状态机等内部实现。\n这是一种Event-condition-State，状态模式封装了condition-State部分。\n每个状态形成一个子类，每个状态只关心它的下一个可能状态，从而无形中形成了状态转换的规则。如果新的状态加入，只涉及它的前一个状态修改和定义。\n状态转换有几个方法实现：一个在每个状态实现next()，指定下一个状态；还有一种方法，设定一个StateOwner，在StateOwner设定stateEnter状态进入和stateExit状态退出行为。\n状态从一个方面说明了流程，流程是随时间而改变，状态是截取流程某个时间片。\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.6-state/","summary":"State(状态模式)的定义 不同的状态,不同的行为;或者说,每个状态有着相应的行为.\n何时使用? State模式在实际使用中比较多,适合\u0026quot;状态的切换\u0026quot;.因为我们经常会使用If elseif else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.\n不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.\n是否使用? 在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度.\n这里要阐述的是\u0026quot;开关切换状态\u0026quot; 和\u0026quot; 一般的状态判断\u0026quot;是有一些区别的, \u0026quot; 一般的状态判断\u0026quot;也是有 if..elseif结构,例如:\nif (which==1) state=\u0026ldquo;hello\u0026rdquo;; else if (which==2) state=\u0026ldquo;hi\u0026rdquo;; else if (which==3) state=\u0026ldquo;bye\u0026rdquo;;\n这是一个 \u0026quot; 一般的状态判断\u0026quot;,state值的不同是根据which变量来决定的,which和state没有关系.如果改成:\nif (state.euqals(\u0026ldquo;bye\u0026rdquo;)) state=\u0026ldquo;hello\u0026rdquo;; else if (state.euqals(\u0026ldquo;hello\u0026rdquo;)) state=\u0026ldquo;hi\u0026rdquo;; else if (state.euqals(\u0026ldquo;hi\u0026rdquo;)) state=\u0026ldquo;bye\u0026rdquo;;\n这就是 \u0026ldquo;开关切换状态\u0026rdquo;,是将state的状态从\u0026quot;hello\u0026quot;切换到\u0026quot;hi\u0026quot;,再切换到\u0026quot;\u0026ldquo;bye\u0026rdquo;;在切换到\u0026quot;hello\u0026quot;,好象一个旋转开关,这种状态改变就可以使用State模式了.\n如果单纯有上面一种将\u0026quot;hello\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;hi\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;bye\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;hello\u0026quot;这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.\n请看下例:\npublic class Context{ private Color state=null; public void push(){ //如果当前red状态 就切换到blue if (state==Color.red) state=Color.blue; //如果当前blue状态 就切换到green else if (state==Color.blue) state=Color.green; //如果当前black状态 就切换到red else if (state==Color.","title":"3.6 State"},{"content":"Command模式是最让我疑惑的一个模式,我在阅读了很多代码后,才感觉隐约掌握其大概原理,我认为理解设计模式最主要是掌握起原理构造,这样才对自己实际编程有指导作用.Command模式实际上不是个很具体,规定很多的模式,正是这个灵活性,让人有些confuse.\nCommand命令模式 n 将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。\n这是一种两台机器之间通讯联系性质的模式，类似传统过程语 言的 CallBack功能。\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n优点 解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。\n不少Command模式的代码都是针对图形界面的,它实际就是菜单命令,我们在一个下拉菜单选择一个命令时,然后会执行一些动作.\n将这些命令封装成在一个类中,然后用户(调用者)再对这个类进行操作,这就是Command模式,换句话说,本来用户(调用者)是直接调用这些命令的,如菜单上打开文档(调用者),就直接指向打开文档的代码,使用Command模式,就是在这两者之间增加一个中间者,将这种直接关系拗断,同时两者之间都隔离,基本没有关系了.\n显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式, 从Command模式,我也发现设计模式一个\u0026quot;通病\u0026quot;:好象喜欢将简单的问题复杂化, 喜欢在不同类中增加第三者,当然这样做有利于代码的健壮性 可维护性 还有复用性.\n如何使用? 具体的Command模式代码各式各样,因为如何封装命令,不同系统,有不同的做法.下面事例是将命令封装在一个Collection的List中,任何对象一旦加入List中,实际上装入了一个封闭的黑盒中,对象的特性消失了,只有取出时,才有可能模糊的分辨出:典型的Command模式需要有一个接口.接口中有一个统一的方法,这就是\u0026quot;将命令/请求封装为对象\u0026quot;:\npublic interface Command { public abstract void execute ( ); } 具体不同命令/请求代码是实现接口Command,下面有三个具体命令\npublic class Engineer implements Command { public void execute( ) { //do Engineer\u0026#39;s command } } public class Programmer implements Command { public void execute( ) { //do programmer\u0026#39;s command } } public class Politician implements Command { public void execute( ) { //do Politician\u0026#39;s command } } 按照通常做法,我们就可以直接调用这三个Command,但是使用Command模式,我们要将他们封装起来,扔到黑盒子List里去:\npublic class producer{ public static List produceRequests() { List queue = new ArrayList(); queue.add( new DomesticEngineer() ); queue.add( new Politician() ); queue.add( new Programmer() ); return queue; } } 这三个命令进入List中后,已经失去了其外表特征,以后再取出,也可能无法分辨出谁是Engineer 谁是Programmer了,看下面客户端如何调用Command模式:\npublic class TestCommand { public static void main(String[] args) { List queue = Producer.produceRequests(); for (Iterator it = queue.iterator(); it.hasNext(); ) //客户端直接调用execute方法，无需知道被调用者的其它更多类的方法名。 ((Command)it.next()).execute(); } } 由此可见,调用者基本只和接口打交道,不合具体实现交互,这也体现了一个原则,面向接口编程,这样,以后增加第四个具体命令时,就不必修改调用者TestCommand中的代码了.\n理解了上面的代码的核心原理,在使用中,就应该各人有自己方法了,特别是在如何分离调用者和具体命令上,有很多实现方法,上面的代码是使用\u0026quot;从List过一遍\u0026quot;的做法.这种做法只是为了演示.\n使用Command模式的一个好理由还因为它能实现Undo功能.每个具体命令都可以记住它刚刚执行的动作,并且在需要时恢复.\nCommand模式在界面设计中应用广泛.Java的Swing中菜单命令都是使用Command模式,由于Java在界面设计的性能上还有欠缺,因此界面设计具体代码我们就不讨论,网络上有很多这样的示例.\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.5-command/","summary":"Command模式是最让我疑惑的一个模式,我在阅读了很多代码后,才感觉隐约掌握其大概原理,我认为理解设计模式最主要是掌握起原理构造,这样才对自己实际编程有指导作用.Command模式实际上不是个很具体,规定很多的模式,正是这个灵活性,让人有些confuse.\nCommand命令模式 n 将来自客户端的请求传入一个对象，无需了解这个请求激活的 动作或有关接受这个请求的处理细节。\n这是一种两台机器之间通讯联系性质的模式，类似传统过程语 言的 CallBack功能。\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。\n优点 解耦了发送者和接受者之间联系。 发送者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，发送者无需知道接受者任何接口。\n不少Command模式的代码都是针对图形界面的,它实际就是菜单命令,我们在一个下拉菜单选择一个命令时,然后会执行一些动作.\n将这些命令封装成在一个类中,然后用户(调用者)再对这个类进行操作,这就是Command模式,换句话说,本来用户(调用者)是直接调用这些命令的,如菜单上打开文档(调用者),就直接指向打开文档的代码,使用Command模式,就是在这两者之间增加一个中间者,将这种直接关系拗断,同时两者之间都隔离,基本没有关系了.\n显然这样做的好处是符合封装的特性,降低耦合度,Command是将对行为进行封装的典型模式,Factory是将创建进行封装的模式, 从Command模式,我也发现设计模式一个\u0026quot;通病\u0026quot;:好象喜欢将简单的问题复杂化, 喜欢在不同类中增加第三者,当然这样做有利于代码的健壮性 可维护性 还有复用性.\n如何使用? 具体的Command模式代码各式各样,因为如何封装命令,不同系统,有不同的做法.下面事例是将命令封装在一个Collection的List中,任何对象一旦加入List中,实际上装入了一个封闭的黑盒中,对象的特性消失了,只有取出时,才有可能模糊的分辨出:典型的Command模式需要有一个接口.接口中有一个统一的方法,这就是\u0026quot;将命令/请求封装为对象\u0026quot;:\npublic interface Command { public abstract void execute ( ); } 具体不同命令/请求代码是实现接口Command,下面有三个具体命令\npublic class Engineer implements Command { public void execute( ) { //do Engineer\u0026#39;s command } } public class Programmer implements Command { public void execute( ) { //do programmer\u0026#39;s command } } public class Politician implements Command { public void execute( ) { //do Politician\u0026#39;s command } } 按照通常做法,我们就可以直接调用这三个Command,但是使用Command模式,我们要将他们封装起来,扔到黑盒子List里去:","title":"3.5 Command"},{"content":"Chain of Responsibility (职责链模式) Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。\n如何使用? 虽然这一段是如何使用CoR,但是也是演示什么是CoR.\n有一个Handler接口:\npublic interface Handler{ public void handleRequest(); } 这是一个处理request的事例， 如果有多种request,比如 请求帮助 请求打印 或请求格式化：\n最先想到的解决方案是：在接口中增加多个请求：\npublic interface Handler{ public void handleHelp(); public void handlePrint(); public void handleFormat(); } 具体是一段实现接口Handler代码：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleHelp(){ //具体处理请求Help的代码 ... } public void handlePrint(){ //如果是print 转去处理Print successor.handlePrint(); } public void handleFormat(){ //如果是Format 转去处理format successor.handleFormat(); } } 一共有三个这样的具体实现类，上面是处理help,还有处理Print 处理Format这大概是我们最常用的编程思路。\n虽然思路简单明了，但是有一个扩展问题，如果我们需要再增加一个请求request种类,需要修改接口及其每一个实现。\n第二方案:将每种request都变成一个接口，因此我们有以下代码 ：\npublic interface HelpHandler{ public void handleHelp(); } public interface PrintHandler{ public void handlePrint(); } public interface FormatHandler{ public void handleFormat(); } public class ConcreteHandler implements HelpHandler,PrintHandler,FormatHandlet{ private HelpHandler helpSuccessor; private PrintHandler printSuccessor; private FormatHandler formatSuccessor; public ConcreteHandler(HelpHandler helpSuccessor,PrintHandler printSuccessor,FormatHandler formatSuccessor) { this.helpSuccessor=helpSuccessor; this.printSuccessor=printSuccessor; this.formatSuccessor=formatSuccessor; } public void handleHelp(){ ....... } public void handlePrint(){this.printSuccessor=printSuccessor;} public void handleFormat(){this.formatSuccessor=formatSuccessor;} } 这个办法在增加新的请求request情况下，只是节省了接口的修改量，接口实现ConcreteHandler还需要修改。而且代码显然不简单美丽。\n解决方案3: 在Handler接口中只使用一个参数化方法：\npublic interface Handler{ public void handleRequest(String request); } 那么Handler实现代码如下：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleRequest(String request){ if (request.equals(\u0026#34;Help\u0026#34;)){ //这里是处理Help的具体代码 }else //传递到下一个 successor.handle(request); } } } 这里先假设request是String类型，如果不是怎么办？当然我们可以创建一个专门类Request\n最后解决方案:接口Handler的代码如下：\npublic interface Handler{ public void handleRequest(Request request); } Request类的定义:\npublic class Request{ private String type; public Request(String type){this.type=type;} public String getType(){return type;} public void execute(){ //request真正具体行为代码 } } 那么Handler实现代码如下：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleRequest(Request request){ if (request instanceof HelpRequest){ //这里是处理Help的具体代码 }else if (request instanceof PrintRequst){ request.execute(); }else //传递到下一个 successor.handle(request); } } } 这个解决方案就是CoR, 在一个链上,都有相应职责的类,因此叫Chain of Responsibility.\nCoR的优点 因为无法预知来自外界（客户端）的请求是属于哪种类型，每个类如果碰到它不能处理的请求只要放弃就可以。\n缺点是效率低，因为一个请求的完成可能要遍历到最后才可能完成，当然也可以用树的概念优化。 在Java AWT1.0中，对于鼠标按键事情的处理就是使用CoR,到Java.1.1以后，就使用Observer代替CoR\n扩展性差，因为在CoR中，一定要有一个统一的接口Handler.局限性就在这里。\n与Command模式区别 Command 模式需要事先协商客户端和服务器端的调用关系，比如 1 代表 start 2 代表 move 等，这些 都是封装在 request 中，到达服务器端再分解。\nCoR 模式就无需这种事先约定，服务器端可以使用 CoR 模式进行客户端请求的猜测，一个个猜测 试验。\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.4-chain-of-responsibility/","summary":"Chain of Responsibility (职责链模式) Chain of Responsibility(CoR) 是用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。\n如何使用? 虽然这一段是如何使用CoR,但是也是演示什么是CoR.\n有一个Handler接口:\npublic interface Handler{ public void handleRequest(); } 这是一个处理request的事例， 如果有多种request,比如 请求帮助 请求打印 或请求格式化：\n最先想到的解决方案是：在接口中增加多个请求：\npublic interface Handler{ public void handleHelp(); public void handlePrint(); public void handleFormat(); } 具体是一段实现接口Handler代码：\npublic class ConcreteHandler implements Handler{ private Handler successor; public ConcreteHandler(Handler successor){ this.successor=successor; } public void handleHelp(){ //具体处理请求Help的代码 ... } public void handlePrint(){ //如果是print 转去处理Print successor.handlePrint(); } public void handleFormat(){ //如果是Format 转去处理format successor.","title":"3.4 Chain of Responsibility"},{"content":"Observer(观察者模式)定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n链接\n具体讲解\nJava深入到一定程度,就不可避免的碰到设计模式(design pattern)这一概念,了解设计模式,将使自己对java中的接口或抽象类应用有更深的理解.设计模式在java的中型系统中应用广泛,遵循一定的编程模式,才能使自己的代码便于理解,易于交流,Observer(观察者)模式是比较常用的一个模式,尤其在界面设计中应用广泛,而本站所关注的是Java在电子商务系统中应用,因此想从电子商务实例中分析Observer的应用.\n虽然网上商店形式多样,每个站点有自己的特色,但也有其一般的共性,单就\u0026quot;商品的变化,以便及时通知订户\u0026quot;这一点,是很多网上商店共有的模式,这一模式类似Observer patern观察者模式.\n具体的说,如果网上商店中商品在名称 价格等方面有变化,如果系统能自动通知会员,将是网上商店区别传统商店的一大特色.这就需要在商品product中加入Observer这样角色,以便product细节发生变化时,Observer能自动观察到这种变化,并能进行及时的update或notify动作.\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.3-observer/","summary":"Observer(观察者模式)定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n链接\n具体讲解\nJava深入到一定程度,就不可避免的碰到设计模式(design pattern)这一概念,了解设计模式,将使自己对java中的接口或抽象类应用有更深的理解.设计模式在java的中型系统中应用广泛,遵循一定的编程模式,才能使自己的代码便于理解,易于交流,Observer(观察者)模式是比较常用的一个模式,尤其在界面设计中应用广泛,而本站所关注的是Java在电子商务系统中应用,因此想从电子商务实例中分析Observer的应用.\n虽然网上商店形式多样,每个站点有自己的特色,但也有其一般的共性,单就\u0026quot;商品的变化,以便及时通知订户\u0026quot;这一点,是很多网上商店共有的模式,这一模式类似Observer patern观察者模式.\n具体的说,如果网上商店中商品在名称 价格等方面有变化,如果系统能自动通知会员,将是网上商店区别传统商店的一大特色.这就需要在商品product中加入Observer这样角色,以便product细节发生变化时,Observer能自动观察到这种变化,并能进行及时的update或notify动作.","title":"3.3 Observer"},{"content":"Memento(备忘录模式)定义 memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.\nMemento模式相对也比较好理解,我们看下列代码:\npublic class Originator { public int number; public File file = null; public Originator(){} // 创建一个Memento public Memento getMemento(){ return new Memento(this); } // 恢复到原始值 public void setMemento(Memento m){ number = m.number; file = m.file; } } 我们再看看Memento类:\nprivate class Memento implements java.io.Serializable{ public int number; public File file = null; public Memento( Originator o){ number = o.number; file = o.file; } } 可见 Memento中保存了Originator中的number和file的值. 通过调用Originator中number和file值改变的话,通过调用setMemento()方法可以恢复.\nMemento模式的缺点是耗费大,如果内部状态很多,再保存一份,无意要浪费大量内存.\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.2-memento/","summary":"Memento(备忘录模式)定义 memento是一个保存另外一个对象内部状态拷贝的对象.这样以后就可以将该对象恢复到原先保存的状态.\nMemento模式相对也比较好理解,我们看下列代码:\npublic class Originator { public int number; public File file = null; public Originator(){} // 创建一个Memento public Memento getMemento(){ return new Memento(this); } // 恢复到原始值 public void setMemento(Memento m){ number = m.number; file = m.file; } } 我们再看看Memento类:\nprivate class Memento implements java.io.Serializable{ public int number; public File file = null; public Memento( Originator o){ number = o.number; file = o.file; } } 可见 Memento中保存了Originator中的number和file的值. 通过调用Originator中number和file值改变的话,通过调用setMemento()方法可以恢复.\nMemento模式的缺点是耗费大,如果内部状态很多,再保存一份,无意要浪费大量内存.","title":"3.2 Memento"},{"content":"Template(模板模式)定义 定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.\n使用Java的抽象类时，就经常会使用到Template模式,因此Template模式使用很普遍.而且很容易理解和使用。\npublic abstract class Benchmark { /** * 下面操作是我们希望在子类中完成 */ public abstract void benchmark(); /** * 重复执行benchmark次数 */ public final long repeat (int count) { if (count \u0026lt;= 0) return 0; else { long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; count; i++) benchmark(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; } } } 在上例中,我们希望重复执行benchmark()操作,但是对benchmark()的具体内容没有说明,而是延迟到其子类中描述:\npublic class MethodBenchmark extends Benchmark { /** * 真正定义benchmark内容 */ public void benchmark() { for (int i = 0; i \u0026lt; Integer.MAX_VALUE; i++){ System.out.printtln(\u0026#34;i=\u0026#34;+i);　} } } 至此,Template模式已经完成,是不是很简单?\n我们称repeat方法为模板方法， 它其中的benchmark()实现被延迟到子类MethodBenchmark中实现了，\n看看如何使用:\nBenchmark operation = new MethodBenchmark(); long duration = operation.repeat(Integer.parseInt(args[0].trim())); System.out.println(\u0026#34;The operation took \u0026#34; + duration + \u0026#34; milliseconds\u0026#34;); 也许你以前还疑惑抽象类有什么用,现在你应该彻底明白了吧? 至于这样做的好处,很显然啊,扩展性强,以后Benchmark内容变化,我只要再做一个继承子类就可以,不必修改其他应用代码.\n","permalink":"http://blog.chalme.top/posts/design-patterns/3.1-template/","summary":"Template(模板模式)定义 定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中.\n使用Java的抽象类时，就经常会使用到Template模式,因此Template模式使用很普遍.而且很容易理解和使用。\npublic abstract class Benchmark { /** * 下面操作是我们希望在子类中完成 */ public abstract void benchmark(); /** * 重复执行benchmark次数 */ public final long repeat (int count) { if (count \u0026lt;= 0) return 0; else { long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; count; i++) benchmark(); long stopTime = System.currentTimeMillis(); return stopTime - startTime; } } } 在上例中,我们希望重复执行benchmark()操作,但是对benchmark()的具体内容没有说明,而是延迟到其子类中描述:\npublic class MethodBenchmark extends Benchmark { /** * 真正定义benchmark内容 */ public void benchmark() { for (int i = 0; i \u0026lt; Integer.","title":"3.1 Template"},{"content":"Flyweight(享元模式)定义 避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).\n重点 本质factory的实现，巧妙的设计。 hashtable 或 hashmap 来判断对象是否存在 为什么使用? 面向对象语言的原则就是一切都是对象,但是如果真正使用起来,有时对象数可能显得很庞大,比如,字处理软件,如果以每个文字都作为一个对象,几千个字,对象数就是几千,无疑耗费内存,那么我们还是要\u0026quot;求同存异\u0026quot;,找出这些对象群的共同点,设计一个元类,封装可以被共享的类,另外,还有一些特性是取决于应用(context),是不可共享的,这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分.\n说白点,就是先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象.\nFlyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.\n如何使用?\n我们先从Flyweight抽象接口开始:\npublic interface Flyweight { public void operation( ExtrinsicState state ); } //用于本模式的抽象数据类型(自行设计) public interface ExtrinsicState { }\n下面是接口的具体实现(ConcreteFlyweight) ,并为内部状态增加内存空间, ConcreteFlyweight必须是可共享的,它保存的任何状态都必须是内部(intrinsic),也就是说,ConcreteFlyweight必须和它的应用环境场合无关.\npublic class ConcreteFlyweight implements Flyweight { private IntrinsicState state; public void operation( ExtrinsicState state ) { //具体操作 } } 当然,并不是所有的Flyweight具体实现子类都需要被共享的,所以还有另外一种不共享的ConcreteFlyweight:\npublic class UnsharedConcreteFlyweight implements Flyweight { public void operation( ExtrinsicState state ) { } } Flyweight factory负责维护一个Flyweight池(存放内部状态),当客户端请求一个共享Flyweight时,这个factory首先搜索池中是否已经有可适用的,如果有,factory只是简单返回送出这个对象,否则,创建一个新的对象,加入到池中,再返回送出这个对象.池\npublic class FlyweightFactory { //Flyweight pool private Hashtable flyweights = new Hashtable(); public Flyweight getFlyweight( Object key ) { Flyweight flyweight = (Flyweight) flyweights.get(key); if( flyweight == null ) { //产生新的ConcreteFlyweight flyweight = new ConcreteFlyweight(); flyweights.put( key, flyweight ); } return flyweight; } } 至此,Flyweight模式的基本框架已经就绪,我们看看如何调用:\nFlyweightFactory factory = new FlyweightFactory(); Flyweight fly1 = factory.getFlyweight( \u0026ldquo;Fred\u0026rdquo; ); Flyweight fly2 = factory.getFlyweight( \u0026ldquo;Wilma\u0026rdquo; ); \u0026hellip;\u0026hellip;\n从调用上看,好象是个纯粹的Factory使用,但奥妙就在于Factory的内部设计上.\nFlyweight模式在XML等数据源中应用 我们上面已经提到,当大量从数据源中读取字符串,其中肯定有重复的,那么我们使用Flyweight模式可以提高效率,以唱片CD为例,在一个XML文件中,存放了多个CD的资料.\n每个CD有三个字段: 1.出片日期(year) 2.歌唱者姓名等信息(artist) 3.唱片曲目 (title)\n其中,歌唱者姓名有可能重复,也就是说,可能有同一个演唱者的多个不同时期 不同曲目的CD.我们将\u0026quot;歌唱者姓名\u0026quot;作为可共享的ConcreteFlyweight.其他两个字段作为UnsharedConcreteFlyweight.\n首先看看数据源XML文件的内容:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;collection\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Another Green World\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1978\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Eno, Brian\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Greatest Hits\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1950\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Holiday, Billie\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; \u0026lt;cd\u0026gt; \u0026lt;title\u0026gt;Taking Tiger Mountain (by strategy)\u0026lt;/title\u0026gt; \u0026lt;year\u0026gt;1977\u0026lt;/year\u0026gt; \u0026lt;artist\u0026gt;Eno, Brian\u0026lt;/artist\u0026gt; \u0026lt;/cd\u0026gt; ....... \u0026lt;/collection\u0026gt; 虽然上面举例CD只有3张,CD可看成是大量重复的小类,因为其中成分只有三个字段,而且有重复的(歌唱者姓名).\nCD就是类似上面接口 Flyweight:\npublic class CD { private String title; private int year; private Artist artist; public String getTitle() {　return title;　} public int getYear() {　return year;　} public Artist getArtist() {　return artist;　} public void setTitle(String t){　title = t;} public void setYear(int y){year = y;} public void setArtist(Artist a){artist = a;} } 将\u0026quot;歌唱者姓名\u0026quot;作为可共享的ConcreteFlyweight:\npublic class Artist { //内部状态 private String name; // note that Artist is immutable. String getName(){return name;} Artist(String n){ name = n; } } 再看看Flyweight factory,专门用来制造上面的可共享的ConcreteFlyweight:Artist\npublic class ArtistFactory { Hashtable pool = new Hashtable(); Artist getArtist(String key){ Artist result; result = (Artist)pool.get(key); ////产生新的Artist if(result == null) { result = new Artist(key); pool.put(key,result); } return result; } } 当你有几千张甚至更多CD时,Flyweight模式将节省更多空间,共享的flyweight越多,空间节省也就越大.\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.7-flyweight/","summary":"Flyweight(享元模式)定义 避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类).\n重点 本质factory的实现，巧妙的设计。 hashtable 或 hashmap 来判断对象是否存在 为什么使用? 面向对象语言的原则就是一切都是对象,但是如果真正使用起来,有时对象数可能显得很庞大,比如,字处理软件,如果以每个文字都作为一个对象,几千个字,对象数就是几千,无疑耗费内存,那么我们还是要\u0026quot;求同存异\u0026quot;,找出这些对象群的共同点,设计一个元类,封装可以被共享的类,另外,还有一些特性是取决于应用(context),是不可共享的,这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分.\n说白点,就是先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象.\nFlyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.\n如何使用?\n我们先从Flyweight抽象接口开始:\npublic interface Flyweight { public void operation( ExtrinsicState state ); } //用于本模式的抽象数据类型(自行设计) public interface ExtrinsicState { }\n下面是接口的具体实现(ConcreteFlyweight) ,并为内部状态增加内存空间, ConcreteFlyweight必须是可共享的,它保存的任何状态都必须是内部(intrinsic),也就是说,ConcreteFlyweight必须和它的应用环境场合无关.\npublic class ConcreteFlyweight implements Flyweight { private IntrinsicState state; public void operation( ExtrinsicState state ) { //具体操作 } } 当然,并不是所有的Flyweight具体实现子类都需要被共享的,所以还有另外一种不共享的ConcreteFlyweight:\npublic class UnsharedConcreteFlyweight implements Flyweight { public void operation( ExtrinsicState state ) { } } Flyweight factory负责维护一个Flyweight池(存放内部状态),当客户端请求一个共享Flyweight时,这个factory首先搜索池中是否已经有可适用的,如果有,factory只是简单返回送出这个对象,否则,创建一个新的对象,加入到池中,再返回送出这个对象.","title":"2.7 Flyweight"},{"content":"Bridge(桥接模式)定义 将抽象和行为划分开来,各自独立,但能动态的结合。\n在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。\n重点 单例模型的使用和 调用 为什么使用? 不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。\n如果一个抽象类或接口有多个具体实现(子类、concrete subclass),这些子类之间关系可能有以下两种情况:\n这多个子类之间概念是并列的,如前面举例,打桩,有两个concrete class:方形桩和圆形桩;这两个形状上的桩是并列的,没有概念上的重复。\n这多个子类之中有内容概念上重叠.那么需要我们把抽象共同部分和行为共同部分各自独立开来,原来是准备放在一个接口里,现在需要设计两个接口：抽象接口和行为接口，分别放置抽象和行为.\n例如,一杯咖啡为例,子类实现类为四个：中杯加奶、大杯加奶、 中杯不加奶、大杯不加奶。\n但是，我们注意到：上面四个子类中有概念重叠，可从另外一个角度进行考虑，这四个类实际是两个角色的组合：抽象 和行为，其中抽象为：中杯和大杯；行为为：加奶 不加奶（如加橙汁 加苹果汁）.\n实现四个子类在抽象和行为之间发生了固定的绑定关系，如果以后动态增加加葡萄汁的行为，就必须再增加两个类：中杯加葡萄汁和大杯加葡萄汁。显然混乱,扩展性极差。\n那我们从分离抽象和行为的角度，使用Bridge模式来实现。\n如何实现? 以上面提到的咖啡 为例. 我们原来打算只设计一个接口(抽象类),使用Bridge模式后,我们需要将抽象和行为分开,加奶和不加奶属于行为,我们将它们抽象成一个专门的行为接口.\n先看看抽象部分的接口代码:\npublic abstract class Coffee { CoffeeImp coffeeImp; public void setCoffeeImp() { this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp(); } public CoffeeImp getCoffeeImp() {return this.CoffeeImp;} public abstract void pourCoffee(); } 其中CoffeeImp 是加不加奶的行为接口,看其代码如下:\npublic abstract class CoffeeImp { public abstract void pourCoffeeImp(); } 现在我们有了两个抽象类,下面我们分别对其进行继承,实现concrete class:\n//中杯 public class MediumCoffee extends Coffee { public MediumCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.getCoffeeImp(); //我们以重复次数来说明是冲中杯还是大杯 ,重复2次是中杯 for (int i = 0; i \u0026lt; 2; i++) { coffeeImp.pourCoffeeImp(); } } } //大杯 public class SuperSizeCoffee extends Coffee { public SuperSizeCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.getCoffeeImp(); //我们以重复次数来说明是冲中杯还是大杯 ,重复5次是大杯 for (int i = 0; i \u0026lt; 5; i++) { coffeeImp.pourCoffeeImp(); } } } 上面分别是中杯和大杯的具体实现.下面再对行为CoffeeImp进行继承:\n//加奶 public class MilkCoffeeImp extends CoffeeImp { MilkCoffeeImp() {} public void pourCoffeeImp() { System.out.println(\u0026#34;加了美味的牛奶\u0026#34;); } } //不加奶 public class FragrantCoffeeImp extends CoffeeImp { FragrantCoffeeImp() {} public void pourCoffeeImp() { System.out.println(\u0026#34;什么也没加,清香\u0026#34;); } } Bridge模式的基本框架我们已经搭好了,别忘记定义中还有一句:动态结合,我们现在可以喝到至少四种咖啡: 1.中杯加奶 2.中杯不加奶 3.大杯加奶 4.大杯不加奶\n看看是如何动态结合的,在使用之前,我们做个准备工作,设计一个单态类(Singleton)用来hold当前的CoffeeImp:\npublic class CoffeeImpSingleton { private static CoffeeImp coffeeImp; public CoffeeImpSingleton(CoffeeImp coffeeImpIn) {this.coffeeImp = coffeeImpIn;} public static CoffeeImp getTheCoffeeImp() { return coffeeImp; } } 看看中杯加奶 和大杯加奶 是怎么出来的:\n//拿出牛奶 CoffeeImpSingleton coffeeImpSingleton = new CoffeeImpSingleton(new MilkCoffeeImp()); //中杯加奶 MediumCoffee mediumCoffee = new MediumCoffee(); mediumCoffee.pourCoffee(); //大杯加奶 SuperSizeCoffee superSizeCoffee = new SuperSizeCoffee(); superSizeCoffee.pourCoffee(); 注意: Bridge模式的执行类如CoffeeImp和Coffee是一对一的关系, 正确创建CoffeeImp是该模式的关键。\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.6-bridge/","summary":"Bridge(桥接模式)定义 将抽象和行为划分开来,各自独立,但能动态的结合。\n在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。\n重点 单例模型的使用和 调用 为什么使用? 不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。\n如果一个抽象类或接口有多个具体实现(子类、concrete subclass),这些子类之间关系可能有以下两种情况:\n这多个子类之间概念是并列的,如前面举例,打桩,有两个concrete class:方形桩和圆形桩;这两个形状上的桩是并列的,没有概念上的重复。\n这多个子类之中有内容概念上重叠.那么需要我们把抽象共同部分和行为共同部分各自独立开来,原来是准备放在一个接口里,现在需要设计两个接口：抽象接口和行为接口，分别放置抽象和行为.\n例如,一杯咖啡为例,子类实现类为四个：中杯加奶、大杯加奶、 中杯不加奶、大杯不加奶。\n但是，我们注意到：上面四个子类中有概念重叠，可从另外一个角度进行考虑，这四个类实际是两个角色的组合：抽象 和行为，其中抽象为：中杯和大杯；行为为：加奶 不加奶（如加橙汁 加苹果汁）.\n实现四个子类在抽象和行为之间发生了固定的绑定关系，如果以后动态增加加葡萄汁的行为，就必须再增加两个类：中杯加葡萄汁和大杯加葡萄汁。显然混乱,扩展性极差。\n那我们从分离抽象和行为的角度，使用Bridge模式来实现。\n如何实现? 以上面提到的咖啡 为例. 我们原来打算只设计一个接口(抽象类),使用Bridge模式后,我们需要将抽象和行为分开,加奶和不加奶属于行为,我们将它们抽象成一个专门的行为接口.\n先看看抽象部分的接口代码:\npublic abstract class Coffee { CoffeeImp coffeeImp; public void setCoffeeImp() { this.CoffeeImp = CoffeeImpSingleton.getTheCoffeImp(); } public CoffeeImp getCoffeeImp() {return this.CoffeeImp;} public abstract void pourCoffee(); } 其中CoffeeImp 是加不加奶的行为接口,看其代码如下:\npublic abstract class CoffeeImp { public abstract void pourCoffeeImp(); } 现在我们有了两个抽象类,下面我们分别对其进行继承,实现concrete class:\n//中杯 public class MediumCoffee extends Coffee { public MediumCoffee() {setCoffeeImp();} public void pourCoffee() { CoffeeImp coffeeImp = this.","title":"2.6 Bridge"},{"content":"Composite(组合模式)定义 将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.\nComposite比较容易理解，想到Composite就应该想到树形结构图。组合体内这些对象都有共同接口,当组合体一个对象的方法被调用执行时，Composite将遍历(Iterator)整个树形结构,寻找同样包含这个方法的对象并实现调用执行。可以用牵一动百来形容。\n所以Composite模式使用到Iterator模式，和Chain of Responsibility模式类似。\n本质 定义 interface 或 abstract class\n核心 在class(继承或实现) 中使用了 arraylist . 可以在其中添加 其他 对象（继承同一class）\nComposite好处 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。 更容易在组合体内加入对象部件. 客户端不必因为加入了新的对象部件而更改代码。 如何使用Composite 首先定义一个接口或抽象类，这是设计模式通用方式了，其他设计模式对接口内部定义限制不多，Composite却有个规定，那就是要在接口内部定义一个用于访问和管理Composite组合体的对象们（或称部件Component）.\n下面的代码是以抽象类定义，一般尽量用接口interface,\npublic abstract class Equipment { private String name; //实价 public abstract double netPrice(); //折扣价格 public abstract double discountPrice(); //增加部件方法　public boolean add(Equipment equipment) { return false; } //删除部件方法 public boolean remove(Equipment equipment) { return false; } //注意这里，这里就提供一种用于访问组合体类的部件方法。 public Iterator iter() { return null; } public Equipment(final String name) { this.name=name; } } 抽象类Equipment就是Component定义，代表着组合体类的对象们,Equipment中定义几个共同的方法。\npublic class Disk extends Equipment { public Disk(String name) { super(name); } //定义Disk实价为1 public double netPrice() { return 1.; } //定义了disk折扣价格是0.5 对折。 public double discountPrice() { return .5; } } Disk是组合体内的一个对象，或称一个部件，这个部件是个单独元素( Primitive)。 还有一种可能是，一个部件也是一个组合体，就是说这个部件下面还有\u0026rsquo;儿子\u0026rsquo;，这是树形结构中通常的情况，应该比较容易理解。现在我们先要定义这个组合体：\nabstract class CompositeEquipment extends Equipment { private int i=0; //定义一个Vector 用来存放\u0026#39;儿子\u0026#39; private Lsit equipment=new ArrayList(); public CompositeEquipment(String name) { super(name); } public boolean add(Equipment equipment) { this.equipment.add(equipment); return true; } public double netPrice() { double netPrice=0.; Iterator iter=equipment.iterator(); for(iter.hasNext()) netPrice+=((Equipment)iter.next()).netPrice(); return netPrice; } public double discountPrice() { double discountPrice=0.; Iterator iter=equipment.iterator(); for(iter.hasNext()) discountPrice+=((Equipment)iter.next()).discountPrice(); return discountPrice; } //注意这里，这里就提供用于访问自己组合体内的部件方法。 //上面dIsk 之所以没有，是因为Disk是个单独(Primitive)的元素. public Iterator iter() { return equipment.iterator() ; { //重载Iterator方法 public boolean hasNext() { return i\u0026lt;equipment.size(); } //重载Iterator方法 public Object next() { if(hasNext()) return equipment.elementAt(i++); else throw new NoSuchElementException(); } } 上面CompositeEquipment继承了Equipment,同时为自己里面的对象们提供了外部访问的方法,重载了Iterator,Iterator是Java的Collection的一个接口，是Iterator模式的实现.\n我们再看看CompositeEquipment的两个具体类:盘盒Chassis和箱子Cabinet，箱子里面可以放很多东西，如底板，电源盒，硬盘盒等；盘盒里面可以放一些小设备，如硬盘 软驱等。无疑这两个都是属于组合体性质的。\npublic class Chassis extends CompositeEquipment { public Chassis(String name) { super(name); } public double netPrice() { return 1.+super.netPrice(); } public double discountPrice() { return .5+super.discountPrice(); } } public class Cabinet extends CompositeEquipment { public Cabinet(String name) { super(name); } public double netPrice() { return 1.+super.netPrice(); } public double discountPrice() { return .5+super.discountPrice(); } } 至此我们完成了整个Composite模式的架构。\n我们可以看看客户端调用Composote代码:\nCabinet cabinet=new Cabinet(\u0026#34;Tower\u0026#34;); Chassis chassis=new Chassis(\u0026#34;PC Chassis\u0026#34;); //将PC Chassis装到Tower中 (将盘盒装到箱子里) cabinet.add(chassis); //将一个10GB的硬盘装到 PC Chassis (将硬盘装到盘盒里) chassis.add(new Disk(\u0026#34;10 GB\u0026#34;)); //调用 netPrice()方法; System.out.println(\u0026#34;netPrice=\u0026#34;+cabinet.netPrice()); System.out.println(\u0026#34;discountPrice=\u0026#34;+cabinet.discountPrice()); 上面调用的方法netPrice()或discountPrice()，实际上Composite使用Iterator遍历了整个树形结构,寻找同样包含这个方法的对象并实现调用执行.\nComposite是个很巧妙体现智慧的模式，在实际应用中，如果碰到树形结构，我们就可以尝试是否可以使用这个模式。\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.4-composite/","summary":"Composite(组合模式)定义 将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.\nComposite比较容易理解，想到Composite就应该想到树形结构图。组合体内这些对象都有共同接口,当组合体一个对象的方法被调用执行时，Composite将遍历(Iterator)整个树形结构,寻找同样包含这个方法的对象并实现调用执行。可以用牵一动百来形容。\n所以Composite模式使用到Iterator模式，和Chain of Responsibility模式类似。\n本质 定义 interface 或 abstract class\n核心 在class(继承或实现) 中使用了 arraylist . 可以在其中添加 其他 对象（继承同一class）\nComposite好处 使客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关系自己处理的是单个对象还是整个组合结构，这就简化了客户端代码。 更容易在组合体内加入对象部件. 客户端不必因为加入了新的对象部件而更改代码。 如何使用Composite 首先定义一个接口或抽象类，这是设计模式通用方式了，其他设计模式对接口内部定义限制不多，Composite却有个规定，那就是要在接口内部定义一个用于访问和管理Composite组合体的对象们（或称部件Component）.\n下面的代码是以抽象类定义，一般尽量用接口interface,\npublic abstract class Equipment { private String name; //实价 public abstract double netPrice(); //折扣价格 public abstract double discountPrice(); //增加部件方法　public boolean add(Equipment equipment) { return false; } //删除部件方法 public boolean remove(Equipment equipment) { return false; } //注意这里，这里就提供一种用于访问组合体类的部件方法。 public Iterator iter() { return null; } public Equipment(final String name) { this.","title":"2.4 Composite"},{"content":"Decorator(装饰者模式) 定义 动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.\n本质 interface(一般都要)\n主要是编写 被装饰者，在构造函数中加入装饰者，然后在被装饰者类中注意对装饰者类的调用\n为什么使用Decorator? 我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.\n使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了\u0026quot;即插即用\u0026quot;的方法,在运行期间决定何时增加何种功能.\n如何使用? 举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.\n我们先建立一个接口:\npublic interface Work { public void insert(); } 接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:\npublic class SquarePeg implements Work{ public void insert(){ System.out.println(\u0026#34;方形桩插入\u0026#34;); } } 现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).\n那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些\u0026quot;油漆\u0026quot;,这些油漆就是那些额外的功能.\npublic class Decorator implements Work{ private Work work; //额外增加的功能被打包在这个List中 private ArrayList others = new ArrayList(); //在构造器中使用组合new方式,引入Work对象; public Decorator(Work work) { this.work=work; others.add(\u0026#34;挖坑\u0026#34;); others.add(\u0026#34;钉木板\u0026#34;); } public void insert(){ newMethod(); } //在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 public void newMethod() { otherMethod(); work.insert(); } public void otherMethod() { ListIterator listIterator = others.listIterator(); while (listIterator.hasNext()) { System.out.println(((String)(listIterator.next())) + \u0026#34; 正在进行\u0026#34;); } } } 在上例中,我们把挖坑和钉木板都排在了打桩insert前面,这里只是举例说明额外功能次序可以任意安排.\n好了,Decorator模式出来了,我们看如何调用:\nWork squarePeg = new SquarePeg(); Work decorator = new Decorator(squarePeg); decorator.insert(); Decorator模式至此完成.\n如果你细心,会发现,上面调用类似我们读取文件时的调用:\nFileReader fr = new FileReader(filename); BufferedReader br = new BufferedReader(fr);\n实际上Java 的I/O API就是使用Decorator实现的,I/O变种很多,如果都采取继承方法,将会产生很多子类,显然相当繁琐.\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.5-decorator/","summary":"Decorator(装饰者模式) 定义 动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.\n本质 interface(一般都要)\n主要是编写 被装饰者，在构造函数中加入装饰者，然后在被装饰者类中注意对装饰者类的调用\n为什么使用Decorator? 我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.\n使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了\u0026quot;即插即用\u0026quot;的方法,在运行期间决定何时增加何种功能.\n如何使用? 举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.\n我们先建立一个接口:\npublic interface Work { public void insert(); } 接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:\npublic class SquarePeg implements Work{ public void insert(){ System.out.println(\u0026#34;方形桩插入\u0026#34;); } } 现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).\n那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些\u0026quot;油漆\u0026quot;,这些油漆就是那些额外的功能.\npublic class Decorator implements Work{ private Work work; //额外增加的功能被打包在这个List中 private ArrayList others = new ArrayList(); //在构造器中使用组合new方式,引入Work对象; public Decorator(Work work) { this.work=work; others.add(\u0026#34;挖坑\u0026#34;); others.add(\u0026#34;钉木板\u0026#34;); } public void insert(){ newMethod(); } //在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 public void newMethod() { otherMethod(); work.","title":"2.5 Decorator"},{"content":"Adapter(适配者模式) 定义 将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份.\n为何使用? 我们经常碰到要将两个没有关系的类组合在一起使用,第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?\n使用Adapter，在这两种接口之间创建一个混合接口(混血儿).\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.3-adapter/","summary":"Adapter(适配者模式) 定义 将两个不兼容的类纠合在一起使用，属于结构型模式,需要有Adaptee(被适配者)和Adaptor(适配器)两个身份.\n为何使用? 我们经常碰到要将两个没有关系的类组合在一起使用,第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?\n使用Adapter，在这两种接口之间创建一个混合接口(混血儿).","title":"2.3 Adapter"},{"content":"Proxy(代理模式)定义 为其他对象提供一种代理以控制对这个对象的访问.\n代理模式是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结构,Proxy是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理.\n为什么要使用Proxy? 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.\n某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况:\n如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.\n如何使用Proxy? 以Jive论坛系统为例,访问论坛系统的用户有多种类型:注册普通用户 论坛管理者 系统管理者 游客,注册普通用户才能发言;论坛管理者可以管理他被授权的论坛;系统管理者可以管理所有事务等,这些权限划分和管理是使用Proxy完成的.\nForum是Jive的核心接口,在Forum中陈列了有关论坛操作的主要行为,如论坛名称 论坛描述的获取和修改,帖子发表删除编辑等.\n在ForumPermissions中定义了各种级别权限的用户:\npublic class ForumPermissions implements Cacheable { /** * Permission to read object. */ public static final int READ = 0; /** * Permission to administer the entire sytem. */ public static final int SYSTEM_ADMIN = 1; /** * Permission to administer a particular forum. */ public static final int FORUM_ADMIN = 2; /** * Permission to administer a particular user. */ public static final int USER_ADMIN = 3; /** * Permission to administer a particular group. */ public static final int GROUP_ADMIN = 4; /** * Permission to moderate threads. */ public static final int MODERATE_THREADS = 5; /** * Permission to create a new thread. */ public static final int CREATE_THREAD = 6; /** * Permission to create a new message. */ public static final int CREATE_MESSAGE = 7; /** * Permission to moderate messages. */ public static final int MODERATE_MESSAGES = 8; ..... public boolean isSystemOrForumAdmin() { return (values[FORUM_ADMIN] || values[SYSTEM_ADMIN]); } ..... } 因此,Forum中各种操作权限是和ForumPermissions定义的用户级别有关系的,作为接口Forum的实现:ForumProxy正是将这种对应关系联系起来.比如,修改Forum的名称,只有论坛管理者或系统管理者可以修改,代码如下:\npublic class ForumProxy implements Forum { private ForumPermissions permissions; private Forum forum; this.authorization = authorization; public ForumProxy(Forum forum, Authorization authorization, ForumPermissions permissions) { this.forum = forum; this.authorization = authorization; this.permissions = permissions; } ..... public void setName(String name) throws UnauthorizedException, ForumAlreadyExistsException { //只有是系统或论坛管理者才可以修改名称 if (permissions.isSystemOrForumAdmin()) { forum.setName(name); } else { throw new UnauthorizedException(); } } ... } 而DbForum才是接口Forum的真正实现,以修改论坛名称为例:\npublic class DbForum implements Forum, Cacheable { ... public void setName(String name) throws ForumAlreadyExistsException { .... this.name = name; //这里真正将新名称保存到数据库中 saveToDb(); .... } ... } 凡是涉及到对论坛名称修改这一事件,其他程序都首先得和ForumProxy打交道,由ForumProxy决定是否有权限做某一样事情,ForumProxy是个名副其实的\u0026quot;网关\u0026quot;,\u0026ldquo;安全代理系统\u0026rdquo;.\n在平时应用中,无可避免总要涉及到系统的授权或安全体系,不管你有无意识的使用Proxy,实际你已经在使用Proxy了.\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.2-proxy/","summary":"Proxy(代理模式)定义 为其他对象提供一种代理以控制对这个对象的访问.\n代理模式是比较有用途的一种模式,而且变种较多,应用场合覆盖从小结构到整个系统的大结构,Proxy是代理的意思,我们也许有代理服务器等概念,代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理.\n为什么要使用Proxy? 授权机制 不同级别的用户对同一对象拥有不同的访问权利,如Jive论坛系统中,就使用Proxy进行授权机制控制,访问论坛有两种人:注册用户和游客(未注册用户),Jive中就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限.\n某个客户端不能直接操作到某个对象,但又必须和那个对象有所互动. 举例两个具体情况:\n如果那个对象是一个是很大的图片,需要花费很长时间才能显示出来,那么当这个图片包含在文档中时,使用编辑器或浏览器打开这个文档,打开文档必须很迅速,不能等待大图片处理完成,这时需要做个图片Proxy来代替真正的图片. 如果那个对象在Internet的某个远端服务器上,直接操作这个对象因为网络速度原因可能比较慢,那我们可以先用Proxy来代替那个对象. 总之原则是,对于开销很大的对象,只有在使用它时才创建,这个原则可以为我们节省很多宝贵的Java内存. 所以,有些人认为Java耗费资源内存,我以为这和程序编制思路也有一定的关系.\n如何使用Proxy? 以Jive论坛系统为例,访问论坛系统的用户有多种类型:注册普通用户 论坛管理者 系统管理者 游客,注册普通用户才能发言;论坛管理者可以管理他被授权的论坛;系统管理者可以管理所有事务等,这些权限划分和管理是使用Proxy完成的.\nForum是Jive的核心接口,在Forum中陈列了有关论坛操作的主要行为,如论坛名称 论坛描述的获取和修改,帖子发表删除编辑等.\n在ForumPermissions中定义了各种级别权限的用户:\npublic class ForumPermissions implements Cacheable { /** * Permission to read object. */ public static final int READ = 0; /** * Permission to administer the entire sytem. */ public static final int SYSTEM_ADMIN = 1; /** * Permission to administer a particular forum. */ public static final int FORUM_ADMIN = 2; /** * Permission to administer a particular user.","title":"2.2 Proxy"},{"content":"Facade (外观 总管模式）定义 为子系统中的一组接口提供一个一致的界面.\n链接\nFacade一个典型应用就是数据库JDBC的应用\n所有程序对数据库访问都是使用改接口,降低系统的复杂性,增加了灵活性.\n如果我们要使用连接池,也只要针对facade接口修改就可以.\n","permalink":"http://blog.chalme.top/posts/design-patterns/2.1-facade/","summary":"Facade (外观 总管模式）定义 为子系统中的一组接口提供一个一致的界面.\n链接\nFacade一个典型应用就是数据库JDBC的应用\n所有程序对数据库访问都是使用改接口,降低系统的复杂性,增加了灵活性.\n如果我们要使用连接池,也只要针对facade接口修改就可以.","title":"2.1 Facade"},{"content":"Builder(建造者模式）定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.\nBuilder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.\n为何使用? 是为了将构建复杂对象的过程和它的部件解耦.注意: 是解耦过程和部件.\n因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.\n如何使用? 首先假设一个复杂对象是由多个部件组成的,Builder模式是把复杂对象的创建和部件的创建分别开来,分别用Builder类和Director类来表示.\n首先,需要一个接口,它定义如何创建复杂对象的各个部件:\npublic interface Builder { //创建部件A　比如创建汽车车轮 void buildPartA(); //创建部件B 比如创建汽车方向盘 void buildPartB(); //创建部件C 比如创建汽车发动机 void buildPartC(); //返回最后组装成品结果 (返回最后装配好的汽车) //成品的组装过程不在这里进行,而是转移到下面的Director类中进行. //从而实现了解耦过程和部件 Product getResult(); } 用Director构建最后的复杂对象,而在上面Builder接口中封装的是如何创建一个个部件(复杂对象是由这些部件组成的),也就是说Director的内容是如何将部件最后组装成成品:\npublic class Director { private Builder builder; public Director( Builder builder ) { this.builder = builder; } // 将部件partA partB partC最后组成复杂对象 //这里是将车轮 方向盘和发动机组装成汽车的过程 public void construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); } } Builder的具体实现ConcreteBuilder:\n通过具体完成接口Builder来构建或装配产品的部件; 定义并明确它所要创建的是什么具体东西; 提供一个可以重新获取产品的接口: public class ConcreteBuilder implements Builder { Part partA, partB, partC; public void buildPartA() { //这里是具体如何构建partA的代码 }; public void buildPartB() { //这里是具体如何构建partB的代码 }; public void buildPartC() { //这里是具体如何构建partB的代码 }; public Product getResult() { //返回最后组装成品结果 }; } 复杂对象:产品Product:\npublic interface Product { } 复杂对象的部件:\npublic interface Part { } 我们看看如何调用Builder模式:\nConcreteBuilder builder = new ConcreteBuilder(); Director director = new Director( builder ); director.construct(); Product product = builder.getResult(); 应用 在Java实际使用中,我们经常用到\u0026quot;池\u0026quot;(Pool)的概念,当资源提供者无法提供足够的资源,并且这些资源需要被很多用户反复共享时,就需要使用池.\n\u0026ldquo;池\u0026quot;实际是一段内存,当池中有一些复杂的资源的\u0026quot;断肢\u0026rdquo;(比如数据库的连接池,也许有时一个连接会中断),如果循环再利用这些\u0026quot;断肢\u0026quot;,将提高内存使用效率,提高池的性能.修改Builder模式中Director类使之能诊断\u0026quot;断肢\u0026quot;断在哪个部件上,再修复这个部件.\n","permalink":"http://blog.chalme.top/posts/design-patterns/1.4-builder/","summary":"Builder(建造者模式）定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.\nBuilder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节.Builder模式是非常类似抽象工厂模式,细微的区别大概只有在反复使用中才能体会到.\n为何使用? 是为了将构建复杂对象的过程和它的部件解耦.注意: 是解耦过程和部件.\n因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.\n如何使用? 首先假设一个复杂对象是由多个部件组成的,Builder模式是把复杂对象的创建和部件的创建分别开来,分别用Builder类和Director类来表示.\n首先,需要一个接口,它定义如何创建复杂对象的各个部件:\npublic interface Builder { //创建部件A　比如创建汽车车轮 void buildPartA(); //创建部件B 比如创建汽车方向盘 void buildPartB(); //创建部件C 比如创建汽车发动机 void buildPartC(); //返回最后组装成品结果 (返回最后装配好的汽车) //成品的组装过程不在这里进行,而是转移到下面的Director类中进行. //从而实现了解耦过程和部件 Product getResult(); } 用Director构建最后的复杂对象,而在上面Builder接口中封装的是如何创建一个个部件(复杂对象是由这些部件组成的),也就是说Director的内容是如何将部件最后组装成成品:\npublic class Director { private Builder builder; public Director( Builder builder ) { this.builder = builder; } // 将部件partA partB partC最后组成复杂对象 //这里是将车轮 方向盘和发动机组装成汽车的过程 public void construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); } } Builder的具体实现ConcreteBuilder:\n通过具体完成接口Builder来构建或装配产品的部件; 定义并明确它所要创建的是什么具体东西; 提供一个可以重新获取产品的接口: public class ConcreteBuilder implements Builder { Part partA, partB, partC; public void buildPartA() { //这里是具体如何构建partA的代码 }; public void buildPartB() { //这里是具体如何构建partB的代码 }; public void buildPartC() { //这里是具体如何构建partB的代码 }; public Product getResult() { //返回最后组装成品结果 }; } 复杂对象:产品Product:","title":"1.4 Builder"},{"content":"Singleton (单例模式）定义 Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。\n在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作. 还有, singleton能够被状态化; 这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要论坛中的帖子计数器，每次浏览一次需要计数，单态类能否保持住这个计数，并且能synchronize的安全自动加1，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。\n另外方面，Singleton也能够被无状态化。提供工具性质的功能，\nSingleton模式就为我们提供了这样实现的可能。使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。\n我们常常看到工厂模式中类装入器(class loader)中也用Singleton模式实现的,因为被装入的类实际也属于资源。\n如何使用 public class Singleton { private Singleton(){} //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问　public static Singleton getInstance() { return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class TestInstance{ private static TestInstance instance; public static TestInstance getInstance{ if(instance==null){ synchronized(TestInstance.class){ if(instance==null){ instance=new TestInstance(); } } return instance; } } public class SingleClass2{ private static class SingleInstance{ private static SingleClass2 instance = new SingleClass2(); } private SingleClass2(){ } public static SingleClass2 CreateInstance(){ return SingleInstance.instance; } } ","permalink":"http://blog.chalme.top/posts/design-patterns/1.3-singleton/","summary":"Singleton (单例模式）定义 Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。\n在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作. 还有, singleton能够被状态化; 这样，多个单态类在一起就可以作为一个状态仓库一样向外提供服务，比如，你要论坛中的帖子计数器，每次浏览一次需要计数，单态类能否保持住这个计数，并且能synchronize的安全自动加1，如果你要把这个数字永久保存到数据库，你可以在不修改单态接口的情况下方便的做到。\n另外方面，Singleton也能够被无状态化。提供工具性质的功能，\nSingleton模式就为我们提供了这样实现的可能。使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回收（garbage collection）。\n我们常常看到工厂模式中类装入器(class loader)中也用Singleton模式实现的,因为被装入的类实际也属于资源。\n如何使用 public class Singleton { private Singleton(){} //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问　public static Singleton getInstance() { return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } public class TestInstance{ private static TestInstance instance; public static TestInstance getInstance{ if(instance==null){ synchronized(TestInstance.","title":"1.3 Singleton"},{"content":"Prototype Prototype （原型模式）定义 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 使用 java中有 clone 方法来实现对象的克隆，所以。。。 以 勺子为例\npublic abstract class AbstractSpoon implements Cloneable { String spoonName; public void setSpoonName(String spoonName) {this.spoonName = spoonName;} public String getSpoonName() {return this.spoonName;} public Object clone() { Object object = null; try { object = super.clone(); } catch (CloneNotSupportedException exception) { System.err.println(\u0026#34;AbstractSpoon is not Cloneable\u0026#34;); } return object; } } public class SoupSpoon extends AbstractSpoon { public SoupSpoon() { setSpoonName(\u0026#34;Soup Spoon\u0026#34;); } } 调用Prototype模式很简单:\nAbstractSpoon spoon = new SoupSpoon(); AbstractSpoon spoon2 = spoon.clone(); 当然也可以结合工厂模式来创建AbstractSpoon实例。 实质： java 使用object 类的clone 方法\n","permalink":"http://blog.chalme.top/posts/design-patterns/1.2-prototype/","summary":"Prototype Prototype （原型模式）定义 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象. Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 使用 java中有 clone 方法来实现对象的克隆，所以。。。 以 勺子为例\npublic abstract class AbstractSpoon implements Cloneable { String spoonName; public void setSpoonName(String spoonName) {this.spoonName = spoonName;} public String getSpoonName() {return this.spoonName;} public Object clone() { Object object = null; try { object = super.clone(); } catch (CloneNotSupportedException exception) { System.err.println(\u0026#34;AbstractSpoon is not Cloneable\u0026#34;); } return object; } } public class SoupSpoon extends AbstractSpoon { public SoupSpoon() { setSpoonName(\u0026#34;Soup Spoon\u0026#34;); } } 调用Prototype模式很简单:","title":"1.2 Prototype"},{"content":"工厂模式定义 提供创建对象的接口\n详细1\n详细2\n简介 简单工厂模式\n工厂方法模式\n抽象工厂模式\n简单工厂模式 它由三种角色组成（关系见下面的类图）：\n工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。\n抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。\n具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。\n本质 : 在Creator 中 create 方法中 使用 equals(string name)方法来创建 Product。\n//抽象产品角色 public interface Car{ public void drive(); } //具体产品角色 public class Benz implements Car{ public void drive() { System.out.println(\u0026#34;Driving Benz \u0026#34;); } } public class Bmw implements Car{ public void drive() { System.out.println(\u0026#34;Driving Bmw \u0026#34;); } } 。。。（奥迪我就不写了:P） //工厂类角色 public class Driver{ //工厂方法 //注意 返回类型为抽象产品角色 public static Car driverCar(String s)throws Exception { //判断逻辑，返回具体的产品角色给Client if(s.equalsIgnoreCase(\u0026#34;Benz\u0026#34;)) return new Benz(); else if(s.equalsIgnoreCase(\u0026#34;Bmw\u0026#34;)) return new Bmw(); ...... else throw new Exception(); 。。。 //欢迎暴发户出场...... public class Magnate{ public static void main(String[] args){ try{ //告诉司机我今天坐奔驰 Car car = Driver.driverCar(\u0026#34;benz\u0026#34;); //下命令：开车 car.drive(); 。。。 工厂方法模式 先来看下它的组成吧：\n抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4、具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 //抽象工厂角色 public interface Driver{ public Car driverCar(); } public class BenzDriver implements Driver{ public Car driverCar(){ return new Benz(); } } public class BmwDriver implements Driver{ public Car driverCar() { return new Bmw(); } } ......//应该和具体产品形成对应关系，这里略... //有请暴发户先生 public class Magnate { public static void main(String[] args) { try{ Driver driver = new BenzDriver(); Car car = driver.driverCar(); car.drive(); }catch(Exception e) { } } } 抽象工厂模式 抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。而且使用抽象工厂模式还要满足一下条件：\n系统中有多个产品族，而系统一次只可能消费其中一族产品 同属于同一个产品族的产品一起使用时。 来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：\n抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 ","permalink":"http://blog.chalme.top/posts/design-patterns/1.1-factory/","summary":"工厂模式定义 提供创建对象的接口\n详细1\n详细2\n简介 简单工厂模式\n工厂方法模式\n抽象工厂模式\n简单工厂模式 它由三种角色组成（关系见下面的类图）：\n工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。\n抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。\n具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。\n本质 : 在Creator 中 create 方法中 使用 equals(string name)方法来创建 Product。\n//抽象产品角色 public interface Car{ public void drive(); } //具体产品角色 public class Benz implements Car{ public void drive() { System.out.println(\u0026#34;Driving Benz \u0026#34;); } } public class Bmw implements Car{ public void drive() { System.out.println(\u0026#34;Driving Bmw \u0026#34;); } } 。。。（奥迪我就不写了:P） //工厂类角色 public class Driver{ //工厂方法 //注意 返回类型为抽象产品角色 public static Car driverCar(String s)throws Exception { //判断逻辑，返回具体的产品角色给Client if(s.","title":"1.1 Factory"},{"content":"设计模式(Patterns in Java) 链接 另类的设计模式\n图说设计模式\n如今设计模式已经成为架构师和程序员之间沟通的必备语言，也是普通程序员成长为资深程序员的必备基础之一。只有掌握了设计模式，才能更好地掌握DDD领域驱动设计等OO分析设计方法，也才能更熟练地学习使用不断涌现的新语言。\n创建模式（5） Factory(工厂模式）\nPrototype(原型模式）\nBuilder\nSingleton(单例模式）\n结构模式（7） Facade\nProxy\nAdapter\nComposite\nDecorator\nBridge\nFlyweight\n行为模式（11） Template(模板模式）\nMemento(备忘录模式）\nObserver(观察者模式）\nChain of Responsibility(CoR)\nCommand\nState\nStrategy\nmediator\nInterperter\nVivistor\nIterator\n","permalink":"http://blog.chalme.top/posts/design-patterns/0.0-outline/","summary":"设计模式(Patterns in Java) 链接 另类的设计模式\n图说设计模式\n如今设计模式已经成为架构师和程序员之间沟通的必备语言，也是普通程序员成长为资深程序员的必备基础之一。只有掌握了设计模式，才能更好地掌握DDD领域驱动设计等OO分析设计方法，也才能更熟练地学习使用不断涌现的新语言。\n创建模式（5） Factory(工厂模式）\nPrototype(原型模式）\nBuilder\nSingleton(单例模式）\n结构模式（7） Facade\nProxy\nAdapter\nComposite\nDecorator\nBridge\nFlyweight\n行为模式（11） Template(模板模式）\nMemento(备忘录模式）\nObserver(观察者模式）\nChain of Responsibility(CoR)\nCommand\nState\nStrategy\nmediator\nInterperter\nVivistor\nIterator","title":"0.0 outline"},{"content":"关于容器技术 容器定义 首先必须是一个相对独立的运行环境，在这一点上，有点类似虚拟机的概念，但又没有虚拟机那样彻底。另外，在一个容器环境内，应该最小化其对外界的影响，比如不能在容器中把 host 上的资源全部消耗掉，这就是资源控制。\n容器技术已经集成到了 Linux 内核中，已经被当作 Linux 内核原生提供的特性。\n容器技术主要包括Namespace和Cgroup两个内核特性。\nNamespace 又称命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象， 并将其封装在一起提供给一个容器使用，对于这类资源，因 为每个容器都有自己的抽象，而它们彼此之间是不可见的，所以就可以 做到访问隔离。 Cgroup 是 control group 的简称，又称控制组，它主要是做资源控制。 其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的 可用资源，达到控制这一组进程可用资源的目的。 实际上，Namespace 和 Cgroup 并不是强相关的两种技术，用户可以根据需要单 独使用他们，比如单独使用 Cgroup 做资源管理，就是一种比较常见的做法。而 如果把他们应用到一起，在一个 Namespace 中的进程恰好又在一个 Cgroup 中， 那么这些进程就既有访问隔离，又有资源控制，符合容器的特性，这样就创建 了一个容器。\n理解容器 容器的核心技术是 Cgroup + Namespace ，但光有这两个抽象的技术概念是无 法组成容器。Linux 容器的最小组成，可以由以下公式来表示：\n容器 = cgroup + namespace + rootfs + 容器引擎（用户态工具） 其各项功能分别是：\nCgroup：资源控制。 Namespace： 访问控制。 rootfs：文件系统隔离。 容器引擎：生命周期控制。 容器的创建原理。\n代码一： pid = clone(fun, stack, flags, clone_arg); (flags: CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWipc | CLONE_NEWuts | ...) 代码二： echo $pid \u0026gt; /sys/fs/cgroup/cpu/tasks echo $pid \u0026gt; /sys/fs/cgroup/cpuset/tasks echo $pid \u0026gt; /sys/fs/cgroup/blkio/tasks echo $pid \u0026gt; /sys/fs/cgroup/memory/tasks echo $pid \u0026gt; /sys/fs/cgroup/devices/tasks echo $pid \u0026gt; /sys/fs/cgroup/freezer/tasks 代码三： fun() { ... pivot_root(\u0026#34;path_of_rootfs/\u0026#34;, path); ... exec(\u0026#34;/bin/bash\u0026#34;); ... } 代码一，通过 clone 系统调用，并传入各个 Namespace 对应的 clone flag ，创建了一个新的子进程，该进程拥有自己的 Namespace。根据以上代码 可知，该进程拥有自己的 pid、mount、user、net、ipc、uts namespace 。 代码二，将代码一中的进程 pid 写入各个 Cgroup 子系统中，这样该进程就 可以受到相应 Cgroup 子系统的控制。 代码三，该 fun 函数由上面生成的新进程执行，在 fun 函数中，通过 pivot_root 系统调用，使进程进入一个新的 rootfs，之后通过 exec 系统 调用，在新的 Namespace、Cgroup、 rootfs 中执行\u0026quot;/bin/bash\u0026quot;程序。 通过以上操作，成功地在一个“容器”中运行了一个 bash 程序。\nCgroup 介绍 Cgroup 是什么 Cgroup 是 control group 的简写，属于 Linux 内核提供的一个特性，用于限制和隔离一组 进程对系统资源的使用，也就是做资源 QoS，这些资源主要包括 CPU、内存、block I/O 和网 络带宽。\n从实现的角度来看，Cgroup 实现了一个通用的进程分组的框架，而不同资源的具体管理则 是由各个 Cgroup 子系统实现的。截止到内核 4.1 版本，Cgroup 中实现的子系统及其作用如下： devices：设备权限控制。 cpuset：分配指定的 CPU 和内存节点。 cpu：控制 CPU 占用率。 cpuacct：统计 CPU 使用情况。 memory：限制内存的使用上限。 freezer：冻结（暂停）Cgroup 中的进程。 net_cls：配合 tc（traffic controller）限制网络带宽。 net_prio：设置进程的网络流量优先级。 huge_tlb：限制 HugeTLB 的使用。 perf_event：允许 Perf 工具基于 Cgroup 分组做性能检测。 在 Cgroup 出现之前，只能对一个进程做一些资源控制。 Namespace 介绍 Namespace 是什么 Namespace 是将内核的全局资源做封装，使得每个 Namespace 都有一份独立的资源，因此不同的进程在各自的 Namespace 内对同一种资源的使用不会互相干扰。\n目前 Linux 内核总共实现了 6 种 Namespace: IPC: 隔离 System V IPC 和 POSIX 消息队列。 Network：隔离网络资源。 Mount：隔离文件系统挂载点。 PID：隔离进程 ID。 UTS：隔离主机名和域名。 User：隔离用户 ID 和组 ID。 最后 很失望目前不能继续下去。我读的这本书是docker进阶与实践，确实是进阶，之前没有了解过 docker，现在写的基本都是在摘抄书上的内容，摘抄并没有错，但是确实理解不是特别 深刻，过段时间，在读。\n","permalink":"http://blog.chalme.top/posts/%E5%AE%B9%E5%99%A8/%E5%85%B3%E4%BA%8E%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/","summary":"关于容器技术 容器定义 首先必须是一个相对独立的运行环境，在这一点上，有点类似虚拟机的概念，但又没有虚拟机那样彻底。另外，在一个容器环境内，应该最小化其对外界的影响，比如不能在容器中把 host 上的资源全部消耗掉，这就是资源控制。\n容器技术已经集成到了 Linux 内核中，已经被当作 Linux 内核原生提供的特性。\n容器技术主要包括Namespace和Cgroup两个内核特性。\nNamespace 又称命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象， 并将其封装在一起提供给一个容器使用，对于这类资源，因 为每个容器都有自己的抽象，而它们彼此之间是不可见的，所以就可以 做到访问隔离。 Cgroup 是 control group 的简称，又称控制组，它主要是做资源控制。 其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的 可用资源，达到控制这一组进程可用资源的目的。 实际上，Namespace 和 Cgroup 并不是强相关的两种技术，用户可以根据需要单 独使用他们，比如单独使用 Cgroup 做资源管理，就是一种比较常见的做法。而 如果把他们应用到一起，在一个 Namespace 中的进程恰好又在一个 Cgroup 中， 那么这些进程就既有访问隔离，又有资源控制，符合容器的特性，这样就创建 了一个容器。\n理解容器 容器的核心技术是 Cgroup + Namespace ，但光有这两个抽象的技术概念是无 法组成容器。Linux 容器的最小组成，可以由以下公式来表示：\n容器 = cgroup + namespace + rootfs + 容器引擎（用户态工具） 其各项功能分别是：\nCgroup：资源控制。 Namespace： 访问控制。 rootfs：文件系统隔离。 容器引擎：生命周期控制。 容器的创建原理。\n代码一： pid = clone(fun, stack, flags, clone_arg); (flags: CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWipc | CLONE_NEWuts | .","title":"关于容器技术"},{"content":"对于指针的确我之前还没真正了解，一次面试暴露无遗。确实还是应该好好学习一下指针。\n今天看了一篇文章，确实还是挺详细的。 点此进入\n了解指针一般要清楚 3 点\n指针的类型 指针所指向的类型 指针的值 具体请看原文\n","permalink":"http://blog.chalme.top/posts/history/%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%A6%E8%A7%A3/","summary":"对于指针的确我之前还没真正了解，一次面试暴露无遗。确实还是应该好好学习一下指针。\n今天看了一篇文章，确实还是挺详细的。 点此进入\n了解指针一般要清楚 3 点\n指针的类型 指针所指向的类型 指针的值 具体请看原文","title":"指针的详解"},{"content":"今天这是我写的第一篇博客，不知道在使用 git 中遇到过下面的问题 :\n自己配置了全局的用户信息，然后我们却有两个或两个之上 的 git 账号在不同的服务器上(比如 github, csdn),或者我们正在做两个以上项目(在 github)需要配置不同 ssh， 我们的用户信息却 不同, 但是我们却不能配置两个全局信息。为了使用 ssh 服务，避免每次都要输入用户密码，我们 还是要使用秘钥来配置。\n其实这就是个坑 当我们是新手时，每次看到教程都要配置全局的个人信息(user.name, user.email)，虽然它比较简单，但确实导致 了一些使用的问题。 切入正题，解决方案：\n我们不要使用使用全局的用户信息配置，改成在项目内部配置。\ngit config user.name \u0026#34;username\u0026#34; git config user.email \u0026#34;XXX@email.com\u0026#34; 配置公钥时，需要在~/.ssh目录下添加一个 config 的文件,格式如下\nHost 名称(自己决定，方便输入记忆的) HostName 主机名 User 登录的用户名 IdentityFile 私钥地址 例子\n#github \u0026#34;注释 Host github.com \u0026#34; 简称 HostName github.com \u0026#34; 服务器地址 User chalme \u0026#34; 用户名 IdentityFile ~/.ssh/id_rsa \u0026#34; 公钥地址 Host code.csdn.net HostName code.csdn.net User chalme IdentityFile ~/.ssh/id_rsa_csdn Host A HostName github.com User B IdentityFile ~/.ssh/id_rsa_csdn ","permalink":"http://blog.chalme.top/posts/history/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh%E7%94%A8%E6%88%B7/","summary":"今天这是我写的第一篇博客，不知道在使用 git 中遇到过下面的问题 :\n自己配置了全局的用户信息，然后我们却有两个或两个之上 的 git 账号在不同的服务器上(比如 github, csdn),或者我们正在做两个以上项目(在 github)需要配置不同 ssh， 我们的用户信息却 不同, 但是我们却不能配置两个全局信息。为了使用 ssh 服务，避免每次都要输入用户密码，我们 还是要使用秘钥来配置。\n其实这就是个坑 当我们是新手时，每次看到教程都要配置全局的个人信息(user.name, user.email)，虽然它比较简单，但确实导致 了一些使用的问题。 切入正题，解决方案：\n我们不要使用使用全局的用户信息配置，改成在项目内部配置。\ngit config user.name \u0026#34;username\u0026#34; git config user.email \u0026#34;XXX@email.com\u0026#34; 配置公钥时，需要在~/.ssh目录下添加一个 config 的文件,格式如下\nHost 名称(自己决定，方便输入记忆的) HostName 主机名 User 登录的用户名 IdentityFile 私钥地址 例子\n#github \u0026#34;注释 Host github.com \u0026#34; 简称 HostName github.com \u0026#34; 服务器地址 User chalme \u0026#34; 用户名 IdentityFile ~/.ssh/id_rsa \u0026#34; 公钥地址 Host code.csdn.net HostName code.csdn.net User chalme IdentityFile ~/.ssh/id_rsa_csdn Host A HostName github.","title":"Git配置多个ssh用户"},{"content":"","permalink":"http://blog.chalme.top/categories/","summary":"categories","title":"Category"}]