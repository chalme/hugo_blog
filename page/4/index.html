<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.131.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Chalme</title>
<meta name=description content><meta name=author content="Me"><link rel=canonical href=http://blog.chalme.top/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://blog.chalme.top/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://blog.chalme.top/favicon_io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://blog.chalme.top/favicon_io/favicon-32x32.png><link rel=apple-touch-icon href=http://blog.chalme.top/favicon_io/apple-touch-icon.png><link rel=mask-icon href=http://blog.chalme.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://blog.chalme.top/index.xml><link rel=alternate type=application/json href=http://blog.chalme.top/index.json><link rel=alternate hreflang=en href=http://blog.chalme.top/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Chalme"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://blog.chalme.top/"><meta property="og:image" content="http://blog.chalme.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Chalme"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.chalme.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Chalme"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Chalme","url":"http://blog.chalme.top/","description":"","thumbnailUrl":"http://blog.chalme.top/favicon_io/favicon.ico","sameAs":["https://github.com/chalme"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://blog.chalme.top/ accesskey=h title="Chalme (Alt + H)"><img src=http://blog.chalme.top/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Chalme</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.chalme.top/archives title=Archive><span>Archive</span></a></li><li><a href=http://blog.chalme.top/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.chalme.top/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式关键设计 性能设计</h2></header><div class=entry-content><p>缓存 基本上来说，在分布式系统中最耗性能的地方就是最后端的数据库了。
一般来说，只要小心维护好，数据库四种操作（select、update、insert 和 delete）中的三个写操作 insert、update 和 delete 不太会出现性能问题（insert 一般不会有性能问题，update 和 delete 一般会有主键，所以也不会太慢）。除非索引建得太多，而数据库里的数据又太多，这三个操作才会变慢。 绝大多数情况下，select 是出现性能问题最大的地方。一方面，select 会有很多像 join、group、order、like 等这样丰富的语义，而这些语义是非常耗性能的；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。 分布式系统中远程调用也会消耗很多资源，因为网络开销会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。 设计的重点：
在分布式架构下，一般都需要一个外部的缓存集群。关于这个缓存集群，你需要保证的是内存要足够大，网络带宽也要好，因为缓存本质上是个内存和 IO 密集型的应用。 缓存的好坏要看命中率。缓存的命中率高说明缓存有效，一般来说命中率到 80% 以上就算很高了。当然，有的网络为了追求更高的性能，要做到 95% 以上，甚至可能会把数据库里的数据几乎全部装进缓存中。 缓存是通过牺牲强一致性来提高性能的，这世上任何事情都不是免费的 缓存数据的时间周期也需要好好设计 使用缓存的时候，一般会使用 LRU 策略 缓存是提高性能最好的方式，一般来说，缓存有以下三种模式。
Cache Aside 更新模式 失效：应用程序先从 Cache 取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从 Cache 中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。
当然，最好还是为缓存设置好过期时间。
为什么不去直接更新？ 主要是怕两个并发的写操作导致脏数据。
Cache Aside 就不会有并发问题了？ 比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。
Read/Write Through 更新模式 缓存由数据库代理。 缓存和数据库为一体。
wirte 更新模式 直接写数据库， 通过中间件（精卫）写入缓存。
异步处理 异步通讯的设计模式 ： 提高系统的稳定性和容错能力。 增加整个系统的吞吐量，从而可以面对更高的并发，并可以从容地利用好现有的系统资源。
当你在做一件事的时候，如果有别人来找你做其它事，你就会被打断而要去干别的事。而如果你可以统筹安排这些事情，本来五件事只需要 2 个小时，如果不能，或者老被别人打乱思路，那你可能就要花 5 个小时。异步处理任务可以让你更好地利用好时间和资源。利用好了时间和资源，性能自然就会提升上来。...</p></div><footer class=entry-footer><span title='2023-01-27 23:53:17 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;281 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 分布式关键设计 性能设计" href=http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1-%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式关键设计 管理设计</h2></header><div class=entry-content><p>分布式锁 场景： 我们知道，在多线程情况下访问一些共享资源需要加锁，不然就会出现数据被写乱的问题。分布式环境下， 这样的问题也是一样的。只不过，我们需要一个分布式的锁服务。对于分布式的锁服务，一般可以用数据库 DB、Redis 和 ZooKeeper 等实现。
特点： 安全性（Safety）：在任意时刻，只有一个客户端可以获得锁（排他性）。 避免死锁：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。 容错性：只要锁服务集群中的大部分节点存活，Client 就可以进行加锁解锁操作。
设计： 我是用来修改某个共享源的，还是用来不同进程间的同步或是互斥的。如果使用 CAS 这样的方式（无锁方式）来更新数据，那么我们是不需要使用分布式锁服务的，而后者可能是需要的。 一般可以使用数据库、Redis 或 ZooKeeper 来做分布式锁服务。
需要给一个锁被释放的方式，以避免请求者不把锁还回来，导致死锁的问题。 超时时间。 分布式锁服务应该是高可用的，而且是需要持久化的。 要提供非阻塞方式的锁服务。 还要考虑锁的可重入性。 具体实现 redis：
SET resource_name my_random_value NX PX 30000 if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 end 问题： 解决方案： 乐观锁，版本号递增；
锁服务的时候，单调递增的版本号； 写数据的时候也需要增加版本号； 数据库保存版本号， 对情况进行校验； 从乐观锁到 CAS 数据库中也保留着版本号 ， 可以使用 乐观锁处理(fence token)； UPDATE table_name SET xxx = #{xxx}, version=version+1 where version =#{version}; 数据库那边一般会用 timestamp 时间截来玩。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。...</p></div><footer class=entry-footer><span title='2023-01-27 23:52:31 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;392 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 分布式关键设计 管理设计" href=http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1-%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式关键设计 弹力设计</h2></header><div class=entry-content><p>隔离设计 按服务的种类来做分离： 比如： 我们将系统分成了用户、商品、社区三个板块。 不好： 如果我们需要同时获得多个板块的数据，那么就需要调用多个服务，这会降低性能。注意，这里性能降低指的是响应时间，而不是吞吐量（相反，在这种架构下，吞吐量可以得到提高）。 一般： 很多： 这样的系统通常会引入大量的异步处理模型。
按用户的请求来做分离 多租户 ： 我们将用户分成不同的组，并把后端的同一个服务根据这些不同的组分成不同的实例。 完全独立的设计。每个租户有自己完全独立的服务和数据。 独立的数据分区，共享的服务。多租户的服务是共享的，但数据是分开隔离的。 共享的服务，共享的数据分区。每个租户的数据和服务都是共享的。 分析 如果使用完全独立的方案，在开发实现上和资源隔离度方面会非常好，然而，成本会比较高，计算资源也会有一定的浪费。如果使用完全共享的方案，在资源利用和成本上会非常好，然而，开发难度非常大，而且数据和资源隔离非常不好。
隔离设计的重点 我们需要定义好隔离业务的大小和粒度，过大和过小都不好。这需要认真地做业务上的需求和系统分析。 无论是做系统板块还是多租户的隔离，你都需要考虑系统的复杂度、成本、性能、资源使用的问题，找到一个合适的均衡方案，或是分布实施的方案尤其重要，这其中需要你定义好要什么和不要什么。因为，我们不可能做出一个什么都能满足的系统。 隔离模式需要配置一些高可用、重试、异步、消息中间件，流控、熔断等设计模式的方式配套使用。 不要忘记了分布式系统中的运维的复杂度的提升，要能驾驭得好的话，还需要很多自动化运维的工具，尤其是使用像容器或是虚拟机这样的虚拟化技术可以帮助我们更方便地管理，和对比资源更好地利用。否则做出来了也管理不好。 最后，你需要一个非常完整的能够看得到所有服务的监控系统，这点非常重要。 异步通讯设计 同步调用虽然让系统间只耦合于接口，而且实时性也会比异步调用要高，但是我们也需要知道同步调用会带来如下几个问题。
同步调用需要被调用方的吞吐不低于调用方的吞吐。 同步调用会导致调用方一直在等待被调用方完成，如果一层接一层地同步调用下去，所有的参与方会有相同的等待时间。这会非常消耗调用方的资源。因为调用方需要保存现场（Context）等待远端返回，所以对于并发比较高的场景来说，这样的等待可能会极度消耗资源。 同步调用只能是一对一的，很难做到一对多。 同步调用最不好的是，如果被调用方有问题，那么其调用方就会跟着出问题，于是会出现多米诺骨牌效应，故障一下就蔓延开来。 异步通讯的三种方式 请求响应式。 在这种情况下，发送方（sender）会直接请求接收方（receiver），被请求方接收到请求后，直接返回——收到请求，正在处理。对于返回结果，有两种方法，一种是发送方时不时地去轮询一下，问一下干没干完。另一种方式是发送方注册一个回调方法，也就是接收方处理完后回调请求方。 通过订阅的方式。 这种情况下，接收方（receiver）会来订阅发送方（sender）的消息，发送方会把相关的消息或数据放到接收方所订阅的队列中，而接收方会从队列中获取数据。 通过 Broker 的机制。 所谓 Broker，就是一个中间人，发送方（sender）和接收方（receiver）都互相看不到对方，它们看得到的是一个 Broker，发送方向 Broker 发送消息，接收方向 Broker 订阅消息。 事件驱动设计 事件驱动最好是使用 Broker 方式，服务间通过交换消息来完成交流和整个流程的驱动。 事件驱动方式的好处
服务间的依赖没有了，服务间是平等的，每个服务都是高度可重用并可被替换的。 服务的开发、测试、运维，以及故障处理都是高度隔离的。 服务间通过事件关联，所以服务间是不会相互 block 的。 在服务间增加一些 Adapter（如日志、认证、版本、限流、降级、熔断等）相当容易。 服务间的吞吐也被解开了，各个服务可以按照自己的处理速度处理。 坏处：
业务流程不再那么明显和好管理。整个架构变得比较复杂。解决这个问题需要有一些可视化的工具来呈现整体业务流程。 事件可能会乱序。这会带来非常 Bug 的事。解决这个问题需要很好地管理一个状态机的控制。 事务处理变得复杂。需要使用两阶段提交来做强一致性，或是退缩到最终一致性。 幂等性设计 订单创建接口，第一次调用超时了，然后调用方重试了一次。是否会多创建一笔订单？
两种处理方式。
超时下游系统提供相应的查询接口。 通过幂等性的方式。 对于第一种方式，需要对方提供一个查询接口来做配合。而第二种方式则需要下游的系统提供支持幂等性的交易接口。...</p></div><footer class=entry-footer><span title='2023-01-27 23:51:23 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;413 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 分布式关键设计 弹力设计" href=http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1-%E5%BC%B9%E5%8A%9B%E8%AE%BE%E8%AE%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式关键设计概述</h2></header><div class=entry-content><p>分布式系统中一些比较关键的设计模式，其中包括容错、性能、管理等几个方面。
容错设计又叫弹力设计，其中着眼于分布式系统的各种“容忍”能力，包括容错能力（服务隔离、异步调用、请求幂等性）、可伸缩性（有 / 无状态的服务）、一致性（补偿事务、重试）、应对大流量的能力（熔断、降级）。可以看到，在确保系统正确性的前提下，系统的可用性是弹力设计保障的重点。 管理篇会讲述一些管理分布式系统架构的一些设计模式，比如网关方面的，边车模式，还有一些刚刚开始流行的，如 Service Mesh 相关的设计模式。 性能设计篇会讲述一些缓存、CQRS、索引表、优先级队列、业务分片等相关的架构模式。
故障原因 网络问题。网络链接出现问题，网络带宽出现拥塞…… 性能问题。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足…… 安全问题。被网络攻击，如 DDoS 等。 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题…… 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……</p></div><footer class=entry-footer><span title='2023-01-27 23:49:49 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;23 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 分布式关键设计概述" href=http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式理论前言</h2></header><div class=entry-content><p>此系列主要是阅读陈皓极客时间的课程《左耳听风》的分布式理论笔记。非常系统的讲解分布式系统的方方面面。
分布式 主要是两个：
增大系统容量 加强系统可用 另外：
系统模块化，重用性提高 开发和发布 并行，更快 系统扩展性 团队协作 微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线……还有像 Kubernetes 提供的各式各样的部署和调度方式。
没有这些 PaaS 层的支撑，微服务也是很难被管理和运维的。
技术栈 提供系统的性能 缓存系统。 从前端的浏览器，到网络，服务，数据库，文件系统，磁盘和 CPU。 负载均衡技术。 是水平扩展的关键技术。 异步调用。 数据分区和数据镜像。 数据分区是把数据按一定方式分成多个区。每个不同的数据区分担不同区的流量。 数据镜像。 把一个数据库镜像 成多分一样的数据。 提高架构的稳定性 服务拆分。两个目的： 隔离故障，重用。 引入 服务依赖的问题。 服务冗余。 目的： 去除单点故障，并可以弹性伸缩和故障转移。 限流降级。 系统扛不住压力。 只能通过限流 ， 拒绝一部分用户。功能降级，停掉一部分服务。 高可用架构。 比如，多租户隔离，灾备多活。 冗余 不出单点故障。 高可用运维。 DevOps 中的 CI/CD（持续集成/持续部署）。 一个良好的运维应该是一条很流畅的发布管线。其中做了足够的自动化测试，还可以做灰度发布，以及线上系统的自动化控制。 分布式系统的关键技术 全栈系统监控 服务 / 资源调度 流量调度； 状态/ 数据调度； 开发和运维的自动化。</p></div><footer class=entry-footer><span title='2023-01-27 23:44:14 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;66 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 分布式理论前言" href=http://blog.chalme.top/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%89%8D%E8%A8%80/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://blog.chalme.top/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=http://blog.chalme.top/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=http://blog.chalme.top/>Chalme</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>