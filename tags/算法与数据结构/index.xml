<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>算法与数据结构 on Chalme</title>
    <link>http://blog.chalme.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 算法与数据结构 on Chalme</description>
    <image>
      <url>http://blog.chalme.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://blog.chalme.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 Jan 2023 20:34:09 +0800</lastBuildDate><atom:link href="http://blog.chalme.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法与数据结构</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>本文主要是从极客时间课程中记录的理论笔记及个人练题的记录。
总体结构 时间及空间复杂度 主定理 相关资料
Big-O Complexity Chart 常见数据结构时间复杂度和空间复杂度
leetcode习题 数组/链表 反转链表 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode resNode = null; ListNode tempNode = null; while(head != null) { tempNode = head.next; head.next = resNode; resNode = head; head = tempNode; } return resNode; } } 24.</description>
    </item>
    
    <item>
      <title>类型题-二分</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%88%86/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%88%86/</guid>
      <description>33. 搜索旋转排序数组 思路 二分查找。 每一个层级的遍历，判断哪一侧是顺序的。 nums[0] &amp;lt; nums[mid] , 则左侧有序。 nums[0] &amp;gt; nums[mid] 则右侧有序。
class Solution { public int search(int[] nums, int target) { int len = nums.length; if (len == 0) { return -1; } int i = 0, j = len -1; while (i &amp;lt;= j) { int mid = (i + j) / 2; if (nums[mid] == target) { return mid; } if (nums[0] &amp;lt;= nums[mid]) { if (nums[0] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt; nums[mid]) { j = mid - 1; } else { i = mid + 1; } } else { if (nums[mid] &amp;lt; target &amp;amp;&amp;amp; target &amp;lt;= nums[len - 1]) { i = mid + 1; } else { j = mid - 1; } } } return -1; } } 4.</description>
    </item>
    
    <item>
      <title>类型题-二叉树</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>103. 二叉树的锯齿形层序遍历 offer/add; poll/remove; peek/element; 第一列属于检查，第二列如果队列为空则抛出错误。 时间复杂度：O(n) 空间复杂度: O(n)
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.offer(root); boolean even = false; while (!queue.isEmpty()) { int n = queue.size(); List&amp;lt;Integer&amp;gt; items = new ArrayList&amp;lt;&amp;gt;(); while (n -- &amp;gt; 0) { TreeNode node = queue.poll(); items.add(node.val); if (node.left != null) queue.add(node.left); if (node.right !</description>
    </item>
    
    <item>
      <title>类型题-动态规划</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>121. 买卖股票的最佳时机 思路
暴力所有情况，取最大值； 遍历一次 O(N) class Solution { public int maxProfit(int[] prices) { int price = Integer.MAX_VALUE; int profit = 0; for (int i=0; i&amp;lt;prices.length; i++) { if (prices[i] &amp;lt; price) { price = prices[i]; } else { profit = Math.max(prices[i] - price, profit); } } return profit; } } 53. 最大子数组和 思路 动态规划 dp[i] = max(dp[i-1]+nums[i], nums[i]); dp[i] 为 以 i 结尾的最大数组和
class Solution { public int maxSubArray(int[] nums) { int[] dp = new int[nums.</description>
    </item>
    
    <item>
      <title>类型题-单调栈</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>402. 移掉 K 位数字 贪心 + 单调栈
class Solution { public String removeKdigits(String num, int k) { Deque&amp;lt;Character&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); int length = num.length(); for (int i=0; i&amp;lt;length; i++) { while (!deque.isEmpty() &amp;amp;&amp;amp; k&amp;gt;0 &amp;amp;&amp;amp; deque.getLast() &amp;gt; num.charAt(i)) { deque.removeLast(); k --; } deque.addLast(num.charAt(i)); } for (int i=0; i&amp;lt;k; i++) { deque.removeLast(); } StringBuilder res = new StringBuilder(); boolean zero = true; while (!deque.isEmpty()) { char digit = deque.</description>
    </item>
    
    <item>
      <title>类型题-双指针</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>无重复字符的最长子串 滑动窗口；双指针 左右指针都只遍历一次； 时间复杂度: O(n) 空间复杂度: O(∣Σ∣) (出现的字符的次数）
class Solution { public int lengthOfLongestSubstring(String s) { Set&amp;lt;Character&amp;gt; record = new HashSet&amp;lt;&amp;gt;(); int ans = 0, n = s.length(); int j = -1; for (int i=0; i&amp;lt;n; i++) { if (i != 0) { record.remove(s.charAt(i-1)); } while (j+1 &amp;lt;n &amp;amp;&amp;amp; !record.contains(s.charAt(j+1))) { record.add(s.charAt(j+1)); j = j+1; } ans = Math.max(ans, j-i+1); } return ans; } } 15. 三数之和 思路 排序 + 双指针； 注意边界</description>
    </item>
    
    <item>
      <title>类型题-回溯搜索</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%90%9C%E7%B4%A2/</guid>
      <description>200. 岛屿数量 思路
图遍历，dfs 对于遍历过的节点， 设置&#39;2&#39; class Solution { public int numIslands(char[][] grid) { int result = 0; for (int i=0; i&amp;lt;grid.length; i++) { for (int j=0; j&amp;lt;grid[0].length; j++) { if (grid[i][j] == &amp;#39;1&amp;#39;) { dfs(grid, i, j); result ++; } } } return result; } public void dfs(char[][] grid, int i, int j) { if (i&amp;lt;0 || i&amp;gt;=grid.length || j&amp;lt;0 || j&amp;gt;=grid[0].length || grid[i][j]!=&amp;#39;1&amp;#39;) { return; } grid[i][j] = &amp;#39;2&amp;#39;; dfs(grid, i-1, j); dfs(grid, i+1, j); dfs(grid, i, j+1); dfs(grid, i, j-1); } } 46.</description>
    </item>
    
    <item>
      <title>类型题-栈</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E6%A0%88/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E6%A0%88/</guid>
      <description>20. 有效的括号 思路 使用栈结构来处理
394. 字符串解码 栈 递归 class Solution { int ptr; String src ; public String decodeString(String s) { this.src = s; ptr = 0; LinkedList&amp;lt;String&amp;gt; stack = new LinkedList&amp;lt;&amp;gt;(); while (ptr &amp;lt; s.length()) { Character c = s.charAt(ptr); if (Character.isDigit(c)) { String digits = getDigits(); stack.addLast(digits); } else if (Character.isLetter(c) || c == &amp;#39;[&amp;#39;) { stack.addLast(String.valueOf(c)); ptr ++; } else { System.out.println(stack); ptr ++; LinkedList&amp;lt;String&amp;gt; l = new LinkedList&amp;lt;&amp;gt;(); while (!</description>
    </item>
    
    <item>
      <title>类型题-链表</title>
      <link>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 29 Jan 2023 20:34:09 +0800</pubDate>
      
      <guid>http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E9%93%BE%E8%A1%A8/</guid>
      <description>25. K 个一组翻转链表 相对比较简单的
计算循环体的个数 c = n/k; c == 0 直接返回; c &amp;gt; 0 每个子循环处理； 子循环处理， 重点在于记录每个子循环的起点和终点 以及 当前的终点；用于每个子循环的链接 class Solution { public ListNode reverseKGroup(ListNode head, int k) { int n = 0 ; ListNode tempNode = head; while (tempNode != null) { tempNode = tempNode.next; n = n + 1; } int c = n / k; if (c == 0) { return head; } else { ListNode result = null; ListNode temp = null; ListNode lastNode = null; while (c-- &amp;gt; 0) { int nk = k; ListNode start = null; ListNode end = null; while (nk-- &amp;gt; 0) { if (end == null) { end = head; } temp = head.</description>
    </item>
    
  </channel>
</rss>
