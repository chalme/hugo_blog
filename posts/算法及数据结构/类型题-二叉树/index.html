<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>类型题-二叉树 | Chalme</title><meta name=keywords content="算法与数据结构"><meta name=description content="103. 二叉树的锯齿形层序遍历 offer/add; poll/remove; peek/element; 第一列属于检查，第二列如果队列为空则抛出错误。 时间复杂度：O(n) 空间复杂度: O(n)
class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) { return result; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); boolean even = false; while (!queue.isEmpty()) { int n = queue.size(); List<Integer> items = new ArrayList<>(); while (n -- > 0) { TreeNode node = queue.poll(); items.add(node.val); if (node.left != null) queue.add(node.left); if (node.right !"><meta name=author content="Me"><link rel=canonical href=http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://blog.chalme.top/favicon_io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://blog.chalme.top/favicon_io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://blog.chalme.top/favicon_io/favicon-32x32.png><link rel=apple-touch-icon href=http://blog.chalme.top/favicon_io/apple-touch-icon.png><link rel=mask-icon href=http://blog.chalme.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="类型题-二叉树"><meta property="og:description" content="103. 二叉树的锯齿形层序遍历 offer/add; poll/remove; peek/element; 第一列属于检查，第二列如果队列为空则抛出错误。 时间复杂度：O(n) 空间复杂度: O(n)
class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) { return result; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); boolean even = false; while (!queue.isEmpty()) { int n = queue.size(); List<Integer> items = new ArrayList<>(); while (n -- > 0) { TreeNode node = queue.poll(); items.add(node.val); if (node.left != null) queue.add(node.left); if (node.right !"><meta property="og:type" content="article"><meta property="og:url" content="http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:image" content="http://blog.chalme.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-10T20:34:11+08:00"><meta property="article:modified_time" content="2023-03-10T20:34:11+08:00"><meta property="og:site_name" content="Chalme"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.chalme.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="类型题-二叉树"><meta name=twitter:description content="103. 二叉树的锯齿形层序遍历 offer/add; poll/remove; peek/element; 第一列属于检查，第二列如果队列为空则抛出错误。 时间复杂度：O(n) 空间复杂度: O(n)
class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) { return result; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); boolean even = false; while (!queue.isEmpty()) { int n = queue.size(); List<Integer> items = new ArrayList<>(); while (n -- > 0) { TreeNode node = queue.poll(); items.add(node.val); if (node.left != null) queue.add(node.left); if (node.right !"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://blog.chalme.top/posts/"},{"@type":"ListItem","position":2,"name":"类型题-二叉树","item":"http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"类型题-二叉树","name":"类型题-二叉树","description":"103. 二叉树的锯齿形层序遍历 offer/add; poll/remove; peek/element; 第一列属于检查，第二列如果队列为空则抛出错误。 时间复杂度：O(n) 空间复杂度: O(n)\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); boolean even = false; while (!queue.isEmpty()) { int n = queue.size(); List\u0026lt;Integer\u0026gt; items = new ArrayList\u0026lt;\u0026gt;(); while (n -- \u0026gt; 0) { TreeNode node = queue.poll(); items.add(node.val); if (node.left != null) queue.add(node.left); if (node.right !","keywords":["算法与数据结构"],"articleBody":"103. 二叉树的锯齿形层序遍历 offer/add; poll/remove; peek/element; 第一列属于检查，第二列如果队列为空则抛出错误。 时间复杂度：O(n) 空间复杂度: O(n)\nclass Solution { public List\u003cList\u003cInteger\u003e\u003e zigzagLevelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e result = new ArrayList\u003c\u003e(); if (root == null) { return result; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.offer(root); boolean even = false; while (!queue.isEmpty()) { int n = queue.size(); List\u003cInteger\u003e items = new ArrayList\u003c\u003e(); while (n -- \u003e 0) { TreeNode node = queue.poll(); items.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } if (even) { Collections.reverse(items); } even = !even; result.add(items); } return result; } } 236. 二叉树的最近公共祖先 思路 公共祖先存在两种情况。\nroot, q,p 分属两侧； root 为 q , p 在左侧; root 为 p, q 在右侧. class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left == null) { return right; } if (right == null) { return left; } return root; } } 199. 二叉树的右视图 思路 层序遍历\n124. 二叉树中的最大路径和 思路\n递归 具体： 递归方法 maxValue 经过该 root 最大路径值 = max(0, maxValue(node.left)) + node.value + max(0, maxValue(node.right)) 该节点的最大贡献值 = node.val + max(left, right) class Solution { private int result = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { maxValue(root); return result; } public int maxValue(TreeNode root) { if (root == null) { return 0; } int left = Math.max(0, maxValue(root.left)); int right = Math.max(0, maxValue(root.right)); int newPathValue = root.val + left + right; result = Math.max(result, newPathValue); return root.val + Math.max(left, right); } } 129. 求根节点到叶节点数字之和 BFS / DFS\n// BFS class Solution { public int sumNumbers(TreeNode root) { int res = 0; Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); Queue\u003cInteger\u003e nums = new LinkedList\u003c\u003e(); queue.add(root); nums.add(root.val); while (!queue.isEmpty()) { TreeNode node = queue.poll(); Integer itemNum = nums.poll(); if (node.left == null \u0026\u0026 node.right == null) { res = res + itemNum; } else { if (node.left != null) { queue.add(node.left); nums.add(itemNum * 10 + node.left.val); } if (node.right != null) { queue.add(node.right); nums.add(itemNum * 10 + node.right.val); } } } return res; } } // dfs class Solution { public int sumNumbers(TreeNode root) { return dfs(root, 0); } public int dfs(TreeNode root, int preSum) { if (root == null) { return 0; } int sum = preSum * 10 + root.val; if (root.left == null \u0026\u0026 root.right == null) { return sum; } else { return dfs(root.left, sum) + dfs(root.right, sum); } } } 101. 对称二叉树 思路 递归\nclass Solution { public boolean isSymmetric(TreeNode root) { return check(root, root); } private boolean check(TreeNode p, TreeNode q) { if (p == null \u0026\u0026 q == null) { return true; } if (p == null || q == null) { return false; } return p.val == q.val \u0026\u0026 check(p.left, q.right) \u0026\u0026 check(p.right, q.left); } } 114. 二叉树展开为链表 class Solution { public void flatten(TreeNode root) { List\u003cTreeNode\u003e list = new ArrayList\u003cTreeNode\u003e(); preorderTraversal(root, list); int size = list.size(); for (int i = 1; i \u003c size; i++) { TreeNode prev = list.get(i - 1), curr = list.get(i); prev.left = null; prev.right = curr; } } public void preorderTraversal(TreeNode root, List\u003cTreeNode\u003e list) { if (root != null) { list.add(root); preorderTraversal(root.left, list); preorderTraversal(root.right, list); } } } 230. 二叉搜索树中第 K 小的元素 中序遍历\nclass Solution { int k, ans; public int kthSmallest(TreeNode root, int _k) { k = _k; dfs(root); return ans; } void dfs(TreeNode root) { if (root == null || k \u003c= 0) return ; dfs(root.left); if (--k == 0) ans = root.val; dfs(root.right); } } class Solution { public int kthSmallest(TreeNode root, int k) { Deque\u003cTreeNode\u003e d = new ArrayDeque\u003c\u003e(); while (root != null || !d.isEmpty()) { while (root != null) { d.addLast(root); root = root.left; } root = d.pollLast(); if (--k == 0) return root.val; root = root.right; } return -1; // never } } 226. 翻转二叉树 class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } } 297. 二叉树的序列化与反序列化 public class Codec { public String serialize(TreeNode root) { return rserialize(root, \"\"); } public TreeNode deserialize(String data) { String[] dataArray = data.split(\",\"); List\u003cString\u003e dataList = new LinkedList\u003cString\u003e(Arrays.asList(dataArray)); return rdeserialize(dataList); } public String rserialize(TreeNode root, String str) { if (root == null) { str += \"None,\"; } else { str += str.valueOf(root.val) + \",\"; str = rserialize(root.left, str); str = rserialize(root.right, str); } return str; } public TreeNode rdeserialize(List\u003cString\u003e dataList) { if (dataList.get(0).equals(\"None\")) { dataList.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0))); dataList.remove(0); root.left = rdeserialize(dataList); root.right = rdeserialize(dataList); return root; } } 剑指 Offer 26. 树的子结构 class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { return (A != null \u0026\u0026 B != null) \u0026\u0026 (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)); } boolean recur(TreeNode A, TreeNode B) { if(B == null) return true; if(A == null || A.val != B.val) return false; return recur(A.left, B.left) \u0026\u0026 recur(A.right, B.right); } } 104. 二叉树的最大深度 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } else { int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight, rightHeight) + 1; } } } 110. 平衡二叉树 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } else { return Math.abs(height(root.left) - height(root.right)) \u003c= 1 \u0026\u0026 isBalanced(root.left) \u0026\u0026 isBalanced(root.right); } } public int height(TreeNode root) { if (root == null) { return 0; } else { return Math.max(height(root.left), height(root.right)) + 1; } } } 958. 二叉树的完全性检验 class Solution { public boolean isCompleteTree(TreeNode root) { List\u003cANode\u003e nodes = new ArrayList(); nodes.add(new ANode(root, 1)); int i = 0; while (i \u003c nodes.size()) { ANode anode = nodes.get(i++); if (anode.node != null) { nodes.add(new ANode(anode.node.left, anode.code * 2)); nodes.add(new ANode(anode.node.right, anode.code * 2 + 1)); } } return nodes.get(i-1).code == nodes.size(); } } class ANode { // Annotated Node TreeNode node; int code; ANode(TreeNode node, int code) { this.node = node; this.code = code; } } 二叉树的直径 class Solution { int max = 1; public int diameterOfBinaryTree(TreeNode root) { dfs(root); return max -1; } public int dfs(TreeNode root) { if (root == null) { return 0; } int left = dfs(root.left); int right = dfs(root.right); max = Math.max(left + right + 1, max); return Math.max(left, right) + 1; } } 662. 二叉树最大宽度 class Solution { Map\u003cInteger, Integer\u003e min = new HashMap\u003c\u003e(); public int widthOfBinaryTree(TreeNode root) { return dfs(root, 1, 1); } public int dfs(TreeNode node, int depth, int index) { if (node == null) { return 0; } min.putIfAbsent(depth, index); return Math.max(index - min.get(depth) + 1, Math.max(dfs(node.left, depth + 1, index * 2), dfs(node.right, depth + 1, index * 2 + 1))); } } 中序遍历 class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); Deque\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(); while (root != null || !q.isEmpty()) { while (root != null) { q.push(root); root = root.left; } root = q.pop(); res.add(root.val); root = root.right; } return res; } } class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); inorder(root, res); return res; } public void inorder(TreeNode node, List\u003cInteger\u003e res) { if (node == null) { return ; } inorder(node.left, res); res.add(node.val); inorder(node.right, res); } } 112. 路径总和 思路\nbfs 递归 class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) { return false; } if (root.left == null \u0026\u0026 root.right == null) { return root.val == targetSum; } return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); } } ","wordCount":"1246","inLanguage":"en","datePublished":"2023-03-10T20:34:11+08:00","dateModified":"2023-03-10T20:34:11+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/"},"publisher":{"@type":"Organization","name":"Chalme","logo":{"@type":"ImageObject","url":"http://blog.chalme.top/favicon_io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://blog.chalme.top/ accesskey=h title="Chalme (Alt + H)"><img src=http://blog.chalme.top/favicon_io/apple-touch-icon.png alt aria-label=logo height=35>Chalme</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://blog.chalme.top/archives title=Archive><span>Archive</span></a></li><li><a href=http://blog.chalme.top/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://blog.chalme.top/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://blog.chalme.top/>Home</a>&nbsp;»&nbsp;<a href=http://blog.chalme.top/posts/>Posts</a></div><h1 class=post-title>类型题-二叉树</h1><div class=post-meta><span title='2023-03-10 20:34:11 +0800 +0800'>March 10, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1246 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/chalme/hugo_blog/blob/main/content/posts/%e7%ae%97%e6%b3%95%e5%8f%8a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e7%b1%bb%e5%9e%8b%e9%a2%98-%e4%ba%8c%e5%8f%89%e6%a0%91.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#103-二叉树的锯齿形层序遍历httpsleetcodecnproblemsbinary-tree-zigzag-level-order-traversal><a href=https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/>103. 二叉树的锯齿形层序遍历</a></a></li><li><a href=#236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>236. 二叉树的最近公共祖先</a></a></li><li><a href=#199-二叉树的右视图httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>199. 二叉树的右视图</a></a></li><li><a href=#124-二叉树中的最大路径和httpsleetcodecnproblemsbinary-tree-maximum-path-sum><a href=https://leetcode.cn/problems/binary-tree-maximum-path-sum/>124. 二叉树中的最大路径和</a></a></li><li><a href=#129-求根节点到叶节点数字之和httpsleetcodecnproblemssum-root-to-leaf-numbers><a href=https://leetcode.cn/problems/sum-root-to-leaf-numbers/>129. 求根节点到叶节点数字之和</a></a></li><li><a href=#101-对称二叉树httpsleetcodecnproblemssymmetric-tree><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a></a></li><li><a href=#114-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list><a href=https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/>114. 二叉树展开为链表</a></a></li><li><a href=#230-二叉搜索树中第-k-小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst><a href=https://leetcode.cn/problems/kth-smallest-element-in-a-bst/>230. 二叉搜索树中第 K 小的元素</a></a></li><li><a href=#226-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree><a href=https://leetcode.cn/problems/invert-binary-tree/>226. 翻转二叉树</a></a></li><li><a href=#297-二叉树的序列化与反序列化httpsleetcodecnproblemsserialize-and-deserialize-binary-tree><a href=https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/>297. 二叉树的序列化与反序列化</a></a></li><li><a href=#剑指-offer-26-树的子结构httpsleetcodecnproblemsshu-de-zi-jie-gou-lcof><a href=https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/>剑指 Offer 26. 树的子结构</a></a></li><li><a href=#104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree><a href=https://leetcode.cn/problems/maximum-depth-of-binary-tree/>104. 二叉树的最大深度</a></a></li><li><a href=#110-平衡二叉树httpsleetcodecnproblemsbalanced-binary-tree><a href=https://leetcode.cn/problems/balanced-binary-tree/>110. 平衡二叉树</a></a></li><li><a href=#958-二叉树的完全性检验httpsleetcodecnproblemscheck-completeness-of-a-binary-tree><a href=https://leetcode.cn/problems/check-completeness-of-a-binary-tree/>958. 二叉树的完全性检验</a></a></li><li><a href=#二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree><a href=https://leetcode.cn/problems/diameter-of-binary-tree/>二叉树的直径</a></a></li><li><a href=#662-二叉树最大宽度httpsleetcodecnproblemsmaximum-width-of-binary-tree><a href=https://leetcode.cn/problems/maximum-width-of-binary-tree/>662. 二叉树最大宽度</a></a></li><li><a href=#中序遍历httpsleetcodecnproblemsbinary-tree-inorder-traversal><a href=https://leetcode.cn/problems/binary-tree-inorder-traversal/>中序遍历</a></a></li><li><a href=#112-路径总和httpsleetcodecnproblemspath-sum><a href=https://leetcode.cn/problems/path-sum/>112. 路径总和</a></a></li></ul></nav></div></details></div><div class=post-content><h2 id=103-二叉树的锯齿形层序遍历httpsleetcodecnproblemsbinary-tree-zigzag-level-order-traversal><a href=https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/>103. 二叉树的锯齿形层序遍历</a><a hidden class=anchor aria-hidden=true href=#103-二叉树的锯齿形层序遍历httpsleetcodecnproblemsbinary-tree-zigzag-level-order-traversal>#</a></h2><p>offer/add; poll/remove; peek/element;
第一列属于检查，第二列如果队列为空则抛出错误。
时间复杂度：O(n)
空间复杂度: O(n)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=nf>zigzagLevelOrder</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>result</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Queue</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>queue</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>even</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(!</span><span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=o>(</span><span class=n>n</span> <span class=o>--</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>TreeNode</span> <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=n>items</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>even</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Collections</span><span class=o>.</span><span class=na>reverse</span><span class=o>(</span><span class=n>items</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>even</span> <span class=o>=</span> <span class=o>!</span><span class=n>even</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>items</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>236. 二叉树的最近公共祖先</a><a hidden class=anchor aria-hidden=true href=#236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree>#</a></h2><p><strong>思路</strong>
公共祖先存在两种情况。</p><ol><li>root, q,p 分属两侧；</li><li>root 为 q , p 在左侧;</li><li>root 为 p, q 在右侧.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>lowestCommonAncestor</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>p</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>root</span> <span class=o>==</span> <span class=n>p</span> <span class=o>||</span> <span class=n>root</span> <span class=o>==</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span> <span class=n>left</span> <span class=o>=</span> <span class=n>lowestCommonAncestor</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>q</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span> <span class=n>right</span> <span class=o>=</span> <span class=n>lowestCommonAncestor</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>q</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>left</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>right</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>left</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=199-二叉树的右视图httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>199. 二叉树的右视图</a><a hidden class=anchor aria-hidden=true href=#199-二叉树的右视图httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree>#</a></h2><p><strong>思路</strong> 层序遍历</p><h2 id=124-二叉树中的最大路径和httpsleetcodecnproblemsbinary-tree-maximum-path-sum><a href=https://leetcode.cn/problems/binary-tree-maximum-path-sum/>124. 二叉树中的最大路径和</a><a hidden class=anchor aria-hidden=true href=#124-二叉树中的最大路径和httpsleetcodecnproblemsbinary-tree-maximum-path-sum>#</a></h2><p><strong>思路</strong></p><ol><li>递归
具体：
递归方法 maxValue
经过该 root 最大路径值 = max(0, maxValue(node.left)) + node.value + max(0, maxValue(node.right))
该节点的最大贡献值 = node.val + max(left, right)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MIN_VALUE</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>maxPathSum</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>maxValue</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>maxValue</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>left</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>maxValue</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>right</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>maxValue</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>newPathValue</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>+</span> <span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>result</span><span class=o>,</span> <span class=n>newPathValue</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>+</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=129-求根节点到叶节点数字之和httpsleetcodecnproblemssum-root-to-leaf-numbers><a href=https://leetcode.cn/problems/sum-root-to-leaf-numbers/>129. 求根节点到叶节点数字之和</a><a hidden class=anchor aria-hidden=true href=#129-求根节点到叶节点数字之和httpsleetcodecnproblemssum-root-to-leaf-numbers>#</a></h2><p>BFS / DFS</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// BFS
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>sumNumbers</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Queue</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>nums</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>nums</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(!</span><span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>TreeNode</span> <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>Integer</span> <span class=n>itemNum</span> <span class=o>=</span> <span class=n>nums</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>node</span><span class=o>.</span><span class=na>right</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span> <span class=o>=</span> <span class=n>res</span> <span class=o>+</span> <span class=n>itemNum</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>nums</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>itemNum</span> <span class=o>*</span> <span class=n>10</span> <span class=o>+</span> <span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>nums</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>itemNum</span> <span class=o>*</span> <span class=n>10</span> <span class=o>+</span> <span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>// dfs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>sumNumbers</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=kt>int</span> <span class=n>preSum</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>preSum</span> <span class=o>*</span> <span class=n>10</span> <span class=o>+</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>sum</span><span class=o>)</span> <span class=o>+</span> <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>sum</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=101-对称二叉树httpsleetcodecnproblemssymmetric-tree><a href=https://leetcode.cn/problems/symmetric-tree/>101. 对称二叉树</a><a hidden class=anchor aria-hidden=true href=#101-对称二叉树httpsleetcodecnproblemssymmetric-tree>#</a></h2><p><strong>思路</strong> 递归</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isSymmetric</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>check</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>check</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>p</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>q</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>q</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span><span class=o>.</span><span class=na>val</span> <span class=o>==</span> <span class=n>q</span><span class=o>.</span><span class=na>val</span> <span class=o>&amp;&amp;</span> <span class=n>check</span><span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>q</span><span class=o>.</span><span class=na>right</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>check</span><span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>q</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=114-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list><a href=https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/>114. 二叉树展开为链表</a><a hidden class=anchor aria-hidden=true href=#114-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>flatten</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>preorderTraversal</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>list</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>list</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>TreeNode</span> <span class=n>prev</span> <span class=o>=</span> <span class=n>list</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>1</span><span class=o>),</span> <span class=n>curr</span> <span class=o>=</span> <span class=n>list</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>prev</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>prev</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>curr</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>preorderTraversal</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>preorderTraversal</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>list</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>preorderTraversal</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>list</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=230-二叉搜索树中第-k-小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst><a href=https://leetcode.cn/problems/kth-smallest-element-in-a-bst/>230. 二叉搜索树中第 K 小的元素</a><a hidden class=anchor aria-hidden=true href=#230-二叉搜索树中第-k-小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst>#</a></h2><p>中序遍历</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span><span class=o>,</span> <span class=n>ans</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>kthSmallest</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=kt>int</span> <span class=n>_k</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>_k</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ans</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>0</span><span class=o>)</span> <span class=k>return</span> <span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(--</span><span class=n>k</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>kthSmallest</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Deque</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>d</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayDeque</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=n>root</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>!</span><span class=n>d</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=o>(</span><span class=n>root</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>d</span><span class=o>.</span><span class=na>addLast</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=n>d</span><span class=o>.</span><span class=na>pollLast</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(--</span><span class=n>k</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=k>return</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span> <span class=c1>// never
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=226-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree><a href=https://leetcode.cn/problems/invert-binary-tree/>226. 翻转二叉树</a><a hidden class=anchor aria-hidden=true href=#226-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>invertTree</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span> <span class=n>left</span> <span class=o>=</span> <span class=n>invertTree</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span> <span class=n>right</span> <span class=o>=</span> <span class=n>invertTree</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>left</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=297-二叉树的序列化与反序列化httpsleetcodecnproblemsserialize-and-deserialize-binary-tree><a href=https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/>297. 二叉树的序列化与反序列化</a><a hidden class=anchor aria-hidden=true href=#297-二叉树的序列化与反序列化httpsleetcodecnproblemsserialize-and-deserialize-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Codec</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>serialize</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>rserialize</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=s>&#34;&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>deserialize</span><span class=o>(</span><span class=n>String</span> <span class=n>data</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span><span class=o>[]</span> <span class=n>dataArray</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=na>split</span><span class=o>(</span><span class=s>&#34;,&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>dataList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>dataArray</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>rdeserialize</span><span class=o>(</span><span class=n>dataList</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>rserialize</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>str</span> <span class=o>+=</span> <span class=s>&#34;None,&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>str</span> <span class=o>+=</span> <span class=n>str</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>)</span> <span class=o>+</span> <span class=s>&#34;,&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>str</span> <span class=o>=</span> <span class=n>rserialize</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>str</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>str</span> <span class=o>=</span> <span class=n>rserialize</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>str</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>str</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>rdeserialize</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>dataList</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>dataList</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>).</span><span class=na>equals</span><span class=o>(</span><span class=s>&#34;None&#34;</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dataList</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>TreeNode</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeNode</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>dataList</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>dataList</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>rdeserialize</span><span class=o>(</span><span class=n>dataList</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>rdeserialize</span><span class=o>(</span><span class=n>dataList</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=剑指-offer-26-树的子结构httpsleetcodecnproblemsshu-de-zi-jie-gou-lcof><a href=https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/>剑指 Offer 26. 树的子结构</a><a hidden class=anchor aria-hidden=true href=#剑指-offer-26-树的子结构httpsleetcodecnproblemsshu-de-zi-jie-gou-lcof>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isSubStructure</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>A</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>B</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>A</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>B</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>recur</span><span class=o>(</span><span class=n>A</span><span class=o>,</span> <span class=n>B</span><span class=o>)</span> <span class=o>||</span> <span class=n>isSubStructure</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>B</span><span class=o>)</span> <span class=o>||</span> <span class=n>isSubStructure</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>B</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>recur</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>A</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>B</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>B</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>A</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>A</span><span class=o>.</span><span class=na>val</span> <span class=o>!=</span> <span class=n>B</span><span class=o>.</span><span class=na>val</span><span class=o>)</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>recur</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>B</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>recur</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>B</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree><a href=https://leetcode.cn/problems/maximum-depth-of-binary-tree/>104. 二叉树的最大深度</a><a hidden class=anchor aria-hidden=true href=#104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>maxDepth</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>leftHeight</span> <span class=o>=</span> <span class=n>maxDepth</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>rightHeight</span> <span class=o>=</span> <span class=n>maxDepth</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>leftHeight</span><span class=o>,</span> <span class=n>rightHeight</span><span class=o>)</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=110-平衡二叉树httpsleetcodecnproblemsbalanced-binary-tree><a href=https://leetcode.cn/problems/balanced-binary-tree/>110. 平衡二叉树</a><a hidden class=anchor aria-hidden=true href=#110-平衡二叉树httpsleetcodecnproblemsbalanced-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isBalanced</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>abs</span><span class=o>(</span><span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>-</span> <span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>))</span> <span class=o>&lt;=</span> <span class=n>1</span> <span class=o>&amp;&amp;</span> <span class=n>isBalanced</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>isBalanced</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>height</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>),</span> <span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>))</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=958-二叉树的完全性检验httpsleetcodecnproblemscheck-completeness-of-a-binary-tree><a href=https://leetcode.cn/problems/check-completeness-of-a-binary-tree/>958. 二叉树的完全性检验</a><a hidden class=anchor aria-hidden=true href=#958-二叉树的完全性检验httpsleetcodecnproblemscheck-completeness-of-a-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isCompleteTree</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>ANode</span><span class=o>&gt;</span> <span class=n>nodes</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>nodes</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>ANode</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>1</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>nodes</span><span class=o>.</span><span class=na>size</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ANode</span> <span class=n>anode</span> <span class=o>=</span> <span class=n>nodes</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>i</span><span class=o>++);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>anode</span><span class=o>.</span><span class=na>node</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>nodes</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>ANode</span><span class=o>(</span><span class=n>anode</span><span class=o>.</span><span class=na>node</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>anode</span><span class=o>.</span><span class=na>code</span> <span class=o>*</span> <span class=n>2</span><span class=o>));</span>
</span></span><span class=line><span class=cl>                <span class=n>nodes</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>ANode</span><span class=o>(</span><span class=n>anode</span><span class=o>.</span><span class=na>node</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>anode</span><span class=o>.</span><span class=na>code</span> <span class=o>*</span> <span class=n>2</span> <span class=o>+</span> <span class=n>1</span><span class=o>));</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>nodes</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>i</span><span class=o>-</span><span class=n>1</span><span class=o>).</span><span class=na>code</span> <span class=o>==</span> <span class=n>nodes</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>ANode</span> <span class=o>{</span>  <span class=c1>// Annotated Node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>TreeNode</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>code</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ANode</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>node</span><span class=o>,</span> <span class=kt>int</span> <span class=n>code</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>code</span> <span class=o>=</span> <span class=n>code</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree><a href=https://leetcode.cn/problems/diameter-of-binary-tree/>二叉树的直径</a><a hidden class=anchor aria-hidden=true href=#二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>max</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>diameterOfBinaryTree</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max</span> <span class=o>-</span><span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>left</span> <span class=o>=</span> <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>right</span> <span class=o>=</span> <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>max</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>max</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>)</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=662-二叉树最大宽度httpsleetcodecnproblemsmaximum-width-of-binary-tree><a href=https://leetcode.cn/problems/maximum-width-of-binary-tree/>662. 二叉树最大宽度</a><a hidden class=anchor aria-hidden=true href=#662-二叉树最大宽度httpsleetcodecnproblemsmaximum-width-of-binary-tree>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>min</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>widthOfBinaryTree</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dfs</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>1</span><span class=o>,</span> <span class=n>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>node</span><span class=o>,</span> <span class=kt>int</span> <span class=n>depth</span><span class=o>,</span> <span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>min</span><span class=o>.</span><span class=na>putIfAbsent</span><span class=o>(</span><span class=n>depth</span><span class=o>,</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>index</span> <span class=o>-</span> <span class=n>min</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>depth</span><span class=o>)</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>dfs</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>index</span> <span class=o>*</span> <span class=n>2</span><span class=o>),</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>index</span> <span class=o>*</span> <span class=n>2</span> <span class=o>+</span> <span class=n>1</span><span class=o>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=中序遍历httpsleetcodecnproblemsbinary-tree-inorder-traversal><a href=https://leetcode.cn/problems/binary-tree-inorder-traversal/>中序遍历</a><a hidden class=anchor aria-hidden=true href=#中序遍历httpsleetcodecnproblemsbinary-tree-inorder-traversal>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>inorderTraversal</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>Deque</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>q</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=o>(</span><span class=n>root</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>!</span><span class=n>q</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=o>(</span><span class=n>root</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>q</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=na>pop</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>inorderTraversal</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>res</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>inorder</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>node</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>res</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>res</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>res</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=112-路径总和httpsleetcodecnproblemspath-sum><a href=https://leetcode.cn/problems/path-sum/>112. 路径总和</a><a hidden class=anchor aria-hidden=true href=#112-路径总和httpsleetcodecnproblemspath-sum>#</a></h2><p><strong>思路</strong></p><ol><li>bfs</li><li>递归</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasPathSum</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=kt>int</span> <span class=n>targetSum</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>==</span> <span class=n>targetSum</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>hasPathSum</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>targetSum</span> <span class=o>-</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>)</span> <span class=o>||</span> <span class=n>hasPathSum</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>targetSum</span> <span class=o>-</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://blog.chalme.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>算法与数据结构</a></li></ul><nav class=paginav><a class=prev href=http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E4%BA%8C%E5%88%86/><span class=title>« Prev</span><br><span>类型题-二分</span></a>
<a class=next href=http://blog.chalme.top/posts/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%B1%BB%E5%9E%8B%E9%A2%98-%E6%A0%88/><span class=title>Next »</span><br><span>类型题-栈</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://pc-chalme.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2023 <a href=http://blog.chalme.top/>Chalme</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>